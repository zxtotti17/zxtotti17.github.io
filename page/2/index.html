<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="author" content="zx">
    
    <meta name="description" content="一个在夏天会被芒果砸到的城市靠写代码为生的前职业电竞选手">
    
    
    
    
    
    
    <title>Fly的博客</title>
    <!-- inject:style -->
    <link href="/css/style.css" rel="stylesheet" type="text/css">
    <!-- endinject -->
    <style>
        .cube-loading {
            top: 0;
            position: fixed;
            width: 100%;
            height: 100%;
            background: url('/images/lg/loading.gif') no-repeat center center;
            background-color: rgba(0,0,0,.7);
        }

        .cube-loading.out {
            display: none;
        }

        .cube-loading:before {
            display: block;
            content: 'Loading';
            position: relative;
            width: 100%;
            top: 50%;
            right: -50%;
            color: #fff;
        }

        @media(max-width: 768px) {
            .cube-loading:before {
                font-size: 1.2em;
                transform: translate(-24px,20px);
                -webkit-transform: translate(-24px,20px);
                -o-transform: translate(-24px,20px);
                -ms-transform: translate(-24px,20px);
            }
        }

        @media(min-width: 768px) {
            .cube-loading:before {

            }
        }
    </style>
    
<meta name="generator" content="Hexo 4.2.1"></head>
<body>
<div class="cube-body">
    <nav id="cube-top-memu" class="cube-menu">
    <ul class="cube-menu-collapse">
        
        <li>
            <i class="cube-icon cube-icon-home" aria-hidden="true"></i>
            <a href="/">首页</a>
        </li>
        
        <li>
            <i class="cube-icon cube-icon-archive" aria-hidden="true"></i>
            <a href="/archives">归档</a>
        </li>
        
        <li>
            <i class="cube-icon cube-icon-categories" aria-hidden="true"></i>
            <a href="/categories">分类</a>
        </li>
        
        <li>
            <i class="cube-icon cube-icon-tags" aria-hidden="true"></i>
            <a href="/tags">标签</a>
        </li>
        
        <li>
            <i class="cube-icon cube-icon-about" aria-hidden="true"></i>
            <a href="/about-me">关于我</a>
        </li>
        
    </ul>
</nav>
<nav class="cube-side-menu" id="cube-side-menu">
    <ul class="cube-menu-list">
        
        <li>
            <a class="scroll-to-top">Top</a>
        </li>
    </ul>
</nav>
    <header class="cube-header" id="cube-header">
    <img src=" images/monile_bg.jpg " alt="头部背景图片">
    
    <div class="cube-type">
        <span class="cube-typed-title">一个逗比 --Fly</span>
        <span class="cube-typed-cursor">|</span>
    </div>
    
</header>

    <style>
        nav.cube-menu:before {
            content: '';
            visibility: hidden;
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 44px;
        
            filter: blur(5px);
            -webkit-filter: blur(5px);
        
            z-index: -1;
            background-image: url('/images/bg.jpg');
            background-repeat: no-repeat;
            background-position: center 44px;
            background-size: cover;
            background-color: transparent;
        }

        header.cube-background.cube-header-background {
            visibility: hidden;
            background-image: url('/images/bg.jpg');
            background-position: center 0;
        }
    </style>
    <header class="cube-background cube-header-background">
        
        <div class="cube-type">
            <span class="cube-typed-title">一个逗比 --Fly</span>
            <span class="cube-typed-cursor">|</span>
        </div>
        
    </header>
    <div class="load-header-background"></div>
    <script>
        (function (window) {

            window.headerModule = {}
            window.headerModule.image = {
                width: '1920',
                height: '700'
            }

        })(window)
    </script>
    
    <div class="cube-content">
        <div class="cube-left">
            
<div class="cube-excerpt" id="cube-excerpt-Gin-Vue-Admin">
    <header class="cube-excerpt-header">
        <h1><a href="/post/gin-vue-admin.html">Gin-Vue-Admin</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2022-09-09
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/go/" class="cube-excerpt-tag-link">#go</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <p>服务端用go的gin框架下的开源后台系统，后台部分使用的是vue3.0开发<br>从github上down下服务器代码 <a href="https://github.com/flipped-aurora/gin-vue-admin" target="_blank" rel="noopener">https://github.com/flipped-aurora/gin-vue-admin</a><br>set GOPROXY=<a href="https://goproxy.cn,direct" target="_blank" rel="noopener">https://goproxy.cn,direct</a><br>1.先进入server目录 安装对应的资源包  go generate -x<br>安装完依赖之后 go build main.go生成服务端启动文件main.exe启动<br>2.安装客户端后台， 安装node16.0以上版本， cd  web目录  npm install 安装依赖，安装完成后用npm run  serve启动前端<br>浏览器进入<a href="http://127.0.0.1:8080/这个地址，后选择初始化，填写相关配置会自动生成db及数据" target="_blank" rel="noopener">http://127.0.0.1:8080/这个地址，后选择初始化，填写相关配置会自动生成db及数据</a><br>进入后台页面后即可开始vue和后台学习<br>记录下几个重要的插件使用<br>1.swag自动生成restFul文档<br>go install github.com/swaggo/swag/cmd/swag@latest  安装swag包  在到服务器目录下执行 swag init命令初始化，swag只能用在几个特定的服务端框架上自动生成文档，这里就说下gin<br>在gin的路由文件的地方引入包<br>“github.com/swaggo/gin-swagger”<br>“github.com/swaggo/gin-swagger/swaggerFiles”<br>Router := gin.Default()//获取一个引擎中间件的实例<br>Router.GET(“/swagger/*any”,  ginSwagger.WrapHandler(swaggerFiles.Handler))//关联自动生成文档<br>在服务端目录swagger/index.html即可查看相关文档信息<br>2.gorm 谷歌的一个库方便对数据库的使用，简化了开发及安全，不方便用于复杂sql的使用<br>在db初始化的地方引入包<br>“gorm.io/driver/mysql”<br>“gorm.io/gorm”<br>从设定的配置文件中加载配置信息，用gorm.open建立连接</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">func GormMysqlByConfig(m config.Mysql) *gorm.DB &#123;
 if m.Dbname &#x3D;&#x3D; &quot;&quot;  &#123;
  return nil
 &#125;
 mysqlConfig :&#x3D;  mysql.Config&#123;
  DSN:                       m.Dsn(), &#x2F;&#x2F; DSN data source  name
  DefaultStringSize:         191,     &#x2F;&#x2F; string  类型字段的默认长度
  SkipInitializeWithVersion: false,   &#x2F;&#x2F; 根据版本自动配置
 &#125;
 if db,  err :&#x3D; gorm.Open(mysql.New(mysqlConfig), internal.Gorm.Config()); err !&#x3D; nil  &#123;
  panic(err)
 &#125; else &#123;
  sqlDB, _ :&#x3D;  db.DB()
  sqlDB.SetMaxIdleConns(m.MaxIdleConns)
  sqlDB.SetMaxOpenConns(m.MaxOpenConns)
  return  db
 &#125;
&#125;</code></pre>
<p>返回的db存放在全局global.GVA_DB，使用上依据gorm的语法规则<br>global.GVA_DB.Where(“id = ?”,  info.Uint()).Delete(&amp;system.SysAutoCodeHistory{}).Error </p>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/post/gin-vue-admin.html">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-Go的调度">
    <header class="cube-excerpt-header">
        <h1><a href="/post/go%E7%9A%84%E8%B0%83%E5%BA%A6.html">Go的调度</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2022-09-09
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/go/" class="cube-excerpt-tag-link">#go</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <p>go语言中的调度是个G-P-M的模型<br>G: G代表的是一个goroutine对象，常说的协程，真正携带代码执行逻辑的部分。<br>M：M代表的是一个内核级线程，所有的G任务，最终还是在M上执行。<br>P：P代表的是一个处理器，P是用一个全局数组（255）来保存的，并且维护着一个全局的P空闲链表，一个P可以对应多个M,但同一时刻只能与一个M绑定关系，<br>goroutine对应的结构如下，Go语言中，每一个goroutine是一个独立的执行单元，相较于每个OS线程固定分配2M内存的模式，goroutine的栈采取了动态扩容方式，  初始时仅为2KB，随着任务执行按需增长，最大可达1GB，且完全由golang自己的调度器 Go Scheduler 来调度</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">type g struct &#123;
  stack       stack        &#x2F;&#x2F; 描述了当前 Goroutine 的栈内存范围  [stack.lo, stack.hi)
  stackguard0 uintptr &#x2F;&#x2F; 是对比 Go 栈增长的 prologue 的栈指针,  可以用于调度器抢占式调度
  stackguard1 uintptr &#x2F;&#x2F; 是对比 C 栈增长的 prologue 的栈指针
  ...
   _panic       *_panic &#x2F;&#x2F; 最内侧的 panic 结构体
  _defer       *_defer &#x2F;&#x2F;  最内侧的延迟函数结构体
  m              *m     &#x2F;&#x2F; 当前的m
  sched          gobuf   &#x2F;&#x2F;  goroutine切换时，用于保存g的上下文      
  ...
  param          unsafe.Pointer &#x2F;&#x2F;  用于传递参数，睡眠时其他goroutine可以设置param，唤醒时该goroutine可以获取
  atomicstatus   uint32 &#x2F;&#x2F;  Goroutine 的状态
  stackLock      uint32 
  goid           int64  &#x2F;&#x2F;  goroutine的ID
  ...
  waitsince      int64 &#x2F;&#x2F; g被阻塞的大体时间
  preempt        bool &#x2F;&#x2F; 抢占信号
  preemptStop   bool &#x2F;&#x2F; 抢占时将状态修改成 &#96;_Gpreempted&#96;
   preemptShrink bool &#x2F;&#x2F; 在同步安全点收缩栈
  ...
  lockedm        *m     &#x2F;&#x2F;  G被锁定只在这个m上运行
  ...
&#125;</code></pre>
<p>协作的抢占式调度<br>每当有 goroutine 要创建时，会被添加到 P 上的 goroutine 本地队列上，如果 P 的本地队列已满，则会维护到全局队列里。<br>在进行调度时，会优先从本地队列获取 goroutine 来执行。<br>如果本地队列没有，会从其他的 P 上偷取 goroutine。<br>如果其他 P 上也没有，则会从全局队列上获取 goroutine。<br>这样通过上面的策略，就能尽最大努力保证有 goroutine 可运行。<br>P的结构</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">type p struct &#123;
    id          int32
    status      uint32 &#x2F;&#x2F;  状态，可以为pidle&#x2F;prunning&#x2F;...
    link        puintptr
    schedtick    uint32     &#x2F;&#x2F; 每调度一次加1
    syscalltick uint32     &#x2F;&#x2F; 每一次系统调用加1
     sysmontick  sysmontick 
    m           muintptr   &#x2F;&#x2F; 回链到关联的m
     mcache      *mcache &#x2F;&#x2F;当前m的内存缓存，意味着不必为每一个M都配备一块内存，避免了过多的内存消耗。
    pcache       pageCache
    raceprocctx uintptr
    ......
    &#x2F;&#x2F; goroutine  ids的缓存，摊销对runtime-sched.goidgen的访问。
    goidcache    uint64
     goidcacheend uint64
    
    &#x2F;&#x2F; 可运行的goroutine的队列. 不需要锁即可访问
    runqhead  uint32
    runqtail uint32
    runq     [256]guintptr
    runnext guintptr &#x2F;&#x2F; 下一个运行的g，以高优先级执行 unblock G，提高了一些包的性能。
    &#x2F;&#x2F; 可用的G  (status &#x3D;&#x3D; Gdead， Gdead 表示这个goroutine目前未被使用)
    gFree struct &#123;
         gList
        n int32
    &#125;
    &#x2F;&#x2F; sudog  代表等待列表中的一个G，例如在向通道执行发送&#x2F;接收的G。
    sudogcache []*sudog
    sudogbuf    [128]*sudog
    &#x2F;&#x2F; 堆中mspan对象的缓存
    mspancache struct &#123;
        &#x2F;&#x2F; len  被用于不允许写障碍的调用代码路径中    
        len int
        buf [128]*mspan
     &#125;
    ......
    palloc persistentAlloc &#x2F;&#x2F; per-P to avoid mutex
     ......
&#125;</code></pre>
<p>M对应的线程的栈，当指定了线程栈，则M.stack→G.stack，M的PC寄存器指向G提供的函数，然后去执行</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">type m struct &#123;
    &#x2F;&#x2F; g0是带有调度栈的goroutine。
    &#x2F;&#x2F;  普通的Goroutine栈是在Heap分配的可增长的stack,而g0的stack是M对应的线程栈。
    &#x2F;&#x2F;  所有调度相关代码,会先切换到该Goroutine的栈再执行。
    g0      *g    
    ......
     gsignal       *g         &#x2F;&#x2F; 处理信号的goroutine
    ......
    tls            [6]uintptr &#x2F;&#x2F; thread-local storage
    mstartfn      func() &#x2F;&#x2F;m入口函数
     curg          *g       &#x2F;&#x2F; 当前运行的goroutine
    caughtsig     guintptr 
     p             puintptr &#x2F;&#x2F; 关联p和执行的go代码
    nextp         puintptr
     oldp          puintptr &#x2F;&#x2F; 在执行系统调用之前所附加的p
    id            int32
     mallocing     int32 &#x2F;&#x2F; 状态
    ......
    locks         int32 &#x2F;&#x2F;m的锁
     ......
    spinning      bool &#x2F;&#x2F; m不在执行g，但在积极寻找可执行的g
    blocked       bool  &#x2F;&#x2F; m是否被阻塞
    newSigstack   bool
    printlock     int8
     incgo         bool &#x2F;&#x2F; m是否在执行cgo
    freeWait      uint32 &#x2F;&#x2F;  如果为0，将安全释放g0并删除m（原子性）。
    fastrand      uint32
    ......
     ncgocall      uint64      &#x2F;&#x2F; cgo调用的总数
    ncgo          int32       &#x2F;&#x2F;  当前cgo调用的数目
    ......
    park          note
    alllink       *m &#x2F;&#x2F;  用于链接allm
    schedlink     muintptr
    lockedg       *g &#x2F;&#x2F;  锁定g在当前m上执行，而不会切换到其他m
    createstack   [32]uintptr &#x2F;&#x2F; thread创建的栈
     ......
    nextwaitm     muintptr    &#x2F;&#x2F; 下一个等待的m
    ......
&#125;</code></pre>
<p>M 优先从 P 的本地队列获取 goroutine，减少并发竞争。并且保证了最多跟 CPU 核心数一样的 goroutine  数量在并行运行，充分利用了多核优势</p>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/post/go%E7%9A%84%E8%B0%83%E5%BA%A6.html">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-node.js对接protobuff及protobuff3">
    <header class="cube-excerpt-header">
        <h1><a href="/post/node-js%E5%AF%B9%E6%8E%A5protobuff%E5%8F%8Aprotobuff3.html">node.js对接protobuff及protobuff3</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2022-09-07
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/node-js/" class="cube-excerpt-tag-link">#node.js</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <p>protobuf作为现在最流行的序列化数据结构的协议格式之一，被广泛运用在跨平台的数据交互中，它提升了数据传输过程的时间效率和空间效率，空间效率是JSON的2-5倍，时间效率要高，对于数据大小敏感，传输效率高的模块可以采用protobuf库，同时比明文传输也更加安全，缺点就是消息结构的可读性不高<br>对接<br>首先先在环境中 用npm install  protocol-buffers安装上proto对应插件，当然也可以选择别的proto的相关插件功能是一样的，在参数返回客户端的地方加上序列化转换成buffer数据</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">public after(err: any, msg: any, session: any, resp: any, next: any)  &#123;
        if (afterLogRoute[msg.__route__]) &#123;
            if (resp.data  &amp;&amp; resp.data.user &amp;&amp; resp.data.user.id) &#123;
                let  actor_id &#x3D; resp.data &amp;&amp; resp.data.user.id;
                 this.logRouter(session, msg, actor_id);
            &#125;
        &#125;
         &#x2F;&#x2F; nodejs 使用protocol-buffers 这个库进行编解码的操作
        &#x2F;&#x2F; 加载协议文件中的模型
         const schema:any &#x3D; protobuf(fs.readFileSync(__dirname + &#39;&#x2F;test.proto&#39;,  &#39;utf-8&#39;));&#x2F;&#x2F;测试使用
        &#x2F;&#x2F; schema里面有两个函数，一个是编码的函数，一个是解码的函数
        &#x2F;&#x2F;      encode: [Function: encode] &#123; bytes: 0 &#125;,
        &#x2F;&#x2F;     decode: [Function:  decode] &#123; bytes: 0 &#125;,
        &#x2F;&#x2F; console.log(schema);
        &#x2F;&#x2F;  输出结果
        &#x2F;*
        Messages &#x3D;  &#123;
            Column:  &#123;
                type: 2,
                message:  true,
                name: &#39;Column&#39;,
                buffer:  true,
                encode: [Function: encode] &#123; bytes: 0  &#125;,
                decode: [Function: decode] &#123; bytes: 0  &#125;,
                encodingLength: [Function:  encodingLength],
                dependencies: [ [Object], [Object], [Object]  ]
            &#125;
        &#125;
        *&#x2F;
        
        &#x2F;&#x2F; Using  function about package protobuf
        &#x2F;&#x2F;  将数据根据模型，也就是.proto协议中定义的Column，传入并使用encode函数生成buffer
        const buffer &#x3D;  schema.Column.encode(&#123;
            id: 1,
            name:  &quot;Node.js&quot;,
            price: 80.4
        &#125;)
         console.log(buffer);
        next(err, msg, session, resp);
&#125;</code></pre>
<p>其中要新建一个测试用的test.proto的配置文件，内容对应返回的数据格式</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">message Column &#123;
    required int32 id &#x3D; 1;
    required string name &#x3D;  2;
    required float price &#x3D; 3;
&#125;</code></pre>
<p>这里测试用的是fs异步读取的形式，真正使用最好在程序启动时  app.use()调用上插件，在插件中用map记录路由，遍历路由读取配置文件放进内存静态变量<br>在与客户端交互返回的时候直接调用即可<br>客户端读取的时候同样需要用proto进行decode的解码，所以配置文件服务端客户端各一份</p>
<p>protobuf是谷歌的一套消息协议，具体介绍不说了，记录下使用及基本数据结构<br>protobuf的协议一般不会被node直接编译，所以使用中需要将协议文件放入指定文件夹通过命令自动化拷贝到编译好的项目文件下</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&quot;scripts&quot;: &#123;
    &quot;clear&quot;: &quot;rimraf -rf dist types lib coverage  .nyc_output&quot;,
    &quot;make_dir&quot;: &quot;md dist\\logs\\&quot;,
    &quot;copy&quot;: &quot;xcopy  src\\config\\*.* dist\\config\\ &#x2F;e&#x2F;y &amp;&amp; xcopy src\\public\\*.*  dist\\public\\ &#x2F;e&#x2F;y &amp;&amp; xcopy src\\scripts\\*.* dist\\scripts\\ &#x2F;e&#x2F;y  &quot;,
    &quot;start&quot;: &quot;cross-env NODE_ENV&#x3D;development node .&#x2F;dist&#x2F;app.js&quot;,
     &quot;pomelo_start&quot;: &quot;pomelo start&quot;,
    &quot;build&quot;: &quot;npm run clear &amp;&amp; npm  run make_dir &amp;&amp; npm run copy &amp;&amp; tsc&quot;,
    &quot;build:ts&quot;: &quot;npm  run clear &amp;&amp; npm run make_dir &amp;&amp; npm run copy &amp;&amp; tsc  --sourceMap true --removeComments false --outDir dist --declaration  --declarationDir dist&#x2F;types&quot;,
    &quot;test&quot;: &quot;cross-env NODE_ENV&#x3D;development  cross-env TEST_MODE&#x3D;true nyc mocha --require ts-node&#x2F;register --exit --reporter  spec .&#x2F;**&#x2F;*.spec.ts&quot;,
    &quot;test:coverage&quot;: &quot;cross-env NODE_ENV&#x3D;development  cross-env TEST_MODE&#x3D;true nyc mocha --exit --reporter spec&quot;,
    &quot;check&quot;:  &quot;echo \&quot;Checking...\&quot; &amp;&amp; tsc &amp;&amp; npm run tslint&quot;,
     &quot;tslint&quot;: &quot;tslint -c tslint.json -p tsconfig.json&quot;,
    &quot;start:ts&quot;: &quot;npm run  build:ts &amp;&amp; npm run start&quot;
  &#125;,</code></pre>
<p>主要用到copy的脚本去拷贝对应目录下的文件夹到编译后的文件中<br>.proto Type Notes C++ Type Java Type Python Type[2] Go Type Ruby Type C#  Type PHP Type<br>double    double double float float64 Float double float<br>float    float float float float32 Float float float<br>int32 使用变长编码，对于负值的效率很低，如果你的域有可能有负值，请使用sint64替代 int32 int int int32 Fixnum  或者 Bignum（根据需要） int integer<br>uint32 使用变长编码 uint32 int int/long uint32 Fixnum  或者  Bignum（根据需要） uint integer<br>uint64 使用变长编码 uint64 long int/long uint64 Bignum ulong integer/string<br>sint32 使用变长编码，这些编码在负值时比int32高效的多 int32 int int int32 Fixnum  或者  Bignum（根据需要） int integer<br>sint64 使用变长编码，有符号的整型值。编码时比通常的int64高效。 int64 long int/long int64 Bignum long integer/string<br>fixed32 总是4个字节，如果数值总是比总是比228大的话，这个类型会比uint32高效。 uint32 int int uint32 Fixnum  或者  Bignum（根据需要） uint integer<br>fixed64 总是8个字节，如果数值总是比总是比256大的话，这个类型会比uint64高效。 uint64 long int/long uint64 Bignum ulong integer/string<br>sfixed32 总是4个字节 int32 int int int32 Fixnum  或者  Bignum（根据需要） int integer<br>sfixed64 总是8个字节 int64 long int/long int64 Bignum long integer/string<br>bool    bool boolean bool bool TrueClass/FalseClass bool boolean<br>string 一个字符串必须是UTF-8编码或者7-bit  ASCII编码的文本。 string String str/unicode string String  (UTF-8) string string<br>bytes 可能包含任意顺序的字节数据。 string ByteString str []byte String  (ASCII-8BIT) ByteString string<br>以上是所有proto3的数据类型，具体的使用根据我们项目中的返回数据结构定义比如<br>简单的{“merge_id”:”xxx”, “page”:1, “size”:500}</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">message getMergeListRequest  &#123;
  string merge_id &#x3D; 1;
  int32 page &#x3D; 2;
  int32 size &#x3D; 3;
&#125;</code></pre>
<p>repeated string works_ids = 5;repeated修饰符是用来修饰数组结构[“1”,”2”,”3”]<br>复杂类型需要嵌套构建如</p>
        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/post/node-js%E5%AF%B9%E6%8E%A5protobuff%E5%8F%8Aprotobuff3.html">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-服务端的安全预警">
    <header class="cube-excerpt-header">
        <h1><a href="/post/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E5%AE%89%E5%85%A8%E9%A2%84%E8%AD%A6.html">服务端的安全预警</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2022-09-07
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/%E5%AE%89%E5%85%A8/" class="cube-excerpt-tag-link">#安全</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <p>通常在服务端会为了防止攻击会设置安全限制，及有人攻击的时候及时预警通知自己，能在最短时间内封了不法分子的账号或者ip<br>达人秀中采用的预警是预警登录及获取魔域区服的接口<br>解决方案：<br>1、每日登录时切换区服查【主角色接口】达2次以上出现验证码，切换区服达6次发出预警；<br>2、每日登录时切换区服查【主角色接口】，当IP查询50次以上发出预警；<br>注：不切换区服查主角色接口（查已选择的区服）不限制，因为我们有4小时的主角色信息缓存；<br>3、同个账号每日访【区服列表】接口50次限制，发出预警；<br>4、同IP每日访问【区服列表】接口200次限制，发出预警；<br>5、以上4个事件预警发出后，5分钟内不在发送，避免消息轰炸；</p>
<p>预警模板内容： 渠道ID, 账号id、大区ID，子服ID， IP,  触发事件类型（上面3种）</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">private async addNumLimitLog(game_id:number, area_id:number, ip:string,  real_ip:string)&#123;
    logger.warn(&quot;get_sub_server ip:%s&quot;, ip);
     if(!ip || !real_ip) return false;
    let areaUrlConfig &#x3D;  pomelo.app.get(&#39;areaUrlConfig&#39;);
    let conf &#x3D;  Array.isArray(areaUrlConfig) ? areaUrlConfig[0] : areaUrlConfig;
    let  playerLimit &#x3D; conf.commonLimit || 50;
    let ipLimit &#x3D; conf.ipLimit ||  200;
    let ipWhiteList &#x3D; conf.ipWhiteList || [];
     if(ipWhiteList.indexOf(ip) &gt;&#x3D; 0 ) &#123;
        return false;
     &#125;
    if(real_ip &amp;&amp; real_ip.length &gt; 200)&#123;
         real_ip &#x3D; real_ip.slice(0,200);
    &#125;
    let playerNum &#x3D; await  AreaServerInfoRepository.getInstance().addNumLimit(game_id, area_id,  this.player_id || &#39;&#39;);
    let notice &#x3D;  pomelo.app.get(&#39;noticeService&#39;);
    let confNotice &#x3D;  pomelo.app.get(&#39;watchdogMqConfig&#39;);
    let content: string &#x3D;  confNotice.noticeLoginStr + this.platform_id + &quot; player_id: &quot; + this.player_id +  &quot; area_id: &quot; + area_id + &quot; ip: &quot; + ip;
    let userIds &#x3D;  conf.noticeMqUserIds;
    const areaIp200 &#x3D; &quot;areaIp200&quot;;
    const  areaAccount50 &#x3D; &quot;areaAccount50&quot;;    
    if(playerNum &gt;  playerLimit)&#123;
        logger.error(&quot;player limit game_id:%s  area_id:%s   playerId:%s&quot;, game_id, area_id, this.player_id);
        content +&#x3D; &quot;  event: &quot; + areaAccount50;
        for (let i &#x3D; 0; i &lt; userIds.length;  i++) &#123;
            let id &#x3D; userIds[i];
            await  notice.sendUserLimitTime(id, content, areaAccount50);
         &#125;
        await  AreaServerInfoRepository.getInstance().addClickLimitLog(1, game_id, area_id,  this.player_id, ip, real_ip);
        return  Msg.OVER_AREA_LIMIT;
    &#125;
    let ipNum &#x3D; await  AreaServerInfoRepository.getInstance().addIpNumLimit(ip);
    if(ipNum  &gt; ipLimit)&#123;
        logger.error(&quot;ip limit game_id:%s  area_id:%s   playerId:%s  ip:%s&quot;, game_id, area_id, this.player_id, ip);
         content +&#x3D; &quot; event: &quot; + areaAccount50;
        for (let i &#x3D; 0; i &lt;  userIds.length; i++) &#123;
            let id &#x3D;  userIds[i];
            await notice.sendUserLimitTime(id, content,  areaIp200);
        &#125;
        await  AreaServerInfoRepository.getInstance().addClickLimitLog(2, game_id, area_id,  this.player_id, ip, real_ip);
        return  Msg.OVER_AREA_LIMIT;
    &#125;
    return true;
&#125;</code></pre>
<p>在登录的部分加上ip及验证码使用过多的预警</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">else if (rows &amp;&amp; rows.length) &#123;
            let ipNum &#x3D; await  this.addIpLimit(info.ip);
            let notice &#x3D;  this.app.get(&#39;noticeService&#39;);
            let confNotice &#x3D;  this.app.get(&#39;watchdogMqConfig&#39;);
            let content: string &#x3D;  confNotice.noticeLoginStr + platformId + &quot; player_id: &quot; + info.player_id + &quot;  area_id: &quot; + info.area_id + &quot; server_id: &quot; + info.server_id + &quot; ip: &quot; +  info.ip;
            let userIds &#x3D; conf.noticeMqUserIds;
            const  code6 &#x3D; &quot;code6&quot;;
            const loginIp50 &#x3D; &quot;loginIp50&quot;;
             if(ipNum &gt;&#x3D; 50)&#123;
                content +&#x3D; &quot; event: &quot; +  loginIp50;
                for (let i &#x3D; 0; i &lt; userIds.length; i++)  &#123;
                    let id &#x3D; userIds[i];
                    await  notice.sendUserLimitTime(id, content, loginIp50);
                 &#125;
            &#125;
            if(rows[0].num &gt; max)&#123;
                 await this.addUserLimit(route, userCode, platformId,  rows[0].num);
                return 2;
            &#125;else if(rows[0].num  &lt; begin || rows[0].code &#x3D;&#x3D; text.toLowerCase())&#123;
                 rows[0].num++;
                if(await this.addCache(rows[0],  storage))&#123;
                    return 1;
                &#125;
             &#125; else if(rows[0].num &gt;&#x3D; 6)&#123;
                content +&#x3D; &quot; event: &quot; +  code6;
                for (let i &#x3D; 0; i &lt; userIds.length; i++)  &#123;
                    let id &#x3D; userIds[i];
                    await  notice.sendUserLimitTime(id, content, code6);
                 &#125;
            &#125;</code></pre>
<p>预警的通知限制时间，通过api网络接口发给99u及时通知</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">public async sendUserLimitTime(userId: string, content: string,  event:string): Promise&lt;any&gt; &#123;
        let conf &#x3D;  this.app.get(&#39;noticeConfig&#39;);
        let url &#x3D; conf.api_chat;
        let  time &#x3D; Math.floor(new Date().getTime() &#x2F; 1000);
        if(!time || time &lt;  this.limitTime[event] + 300)&#123;&#x2F;&#x2F;5分钟
            return 
         &#125;
        this.limitTime[event] &#x3D; time;
        &#x2F;&#x2F; 群发格式
        let  postArgs &#x3D; &#123;
            login_name : userId,
            type :  &quot;text&quot;,
            content : content
    &#125;;
        let options: RequestInit &#x3D; &#123;
            method:  &quot;POST&quot;,
            headers: &#123;
                &quot;Content-Type&quot;:  &quot;application&#x2F;json&quot;,
                &quot;Authorization&quot;: &#96;APP  appid&#x3D;4f7933e627ccbbd3,token&#x3D;757c8c2552374cfa42862435da00384e&#96;
             &#125;
        &#125;;
        options.body &#x3D; JSON.stringify(postArgs)
         let response &#x3D; await fetch(url, options);
        let data &#x3D; await  response.json();
        return data;
    &#125;</code></pre>
        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/post/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E5%AE%89%E5%85%A8%E9%A2%84%E8%AD%A6.html">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-Redis原子性应用">
    <header class="cube-excerpt-header">
        <h1><a href="/post/redis%E5%8E%9F%E5%AD%90%E6%80%A7%E5%BA%94%E7%94%A8.html">Redis原子性应用</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2022-09-07
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/redis/" class="cube-excerpt-tag-link">#redis</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <p>服务端中有时候总是会因为一些业务逻辑的不够严谨及并发条件下判断不足导致数据中出现脏数据或者累加的情况下出现数值不一致的情况（不是必现，是偶尔会产生）<br>为了避免以上情况的发生我们通常会采用的方法<br>1.数据库加事务处理，最大程度上保证数据的一致性，但是并发的情况下还是有可能出现脏数据<br>2.通过数据库本身的约束条件，主键约束 ，  唯一索引等约束数据的一致性，能保证脏数据不产生，但是累加的更新在业务层上的锁定无法保证<br>3.通过业务层加锁来保证并发情况下更新累加数据的一致性，如redis分布式锁，或者不做累加只用赋值，通过再次查询一遍数据库值做加法后赋值，这样并发的情况下只会重复更新不会累加多值<br>前2种不说，着重说第3种，redis是单进程的，redis分布式锁就是用到某些语句的原子性特点，保证当前执行锁住只会执行一次如incr命令<br>阅读数场景<br>原先使用get key命令获取缓存参数在set 更新，但是这个命令是非原子性，累加并发的情况就会出现多次累加<br>原先的做法只是load，加分布式锁后在load前后用incr加上key ,在取会数值时候释放incr锁住的key值，这是比较好的做法<br>最好好是用lua脚本实现redis锁</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">public async getOrAdd(databaseId: string, table: string, rowKey: string,  rows: any, opts?: any): Promise&lt;any&gt; &#123;
        let lockKey &#x3D;  &#96;$&#123;rowKey&#125;:__lock__&#96;;
        let flag &#x3D; opts.queryFlag;
        let  redisDb: Database &#x3D; this.service.connect(databaseId);
        let lockState &#x3D;  await this.incrby(databaseId, lockKey, 1);
        &#x2F;&#x2F;锁定原子并发
        if  (lockState !&#x3D;&#x3D; 1) &#123;
            return &#123; error: &#96;table:$&#123;table&#125; key:$&#123;rowKey&#125;  has be locked($&#123;lockState&#125;) of get or add options.&#96; &#125;;
        &#125;
         &#x2F;&#x2F;最多锁定1分钟,自动解除锁定
        await redisDb.removeAsync(this.getRowKey(lockKey), &#123;  mode: CommandMode.Key, expired: utils.nowSecond() + 60 &#125;, flag);
        let  loadRows &#x3D; await this.load(databaseId, table, rowKey, opts);
        if  (!loadRows || (Array.isArray(loadRows) &amp;&amp; loadRows.length &#x3D;&#x3D;&#x3D; 0))  &#123;
            &#x2F;&#x2F;数据不存在时增加
            await this.update(databaseId, table,  rowKey, rows, opts);
            await  redisDb.removeAsync(this.getRowKey(lockKey), &#123; mode: CommandMode.Key, expired: 0  &#125;, flag);
            return &#123; created: true, data: (Array.isArray(rows) ?  rows : [rows]) &#125;;
        &#125;
        await  redisDb.removeAsync(this.getRowKey(lockKey), &#123; mode: CommandMode.Key, expired: 0  &#125;, flag);
        return &#123; created: false, data: loadRows &#125;;
    &#125;</code></pre>
<p>这时候后面在clickData[‘click_num’] += click_num;累加的时候就不会因为并发出现累加多次的情况</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">let ret: any &#x3D; await this.getOrAddDailyClick(works_id, create_time,  clickData, storage);
        if (ret.error) &#123;
             logger.error(&quot;addDailyClicks error:%s works_id:%s create_time:%s&quot;, ret.error,  works_id, create_time);
            return false;
        &#125; else if  (ret.created) &#123;
            msg +&#x3D; &#96; created.&#96;;
             this.execSync(&#39;clickSync.add&#39;, clickData);
        &#125; else &#123;
             clickData &#x3D; ret.data[0];
            msg +&#x3D; &#96;  before_num:$&#123;clickData.click_num&#125;&#96;;
            if (clickData &amp;&amp;  clickData[&#39;owner_actor&#39;] !&#x3D; owner_actor) &#123;
                 clickData[&#39;owner_actor&#39;] &#x3D; owner_actor;
            &#125;
             clickData[&#39;all_click_num&#39;] &#x3D; all_click_num;
             clickData[&#39;click_num&#39;] +&#x3D; click_num;
            clickData[&#39;update_time&#39;] &#x3D;  Math.floor(Date.now() &#x2F; 1000);
            msg +&#x3D; &#96;  after_num:$&#123;clickData.click_num&#125;&#96;;
            if (await  this.addDailyClick(clickData, create_time, storage)) &#123;
                 this.execSync(&#39;clickSync.update&#39;, clickData);
            &#125;  else
                return false;
        &#125;
还有一种方法就是牺牲性能做校验，用赋值的方式不做累加，checkRedNum校验真实的数据后替换在累加
let redCache &#x3D; await redDotsRepository.getInstance().getCharacter(actor_id,  &#39;&#39;);
            if(redCache &amp;&amp; redCache[type] &gt;&#x3D;  0)&#123;
                redCache[type] &#x3D; await  redDotsRepository.getInstance().checkRedNum(actor_id);
                 redCache[type] &#x3D; redCache[type] + num &gt;&#x3D; 0 ? redCache[type] + num :  0;
                return await  redDotsRepository.getInstance().update(actor_id, redCache, type,  redWorks);
            &#125;</code></pre>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/post/redis%E5%8E%9F%E5%AD%90%E6%80%A7%E5%BA%94%E7%94%A8.html">Read More</a>
    </footer>
</div>

<div class="cube-excerpt" id="cube-excerpt-Mysql的一些不常用的规则">
    <header class="cube-excerpt-header">
        <h1><a href="/post/mysql%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E8%A7%84%E5%88%99.html">Mysql的一些不常用的规则</a></h1>
        <div class="cube-excerpt-header-msg">
            <div class="cube-excerpt-date">
                <i class="cube-icon cube-icon-date" aria-hidden="true"></i>
                2021-11-24
            </div>
            <div class="cube-excerpt-tags">
                <i class="cube-icon cube-icon-tag" aria-hidden="true"></i>
                
                <a href="/tags/mysql/" class="cube-excerpt-tag-link">#mysql</a>
                
            </div>
        </div>
    </header>
    <article class="cube-excerpt-entry cube-markdown">
        
        
           <p>mysql的全文索引主要用在用户搜索查询，达人秀中应用是用来匹配作品内容及标题全文搜索</p>
<p>传统的匹配方式是like “%xxx%”但这样效率是很低的，在mysql 5.7版本之后提供了inodb的全文索引方式，用的是分词的形式</p>
<p>达人秀中用户主要用的是中文查找内容，但是在标题和内容中存在网页html  css等标签及无关的标点符号会影响搜索的速度，同时mysql全文索引只支持 char varchar text三种数据类型</p>
<p>那么当出现较多文字的同时就需要缩减文字精炼存储，在用专门的字段存储查询</p>
<pre><code class="bash">ALTER TABLE `works` ADD COLUMN `search_content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT &#39;&#39; COMMENT &#39;搜索文本&#39; AFTER `rich_content`;
ALTER TABLE `works` add fulltext index `title_search_content` (`title`, `search_content`) WITH PARSER ngram;</code></pre>
<p>先给对应的表结构加上字段及全文索引，包含标题及内容，采用分词的形式</p>
<p>在作品添加及更新的时候用正则表达式匹配字符串中文精炼字符串长度保证text的长度能放下，同时过滤只存在中文去掉其他</p>
<pre><code class="bash">public getSearchContent(content:string, rich_content:string)  {
        let str = matchChinses(content) + matchChinses(rich_content);
        if(str.length &gt; 16382){//中文按4个字节来算
            return str.slice(0,16382);
        }
        return str;
    }

/**
 * 正则匹配中文
 */
 export function matchChinses(content: string): any {
    if (content !== null &amp;&amp; content !== &#39;&#39;) {
        const reg = /[\u4e00-\u9fa5]/g;
        return content.match(reg).join(&#39;&#39;);
    }
    return &#39;&#39;;
}</code></pre>
<p>这样就能保证存储数据准确性又不太影响搜索的准确性及时效性</p>
<p>对于之前发布的作品采用脚本的形式一次性做匹配更新操作，定到凌晨3点跑一次做同步，避免死循环加上超时机制</p>
<pre><code class="bash">public async syncUpdateSearchContent(): Promise&lt;any&gt; {
        setTimeout(async () =&gt;{
            let page = 1;
            while(1){
                if(await this.worksService.updateSearchContent(page)){
                    page++;
                }else{
                    break;
                }
            }
            return 
        }, 60*5);
    }

public async updateSearchContent(page:number) {
        let repo = WorksRepository.getInstance();
        let ids = await repo.getNeedSearchContent(page);//取数据
        if(!ids || !ids.length) return false;
        let data = await repo.getIdsWorksData(ids);
        for(let i = 0; i &lt; data.length; i++){
            let worksData:Works = data[i];
            worksData.search_content = this.getSearchContent(worksData.content,worksData.rich_content);
            let editor = this.getEditor(worksData);
            await this.setCharacter(worksData, editor);
        }
        return true;
    }</code></pre>
<p>如果是mysql 8.0以上版本可以用REGEXP_REPLACE的方法直接在sql中匹配替换更新</p>
<ol start="2">
<li>有些不常被使用的mysql语法</li>
<li>1.union 和 union all、 Intersect 这些sql语法主要用在当我们需要查询多表数据同时需要使用多表不同字段数据的时候用这个语句避免多次连接数据库查询<br>如：<pre><code class="bash">SELECT ANY_VALUE(t.works_id) AS works_id, ANY_VALUE(SUM(t.score)) AS score FROM (SELECT ANY_VALUE(works_id) AS works_id, ANY_VALUE(SUM(click_num)) AS score FROM view_click WHERE works_id = ? AND create_time &lt;= ? GROUP BY works_id 
      UNION ALL SELECT ANY_VALUE(works_id) AS works_id, ANY_VALUE(COUNT(id) * 30) AS score FROM log_first_like WHERE works_id = ? AND create_time &lt;= ? GROUP BY works_id </code></pre>
同时union 与 union all的区别在与 当连接查询的表有同样字段的时候union all中对两个结果集进行并集操作，包括重复行，不进行排序， union则会对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序， Intersect：对两个结果集进行交集操作，不包括重复行，同时进行默认规则的排序</li>
</ol>
<p>2.2.视图View 视图就是SELECT语句执行后返回的结果集，比如当我们需要用新表的替换旧表，但需要重旧表中获取数据，可以用视图 view，将两个结果集合并视图，在查询视图，但是视图肯定不会那么高效的，所以尽量少用<br>如：</p>
<pre><code class="bash">CREATE VIEW view_click
AS 
SELECT * FROM click UNION ALL SELECT * FROM log_click</code></pre>
<p>后续当我要按时间查找新旧表数据的时候就可以直接select * from view_click where … 查找视图来查找新旧数据</p>
<p>2.3.ON DUPLICATE KEY UPDATE 这个是专门使用在插入语句中，在并发的情况的下有可能会导致业务数据判断错误，引起插入语句违反数据库限制，如主键唯一  或者 唯一索引限制引起报错，但实际上索要做的是更新对应业务数据的值就可以使用ON DUPLICATE KEY UPDATE在插入语句中去替换因为限制条件下的数据，需要注意的限制条件在插入语句中要去掉，如id做主键就需要在更新后面去掉id，唯一索引也是同理<br>如：</p>
<pre><code class="bash">INSERT INTO table (a,b,c) VALUES (1,2,3)  ON DUPLICATE KEY UPDATE c=c+1;  a为主键，b为唯一索引那么update语句中就不要带这两个字段</code></pre>
<p>但是这个语法容易导致死锁所以使用上要格外小心</p>
<p>``` bash<br>select * from user where id = 1 lock in share mode #加S锁，也称读锁，共享锁，可以事务重复添加S锁，但不能添加X锁，必须释放后才可以<br>update user set username=’javaboy’ where id=1; #会先读取X锁，也称写锁 排他锁，写锁会阻塞直到完成</p>

        
    </article>
    <footer class="cube-excerpt-footer">
        <a class="cube-excerpt-more" href="/post/mysql%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E8%A7%84%E5%88%99.html">Read More</a>
    </footer>
</div>



<ul class="cube-pagination cube-pagination-9">
    
    <li class="cube-pagination-prev">
        <a href="/">« Prev</a>
    </li>
    
    
        
            
                
                <li class="cube-pagination-index">
                    <a href="/">1</a>
                </li>
                
            
                
                <li class="cube-pagination-index disabled">
                    <span>2</span>
                </li>
                
            
                
                <li class="cube-pagination-index">
                    <a href="/page/3">3</a>
                </li>
                
            
                
                <li class="cube-pagination-index">
                    <a href="/page/4">4</a>
                </li>
                
            
                <li class="cube-pagination-ellipses">
                    <span>...</span>
                </li>
                <li class="cube-pagination-index">
                    <a href="/page/8">8</a>
                </li>
        
    

    
    <li class="cube-pagination-next">
        <a href="/page/3/">Next »</a>
    </li>
    
</ul>

<!--其他组件后续添加-->
        </div>
        <div class="cube-right">
            

<div class="cube-search cube-sidebar" id="cube-search">
    <div class="search-container">
        <input type="text" placeholder="Search" class="cube-search-input" id="cube-search-input">
        <i class="cube-icon cube-icon-search cube-search-submit" aria-hidden="true"></i>
    </div>
    <!-- TODO 通过给window赋一个全局变量，通过脚本赋值 -->
</div>
<script>
    (function (window) {
        'use strict';
        window.searchModule = {}
        window.searchModule.JSONUrl = '/content.json'
        window.searchModule.rootUrl = '/'
    })(window)
</script>
<div class="cube-search-form">
    <div class="cube-search-control">
        <input type="text" placeholder="Search" class="search-input">
        <a class="close-button">
            <i class="cube-icon cube-close" aria-hidden="true"></i>
        </a>
    </div>
    <div class="cube-search-result"></div>
</div>


<div class="cube-author cube-sidebar" id="cube-author">
    
    
    <span>zx</span>
    
    
    <a title="一个在夏天会被芒果砸到的城市靠写代码为生的前职业电竞选手">一个在夏天会被芒果砸到的城市靠写代码为生的前职业电竞选手</a>
    
    <div class="count">
        <a class="count articles"><span>44</span>Article</a>
        <a class="count tags"><span>19</span>Tags</a>
        <a class="count categories"><span>4</span>Categories</a>
    </div>
</div>



<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="https://music.163.com/outchain/player?type=2&amp;id=64561&amp;auto=0&amp;height=66"></iframe>

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="https://music.163.com/outchain/player?type=2&amp;id=1293886117&amp;auto=0&amp;height=66"></iframe>

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="https://music.163.com/outchain/player?type=2&amp;id=1489310672&amp;auto=0&amp;height=66"></iframe>

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="https://music.163.com/outchain/player?type=2&amp;id=1848802848&amp;auto=0&amp;height=66"></iframe>

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="https://music.163.com/outchain/player?type=2&amp;id=1840458962&amp;auto=0&amp;height=66"></iframe>

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="https://music.163.com/outchain/player?type=2&amp;id=1821742568&amp;auto=0&amp;height=66"></iframe>

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="https://music.163.com/outchain/player?type=2&amp;id=1833389357&amp;auto=0&amp;height=66"></iframe>




<div class="cube-recent-posts cube-sidebar" id="cube-recent-posts">
    <div class="title">
        <a>Recent Posts</a>
    </div>
    <ul class="list">
        
        
        <li>
            <!-- TODO 如果文章要显示图片，那么在front-matter上添加preview属性(url or path) -->
            
            <div class="normal">
                <p class="index first">
                    <span>1</span>
                </p>
                <p class="title">
                    <a href="/post/%E4%B8%8D%E5%90%8C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F.html" title="不同语言区别">不同语言区别</a>
                </p>
            </div>
            
        </li>
        
        
        
        <li>
            <div class="normal">
                <p class="index">
                    <span>2</span>
                </p>
                <p class="title">
                    <a href="/post/PP-%E6%B4%BB%E5%8A%A8%E4%B8%AD%E5%BF%83.html" title="PP-活动中心">PP-活动中心</a>
                </p>
            </div>
        </li>
        
        
        
        <li>
            <div class="normal">
                <p class="index">
                    <span>3</span>
                </p>
                <p class="title">
                    <a href="/post/PP-%E9%82%AE%E7%AE%B1%E9%82%AE%E4%BB%B6%E7%B3%BB%E7%BB%9F.html" title="PP-邮箱邮件系统">PP-邮箱邮件系统</a>
                </p>
            </div>
        </li>
        
        
        
        <li>
            <div class="normal">
                <p class="index">
                    <span>4</span>
                </p>
                <p class="title">
                    <a href="/post/PP-Battle.html" title="PP_Battle">PP_Battle</a>
                </p>
            </div>
        </li>
        
        
        
        <li>
            <div class="normal">
                <p class="index">
                    <span>5</span>
                </p>
                <p class="title">
                    <a href="/post/PP-%E4%BB%BB%E5%8A%A1%E7%BB%9F%E8%AE%A1%E5%B1%9E%E6%80%A7%E7%AD%9B%E9%80%89%E8%A7%A3%E9%94%81.html" title="PP-任务统计属性筛选解锁模块">PP-任务统计属性筛选解锁模块</a>
                </p>
            </div>
        </li>
        
        
    </ul>
</div>



<div class="cube-categories cube-sidebar" id="cube-categories">
    <div class="title">
        <a href="/categories">Categories</a>
    </div>
    <div class="cube-boxs">
        
        
        <div class="cube-box ">
            <a href="/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/">#开发环境安装</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/IT%E7%AC%94%E8%AE%B0/">#IT笔记</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/categories/%E8%84%9A%E6%9C%AC%E5%B7%A5%E5%85%B7/">#脚本工具</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/">#设计方法</a>
        </div>
        
    </div>
</div>



<div class="cube-tagcloud cube-sidebar" id="cube-tagcloud">
    <div class="title">
        <a href="/tags">Tagcloud</a>
    </div>
    <div class="cube-boxs">
        
        
        <div class="cube-box-bg ">
            <a href="/tags/Sentry/">#Sentry</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/Erlang/">#Erlang</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/Ruby-on-Rails/">#Ruby on Rails</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/Capistrano-%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%B7%A5%E5%85%B7/">#Capistrano 自动部署工具</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/c/">#c++</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">#设计模式</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/node-js/">#node.js</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/mongodb/">#mongodb</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/mysql/">#mysql</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/python/">#python</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/redis/">#redis</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/%E6%B8%B8%E6%88%8F/">#游戏</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/%E5%AE%89%E5%85%A8/">#安全</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/MQ/">#MQ</a>
        </div>
        
        
        <div class="cube-box ">
            <a href="/tags/%E7%AE%97%E6%B3%95/">#算法</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/nginx/">#nginx</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/td-agent/">#td-agent</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/%E9%9D%A2%E8%AF%95/">#面试</a>
        </div>
        
        
        <div class="cube-box-bg ">
            <a href="/tags/go/">#go</a>
        </div>
        
    </div>
</div>



<div class="cube-links cube-sidebar" id="cube-links">
    <div class="title">
        <a>Links</a>
    </div>
    <ul class="list">
        
        <li>
            
            
            <img src="http://cube-1252774894.cosgz.myqcloud.com/links/GitHub.png">
            
            <a href="https://github.com/zxtotti17" target="_blank">GitHub</a>
        </li>
        
        <li>
            
            
            <img src="http://cube-1252774894.cosgz.myqcloud.com/links/开发者头条.png">
            
            <a href="https://toutiao.io/u/148070" target="_blank">开发者头条</a>
        </li>
        
    </ul>
</div>

<div class="social-share" data-wechat-qrcode-title="请打开微信扫一扫"></div>

<!--  css & js -->
<link rel="stylesheet" href="dist/css/share.min.css">
<script src="dist/js/social-share.min.js"></script>


<div class="cube-friend-links cube-sidebar" id="cube-friend-links">
    <div class="title">
        <a>Friend Links</a>
    </div>
    <ul class="list">
        
        <li>
            <!-- TODO change avatar.png to friend.png-->
            <img src="http://cube-1252774894.cosgz.myqcloud.com/friend_links/micblo.png">
            <a href="http://feiilin.com/" target="_blank">图像识别c++大佬-feiilin</a>
        </li>
        
        <li>
            <!-- TODO change avatar.png to friend.png-->
            <img src="http://cube-1252774894.cosgz.myqcloud.com/friend_links/DIYgod.jpg">
            <a href="https://blog.hellozwh.com/" target="_blank">pomelo游戏-起点</a>
        </li>
        
        <li>
            <!-- TODO change avatar.png to friend.png-->
            <img src="/images/friend_links.jpg ">
            <a href="https://github.com/kon9chunkit/GitHub-Chinese-Top-Charts" target="_blank">gitHub中文排行</a>
        </li>
        
    </ul>
</div>


        </div>
    </div>
</div>
<footer class="cube-footer">
    
© 2017 zx

<br>
Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>.&nbsp;Theme by <a href="https://github.com/zxtotti17" target="_blank">Fly</a>
</footer>
<!-- inject:script -->
<script src="/js/script.js"></script>
<!-- endinject -->
<div class="cube-loading out"></div>
</body>
</html>