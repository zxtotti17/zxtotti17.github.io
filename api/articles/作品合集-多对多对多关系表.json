{"title":"作品合集-多对多对多关系表","uid":"f93992fa9cfdd90a84e68e7ac1ad2636","slug":"作品合集-多对多对多关系表","date":"2021-07-27T07:38:58.000Z","updated":"2021-11-30T09:01:12.663Z","comments":true,"path":"api/articles/作品合集-多对多对多关系表.json","keywords":"node.js blogs IT 互联网 服务端 游戏 mysql redis","cover":[],"content":"<p>作品合集的背景是在原有话题上加入标签，让话题和标签有多对多的关系即 A-&gt;B，新的合集表C是由标签B合并成合集也是多对多关系即 B-&gt;C, 同时对于用户来说，用户只关心对应的话题，对应话题条件加入合集即 A-&gt;C,传统的多对多关系一般是建立中间关联表用作中转的关联（传统的关系表中A-B关系就分出一个A-B的各主键关联关系表，B-C和C-A也是一样，但是这时候如果改动一个A上的B属性，就需要改动复杂的关联关系这是必然的，所要改动的表数据可能就是5个，复杂。在表含量较小的情况下时，我们将关系存储于原始表字段，用数组或者map的形式做关系的关联能大大降低关系表的复杂性及查询次数。数据量大的情况下用mangodb的map存储会有更好的效果），但是这样的一般是在多对多一种关系中，在多种关系下就会显得臃肿复杂，所以分析情景细节后，将标签表做B-&gt;A的关联，将合集表做C-&gt;A， C-&gt;B的关联<br>同时对用户发布需要判断话题对应合集的情况，将使用中的合集重要信息缓存一张新的缓存表，以下是标签表</p>\n<p><img src=\"/post/1470BA8020A45243F89BB4BA2CA69630.png\" alt=\"bq\"></p>\n<p>可以看到标签对应的话题已经做了关联，以下是合集表<br><img src=\"/post/hj.png\" alt=\"hj\"></p>\n<p>合集表中关联了标签及对应标签所有相关不重复的话题，重点就是将对应关系一一梳理对应存储，更改合集中的标签的时候，通过对标签与原数据不同的拆解分出添加和删除的标签，从中获取对应涉及的话题，去重合并更新缓存及数据库和用于给用户的使用的缓存表中的关系字段</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">&#x2F;&#x2F;管理更改的标签\n   public async  manageTagMerge(mergeData:WorksMerge, tag_map:any): Promise&lt;string&gt;&#123;\n       let result &#x3D; mergeData.relevance_topic;\n       if(mergeData.topic_tag !&#x3D; JSON.stringify(tag_map))&#123;\n           let mergeTopicList &#x3D; await this.getMergeTagTopic(tag_map);\n           result &#x3D; JSON.stringify(mergeTopicList);\n       &#125;\n       \n       return result;\n   &#125;</code></pre>\n<span id=\"more\"></span>\n<p>当更改或者添加话题标签时，同样也是分出添加和删除的标签，从标签中获取对应的联系的合集，取出合集管理的话题，在对关联话题进行修改达到去掉标签后的关联效果，同时修改标签表中关联的话题属性，将改完去重后完整数据更新缓存及数据库，同时更新用于用户部分的缓存数据</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">public async manageTagTopic(old_tag:string, tag_map:any, topic_id:string): Promise&lt;any&gt; &#123;\n        if(old_tag &#x3D;&#x3D; JSON.stringify(tag_map)) return true;\n        let oldTagMap &#x3D; JSON.parse(old_tag);\n        let newMap &#x3D; tag_map[&#39;0&#39;] || [];\n        let newAddMap &#x3D; await this.addNewTopicTag(topic_id, newMap);\n        if(!newAddMap)&#123;\n            logger.error(&#39;manageTagTopic new  error, topic_id:%s &#39;,topic_id);\n            return false;\n        &#125;\n        let addMap &#x3D; this.getAddMap(oldTagMap, tag_map);\n        if(!await this.addTagTopic(addMap, topic_id))&#123;\n            logger.error(&#39;manageTagTopic add  error, topic_id:%s &#39;,topic_id);\n            return false;\n        &#125;\n        let deleteMap &#x3D; this.getDeleteMap(oldTagMap, tag_map);\n        if(!await this.deleteTagTopic(deleteMap, topic_id))&#123;\n            logger.error(&#39;manageTagTopic delete error, topic_id:%s &#39;,topic_id);\n            return false;\n        &#125;\n        let result &#x3D; tag_map;\n        if(typeof newAddMap &#x3D;&#x3D; &quot;object&quot;)&#123;\n            delete result[0];\n            for(let k in newAddMap)&#123;\n                result[k] &#x3D; newAddMap[k];\n            &#125;\n        &#125;\n        return result;\n    &#125;</code></pre>\n\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">&#x2F;**\n    * 删除已有话题标签\n    *&#x2F;\n   public async deleteTagTopic (tag_map:any, topic_id:string): Promise&lt;any&gt; &#123;\n       if(JSON.stringify(tag_map) &#x3D;&#x3D; &quot;&#123;&#125;&quot;) return true;\n       for(let k in tag_map)&#123;\n           let tagList &#x3D; await TopicTagRepository.getInstance().getCharacter(k);\n           let tagData &#x3D; tagList[0];\n           if(!tagData)&#123;\n               continue;\n           &#125;\n           let topicArr &#x3D; JSON.parse(tagData.relevance_topic);\n           if(topicArr &amp;&amp; topicArr.length &amp;&amp; topicArr.indexOf(topic_id) &gt;&#x3D; 0)&#123;\n               let index &#x3D; topicArr.indexOf(topic_id);\n               topicArr.splice(index, 1); \n               tagData.relevance_topic &#x3D; JSON.stringify(topicArr);\n               if(await TopicTagRepository.getInstance().setCharacter(tagData))&#123;&#x2F;&#x2F;更新合集作品关联\n                   let rows &#x3D; await WorksMergeRepository.getInstance().getMergeTagIds(k);\n                   for(let j &#x3D; 0; j &lt; rows.length; j++)&#123;\n                       let mergeOne &#x3D; rows[j];\n                       let rt &#x3D; JSON.parse(mergeOne.relevance_topic);\n                       if(rt &amp;&amp; rt.length &amp;&amp; rt.indexOf(topic_id) &gt;&#x3D; 0)&#123;\n                           rt.splice(index, 1); \n                           mergeOne.relevance_topic &#x3D; JSON.stringify(rt);\n                           await WorksMergeRepository.getInstance().setMergeTopic(mergeOne);\n                       &#125;\n                   &#125;\n               &#125;\n           &#125;\n       &#125;\n       return true;\n   &#125;</code></pre>\n\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">&#x2F;**\n    * 添加已有标签\n    *&#x2F;\n   public async addTagTopic (tag_map:any, topic_id:string): Promise&lt;boolean&gt; &#123;\n       if(JSON.stringify(tag_map) &#x3D;&#x3D; &quot;&#123;&#125;&quot;) return true;\n       for(let k in tag_map)&#123;\n           let tagList &#x3D; await TopicTagRepository.getInstance().getCharacter(k);\n           let tagData &#x3D; tagList[0];\n           if(!tagData)&#123;\n               tagData &#x3D; await this.addNewTopicOneTag(topic_id, tag_map[k]);\n           &#125;\n           let topicArr &#x3D; JSON.parse(tagData.relevance_topic);\n           if(topicArr &amp;&amp; topicArr.indexOf(topic_id) &lt; 0)&#123;\n               topicArr.push(topic_id);\n               tagData.relevance_topic &#x3D; JSON.stringify(topicArr);\n               if(await TopicTagRepository.getInstance().setCharacter(tagData))&#123;&#x2F;&#x2F;更新合集作品关联\n                   let rows &#x3D; await WorksMergeRepository.getInstance().getMergeTagIds(k);\n                   for(let j &#x3D; 0; j &lt; rows.length; j++)&#123;\n                       let mergeOne &#x3D; rows[j];\n                       let rt &#x3D; JSON.parse(mergeOne.relevance_topic);\n                       if(rt &amp;&amp; rt.length &amp;&amp; rt.indexOf(topic_id) &lt; 0)&#123;\n                           rt.push(topic_id);\n                           mergeOne.relevance_topic &#x3D; JSON.stringify(rt);\n                           await WorksMergeRepository.getInstance().setMergeTopic(mergeOne);\n                       &#125;\n                   &#125;\n               &#125;\n           &#125;\n       &#125;\n       return true;\n   &#125;</code></pre>\n<p>这样就将所有的关系都拆解串联了起来，达到统一。</p>\n<p>用户提交作品的时候获取缓存中正在使用中的话题，遍历判断下条件分配对应话题下即可</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">public static async addWorksMerge(works_id:string, owner_id:string, identity_id:string, file_type:number, topic_list:string):Promise&lt;any&gt;&#123;\n        let fileType &#x3D; &quot;&quot; + file_type;\n        let userMap &#x3D; await WorksMergeRepository.getInstance().getMergeMap();\n        let mergeList &#x3D; await WorksMergePoolRepository.getInstance().getWorkIdMerge(works_id);\n        for(let k in userMap)&#123;\n            if(userMap[k].identity_id &#x3D;&#x3D; identity_id &amp;&amp; userMap[k].file_type.indexOf(fileType) &gt;&#x3D;0 &amp;&amp; topic_list &#x3D;&#x3D; userMap[k].relevance_topic &amp;&amp; mergeList.indexOf(k) &lt; 0)&#123;\n                let opts &#x3D; &#123;\n                    merge_id:k,\n                    works_id:works_id,\n                    owner_id:owner_id,\n                    file_type:fileType,\n                    identity:identity_id,\n                    topic_tag:userMap.topic_tag,\n                    relevance_topic:userMap.relevance_topic\n                &#125;\n                WorksMergePoolRepository.getInstance().addCharacter(opts);\n            &#125;\n        &#125;\n    &#125;</code></pre>\n\n<p>合集部分通过对话题标签取交集来获取当前合集下话题的关联</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">&#x2F;&#x2F;取交集\n   public getMergeWorksTopic(mergeData:WorksMerge)&#123;\n       let rtMap &#x3D; typeof mergeData.relevance_topic &#x3D;&#x3D; &quot;string&quot; ? JSON.parse(mergeData.relevance_topic) : mergeData.relevance_topic;\n       let fileStr &#x3D; typeof mergeData.file_type &#x3D;&#x3D; &quot;string&quot; ? mergeData.file_type.split(&#39;,&#39;) : [];\n       let fileNum &#x3D; [];\n       for(let l &#x3D; 0; l &lt; fileStr.length; l++)&#123;\n           let str &#x3D; fileStr[l];\n           if(isNaN(Number(str)))continue;\n           fileNum.push(Number(str));\n       &#125;\n       let result:any &#x3D; &#123;&quot;merge_id&quot;:mergeData.id, &quot;topic_list&quot;:[], &quot;file_type&quot;:fileNum, &quot;identity_id&quot;:mergeData.identity, &quot;limit&quot;:1, &quot;is_good&quot;:mergeData.is_good&#125;;\n       let topic_list:any[] &#x3D; [];\n       let temp_list:any[] &#x3D; [];\n       for(let k in rtMap)&#123;\n           if(Array.isArray(rtMap[k]))\n           topic_list.push(rtMap[k]);\n       &#125;\n       if(!topic_list.length)result.limit &#x3D; 0;&#x2F;&#x2F;无限制\n       temp_list &#x3D; topic_list.shift(); \n       for(let i &#x3D; topic_list.length; i-- ;)&#123;\n           let p:any &#x3D; &#123;&#125;, obj:any &#x3D; [];\n           temp_list &#x3D; temp_list.concat(topic_list[i]).filter(function (x: string) &#123;\n               return !((x in p) ? !p[x] &amp;&amp; (p[x] &#x3D; 1) : obj.indexOf(x) &lt; 0 &amp;&amp; obj.push(x));\n           &#125;);\n           if(!temp_list.length) &#123;\n               result.topic_list &#x3D; []; \n               return result;\n           &#125;\n       &#125;\n       result.topic_list &#x3D; temp_list;\n       &#x2F;&#x2F; logger.error(&#39;topic_list:&#39;, result.topic_list);\n       return result;\n   &#125;</code></pre>","text":"作品合集的背景是在原有话题上加入标签，让话题和标签有多对多的关系即 A-&gt;B，新的合集表C是由标签B合并成合集也是多对多关系即 B-&gt;C, 同时对于用户来说，用户只关心对应的话题，对应话题条件加入合集即 A-&gt;C,传统的多对多关系一般是建立中间关联表用作中转的关...","link":"","photos":[],"count_time":{"symbolsCount":"8.8k","symbolsTime":"8 mins."},"categories":[{"name":"IT笔记","slug":"IT笔记","count":21,"path":"api/categories/IT笔记.json"}],"tags":[{"name":"mysql","slug":"mysql","count":3,"path":"api/tags/mysql.json"}],"toc":"","author":{"name":"Fly","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个在夏天会被芒果砸到的城市靠写代码为生的前职业电竞选手","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"游戏成就任务系统设计","uid":"a327ba097d8097f094e2ffa26497e116","slug":"游戏成就任务系统设计","date":"2020-06-29T01:07:21.000Z","updated":"2021-11-30T09:07:18.828Z","comments":true,"path":"api/articles/游戏成就任务系统设计.json","keywords":"node.js blogs IT 互联网 服务端 游戏 mysql redis","cover":null,"text":"游戏中的成就任务一般是伴随着玩家操作，及一些游戏次数记录所以可以用一个监听如node里面的 var EventEmitter &#x3D; require(&#39;events&#39;).EventEmitter; var life &#x3D; new EventEmitt...","link":"","photos":[],"count_time":{"symbolsCount":907,"symbolsTime":"1 mins."},"categories":[{"name":"设计方法","slug":"设计方法","count":5,"path":"api/categories/设计方法.json"}],"tags":[{"name":"游戏","slug":"游戏","count":8,"path":"api/tags/游戏.json"}],"author":{"name":"Fly","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个在夏天会被芒果砸到的城市靠写代码为生的前职业电竞选手","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"node.js中常用的函数","uid":"c776e2dac8f01316cfe1fc728bbcc754","slug":"node-js中常用的函数","date":"2021-07-07T06:33:31.000Z","updated":"2021-11-30T09:05:10.586Z","comments":true,"path":"api/articles/node-js中常用的函数.json","keywords":"node.js blogs IT 互联网 服务端 游戏 mysql redis","cover":null,"text":"http部分 import fetch from &quot;node-fetch&quot;; import &#123; RequestInit &#125; from &quot;node-fetch&quot;; import &#123; URLSearchParams...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"IT笔记","slug":"IT笔记","count":21,"path":"api/categories/IT笔记.json"}],"tags":[{"name":"node.js","slug":"node-js","count":7,"path":"api/tags/node-js.json"}],"author":{"name":"Fly","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个在夏天会被芒果砸到的城市靠写代码为生的前职业电竞选手","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}