{"title":"node.js中常用的函数","uid":"c776e2dac8f01316cfe1fc728bbcc754","slug":"node-js中常用的函数","date":"2021-07-07T06:33:31.000Z","updated":"2021-11-30T09:05:10.586Z","comments":true,"path":"api/articles/node-js中常用的函数.json","keywords":"node.js blogs IT 互联网 服务端 游戏 mysql redis","cover":null,"content":"<p>http部分</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">import fetch from &quot;node-fetch&quot;;\nimport &#123; RequestInit &#125; from &quot;node-fetch&quot;;\nimport &#123; URLSearchParams &#125; from &#39;url&#39;;\n\nexport enum ContentType &#123;\n    JSON &#x3D; &quot;application&#x2F;json&quot;,\n    FORM &#x3D; &quot;application&#x2F;x-www-form-urlencoded&quot;\n&#125;;\n\nexport enum ResponseType &#123;\n    JSON,\n    XML,\n    BUFFER_OR_JSON,\n    TEXT\n&#125;;\n\nexport async function doGet(url: string, headers?: &#123; [index: string]: string &#125;, reqFail?: (err: any) &#x3D;&gt; void,\n    responseType: ResponseType &#x3D; ResponseType.JSON) &#123;\n    let options: RequestInit &#x3D; &#123;\n        method: &quot;GET&quot;,\n        headers: &#123; &#39;Content-Type&#39;: ContentType.JSON &#125;,\n    &#125;;\n\n    if (headers) &#123;\n        Object.assign(options.headers, headers);\n    &#125;\n\n    return await doRequest(url, options, reqFail, responseType);\n&#125;\n\nexport async function doPost(url: string, body: (URLSearchParams | any), headers?: &#123; [index: string]: string &#125;,\n    reqFail?: (err: any) &#x3D;&gt; void, responseType: ResponseType &#x3D; ResponseType.JSON) &#123;\n    let options: RequestInit &#x3D; &#123;\n        method: &quot;POST&quot;\n    &#125;;\n\n    if (body &amp;&amp; body.constructor &amp;&amp; body.constructor.name &#x3D;&#x3D;&#x3D; &quot;URLSearchParams&quot;) &#123;\n        &#x2F;&#x2F; 表单类型直接赋值body\n        options.body &#x3D; body;\n        options.headers &#x3D; &#123; &#39;Content-Type&#39;: ContentType.FORM &#125;\n    &#125;\n    else &#123;\n        options.body &#x3D; JSON.stringify(body);\n        options.headers &#x3D; &#123; &#39;Content-Type&#39;: ContentType.JSON &#125;\n    &#125;\n\n    if (headers) &#123;\n        Object.assign(options.headers, headers);\n    &#125;\n\n    return await doRequest(url, options, reqFail, responseType);\n&#125;\n\nasync function doRequest(url: string, options: RequestInit, reqFail?: (err: any) &#x3D;&gt; void,\n    responseType: ResponseType &#x3D; ResponseType.JSON) &#123;\n    let fetchRes &#x3D; await fetch(url, options);\n\n    if (fetchRes.status !&#x3D; 200 &amp;&amp; fetchRes.status !&#x3D; 201) &#123;\n        try &#123;\n            if (reqFail) &#123;\n                let err &#x3D; await getError(fetchRes, responseType);\n\n                await reqFail(err);\n            &#125;\n        &#125;\n        catch &#123;\n            if (reqFail) &#123;\n                await reqFail(&#123; http_status_code: fetchRes.status, error: &#96;to json fail&#96; &#125;);\n            &#125;\n        &#125;\n\n        return undefined;\n    &#125;\n\n    let res &#x3D; undefined;\n\n    switch (responseType) &#123;\n        case ResponseType.JSON:\n            res &#x3D; await fetchRes.json();\n            break;\n        case ResponseType.XML:\n        case ResponseType.TEXT:\n            res &#x3D; await fetchRes.text()\n            break;\n        case ResponseType.BUFFER_OR_JSON:\n            if ((fetchRes.headers.get(&quot;content-type&quot;) || &quot;&quot;).includes(&quot;json&quot;)) &#123;\n                res &#x3D; await fetchRes.json();\n            &#125;\n            else &#123;\n                res &#x3D; await fetchRes.buffer();\n            &#125;\n            break;\n        default:\n            if (reqFail) &#123;\n                await reqFail(&#123; error: &#96;responseType error&#96; &#125;);\n            &#125;\n            break;\n    &#125;\n\n    return res;\n&#125;\n\nasync function getError(fetchRes: any, responseType: ResponseType) &#123;\n    let err: any &#x3D; &#123;&#125;;\n    switch (responseType) &#123;\n        case ResponseType.JSON:\n            err &#x3D; await fetchRes.json();\n            err.http_status_code &#x3D; fetchRes.status\n            break;\n        case ResponseType.XML:\n            let text &#x3D; await fetchRes.text();\n            err &#x3D; &#123; http_status_code: fetchRes.status, error: text &#125;;\n            break;\n        default:\n            err &#x3D; &#123; http_status_code: fetchRes.status, error: &#96;responseType error&#96; &#125;\n            break;\n    &#125;\n    return err;\n&#125;</code></pre>\n<span id=\"more\"></span>\n\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">import fetch from &quot;node-fetch&quot;;\nimport &#123; URL &#125; from &#39;url&#39;;\nimport &#123; RequestInit &#125; from &quot;node-fetch&quot;;\nimport logger &#x3D; require(&quot;.&#x2F;logger&quot;);\nconst FormData &#x3D; require(&#39;form-data&#39;);\n&#x2F;&#x2F; import &#123; URLSearchParams &#125; from &#39;url&#39;;\n\nexport function requestParam(url: string, method?: string, params?: any, headers?: any): Promise&lt;any&gt; &#123;\n    let form &#x3D; new FormData();\n    headers &#x3D; headers || form.getHeaders();\n    for (let key in params) &#123;\n        form.append(key, params[key]);\n    &#125;\n    return request(url, method, form, headers);\n&#125;\n\nexport function checkUrl(url: string) &#123;\n    try &#123;\n        let parsedURL &#x3D; new URL(url);\n        logger.info(&#39;url protocol:[%s] host:%s port:%s hostname:%s, path:%s&#39;, parsedURL.protocol, parsedURL.host, parsedURL.port, parsedURL.hostname, parsedURL.pathname);\n\n    &#125; catch (err) &#123;\n        logger.error(&#39;url:%s invoid, err:%j&#39;, url, err.message);\n    &#125;\n&#125;\n\nexport function request(url: string, method?: string, data?: any, headers?: any): Promise&lt;any&gt; &#123;\n    let options: RequestInit &#x3D; &#123;\n        method: method || &#39;GET&#39;,\n        headers: headers || &#123; &#39;Content-Type&#39;: &quot;application&#x2F;json&quot; &#125;\n    &#125;;\n    if (data) &#123;\n        options.body &#x3D; data;\n    &#125;\n    &#x2F;&#x2F;check url\n    &#x2F;&#x2F; checkUrl(url);\n\n    return new Promise((resolve, reject) &#x3D;&gt; &#123;\n        fetch(url, options).then(resp &#x3D;&gt; &#123;\n            if (resp.status !&#x3D; 200) &#123;\n                return reject(&#39;request status:&#39; + resp.status);\n            &#125;\n            &#x2F;&#x2F;尝试以json结果返回\n            resp.json().then(data &#x3D;&gt; &#123;\n                resolve(data);\n            &#125;).catch(_ &#x3D;&gt; &#123;\n                &#x2F;&#x2F;尝试以text结果返回\n                resp.text().then(data &#x3D;&gt; &#123;\n                    resolve(data);\n                &#125;).catch(error &#x3D;&gt; &#123;\n                    return reject(error);\n                &#125;);\n            &#125;)\n        &#125;).catch(err &#x3D;&gt; &#123;\n            return reject(err);\n        &#125;);\n    &#125;);\n&#125;</code></pre>\n\n<p>加密部分</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">md5(data: string) &#123;\n    &#x2F;&#x2F; 以md5的格式创建一个哈希值\n    let hash &#x3D; crypto.createHash(&#39;md5&#39;);\n    return hash.update(data).digest(&#39;hex&#39;);\n&#125;,\nsha1(data: string) &#123;\n    &#x2F;&#x2F; 以md5的格式创建一个哈希值\n    let hash &#x3D; crypto.createHash(&#39;sha1&#39;);\n    return hash.update(data).digest(&#39;hex&#39;);\n&#125;,\nhmac(data: string, key: string, upperCase: boolean &#x3D; false) &#123;\n    if (!key) &#123;\n        throw &#39;invoid hmac &quot;key&quot; params.&#39;\n    &#125;\n    &#x2F;&#x2F; 以md5的格式创建一个哈希值\n    const hash &#x3D; crypto.createHmac(&#39;md5&#39;, key);\n    let result &#x3D; hash.update(data).digest(&#39;hex&#39;);\n    return upperCase ? result.toUpperCase() : result;\n&#125;,\nhmac_sha1(data:string, key:string)&#123;\n    return Base64.stringify((HmacSha1(data,key)));\n&#125;,\n&#x2F;** base64编码 *&#x2F;\nencodeBase64(str: string) &#123;\n    if (!str) &#123;\n        return &quot;&quot;\n    &#125;\n    let buff &#x3D; iconv.encode(str, &#39;utf8&#39;);\n    return iconv.decode(buff, &#39;base64&#39;);\n&#125;,</code></pre>\n\n<p>时间部分</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">&#x2F;**\n * 获取指定整点的时间\n *&#x2F;\nexport function getGivenHour(dateVal: Date, hour: number) &#123;\n    let t &#x3D; new Date(dateVal.getFullYear(), dateVal.getMonth(), dateVal.getDate(), hour);\n    return t;\n&#125;\n\n&#x2F;**\n * 获取本月第一天的时间\n *&#x2F;\nexport function getMonthFirstDay(dateVal: Date) &#123;\n    let t &#x3D; new Date(dateVal.getFullYear(), dateVal.getMonth(), 1);\n    return t;\n&#125;\n\nexport function getThirtyDay(dateVal: Date): number &#123;\n    let t &#x3D; new Date(dateVal.getFullYear(), dateVal.getMonth(), dateVal.getDate());\n    let time &#x3D; t.getTime() - 30 * 24 * 60 * 60 * 1000\n    return time;\n&#125;\n\n&#x2F;**\n * 获取下个月第一天的时间\n *&#x2F;\nexport function getNextMonthFirstDay(dateVal: Date) &#123;\n    let t &#x3D; new Date(dateVal.getFullYear(), dateVal.getMonth() + 1, 1);\n    return t;\n&#125;\n\n&#x2F;**\n * 一天的毫秒数\n *&#x2F;\nexport function getDayMs() &#123;\n    return 86400000;\n&#125;\n\n&#x2F;**\n * 获取本周第一天的时间\n *&#x2F;\nexport function getWeekFirstDay(dateVal: Date) &#123;\n    let day &#x3D; getDay(dateVal);\n\n    let dnum &#x3D; dateVal.getTime() - ((day - 1) * getDayMs());\n    let d &#x3D; new Date(dnum);\n    return getGivenHour(d, 0);\n&#125;\n\n&#x2F;**\n * 获取下个周第一天的时间\n *&#x2F;\nexport function getNextWeekFirstDay(dateVal: Date) &#123;\n    let day &#x3D; getDay(dateVal);\n\n    let dnum &#x3D; dateVal.getTime() + ((8 - day) * getDayMs());\n    let d &#x3D; new Date(dnum);\n    return getGivenHour(d, 0);\n&#125;\n\n&#x2F;**\n * 获取day，周日转为7\n * 周一：1，周二：2，周三：3，周四：4，周五：5，周六：6，周日：7\n *&#x2F;\nfunction getDay(dateVal: Date) &#123;\n    let day &#x3D; dateVal.getDay();\n    day &#x3D; day &#x3D;&#x3D; 0 ? 7 : day;\n    return day;\n&#125;\n\n&#x2F;**\n * 取当前时间(秒)\n *&#x2F;\nexport function now(): number &#123;\n    return Math.floor(Date.now() &#x2F; 1000);\n&#125;\n\n&#x2F;**\n * 时间戳转日期\n * @param date\n *&#x2F;\nexport function dateFormat(date: Date, fmtEnum: FmtOpsion): string &#123;\n    let o: Map&lt;string, number&gt; &#x3D; new Map()\n        .set(&quot;M+&quot;, date.getMonth() + 1)\n        .set(&quot;d+&quot;, date.getDate())\n        .set(&quot;H+&quot;, date.getHours())\n        .set(&quot;m+&quot;, date.getMinutes())\n        .set(&quot;s+&quot;, date.getSeconds())\n        .set(&quot;q+&quot;, Math.floor((date.getMonth() + 3) &#x2F; 3))   &#x2F;&#x2F; 季度\n        .set(&quot;S&quot;, date.getMilliseconds()); &#x2F;&#x2F; 毫秒\n\n    let fmt &#x3D; fmtEnum.toString();\n    if (new RegExp(&#x2F;(y+)&#x2F;).test(fmt)) &#123;\n        fmt &#x3D; fmt.replace(RegExp.$1, (date.getFullYear() + &quot;&quot;).substr(4 - RegExp.$1.length));\n    &#125;\n\n    o.forEach((_val, k) &#x3D;&gt; &#123;\n        if (new RegExp(&quot;(&quot; + k + &quot;)&quot;).test(fmt)) &#123;\n            let val &#x3D; (o.get(k) || &quot;&quot;).toString();\n            fmt &#x3D; fmt.replace(RegExp.$1, (RegExp.$1.length &#x3D;&#x3D; 1) ? (val) : ((&quot;00&quot; + val).substr((&quot;&quot; + val).length)));\n        &#125;\n    &#125;);\n\n    return fmt;\n&#125;\n\nexport enum FmtOpsion &#123;\n    longDateTime &#x3D; &quot;yyyy-MM-dd HH:mm:ss&quot;,\n    shortDateTime &#x3D; &quot;yyyy-MM-dd&quot;\n&#125;\n\nexport function getLongDateTime(date: Date &#x3D; new Date()) &#123;\n    return dateFormat(date, FmtOpsion.longDateTime);\n&#125;</code></pre>\n\n<p>数据结构部分</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">export function ListToMap(list: any[], predicate: (item: any) &#x3D;&gt; any) &#123;\n    let map &#x3D; new Map&lt;any, any&gt;();\n\n    for (let i &#x3D; 0; i &lt; list.length; i++) &#123;\n        let item &#x3D; list[i];\n        let key &#x3D; predicate(item);\n        map.set(key, item);\n    &#125;\n\n    return map;\n&#125;</code></pre>","text":"http部分 import fetch from &quot;node-fetch&quot;; import &#123; RequestInit &#125; from &quot;node-fetch&quot;; import &#123; URLSearchParams...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"IT笔记","slug":"IT笔记","count":21,"path":"api/categories/IT笔记.json"}],"tags":[{"name":"node.js","slug":"node-js","count":7,"path":"api/tags/node-js.json"}],"toc":"","author":{"name":"Fly","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个在夏天会被芒果砸到的城市靠写代码为生的前职业电竞选手","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"作品合集-多对多对多关系表","uid":"f93992fa9cfdd90a84e68e7ac1ad2636","slug":"作品合集-多对多对多关系表","date":"2021-07-27T07:38:58.000Z","updated":"2021-11-30T09:01:12.663Z","comments":true,"path":"api/articles/作品合集-多对多对多关系表.json","keywords":"node.js blogs IT 互联网 服务端 游戏 mysql redis","cover":[],"text":"作品合集的背景是在原有话题上加入标签，让话题和标签有多对多的关系即 A-&gt;B，新的合集表C是由标签B合并成合集也是多对多关系即 B-&gt;C, 同时对于用户来说，用户只关心对应的话题，对应话题条件加入合集即 A-&gt;C,传统的多对多关系一般是建立中间关联表用作中转的关...","link":"","photos":[],"count_time":{"symbolsCount":"8.8k","symbolsTime":"8 mins."},"categories":[{"name":"IT笔记","slug":"IT笔记","count":21,"path":"api/categories/IT笔记.json"}],"tags":[{"name":"mysql","slug":"mysql","count":3,"path":"api/tags/mysql.json"}],"author":{"name":"Fly","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个在夏天会被芒果砸到的城市靠写代码为生的前职业电竞选手","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"加薪秘籍","uid":"2debb017808112f7c6dc95c7509d53b7","slug":"加薪秘籍","date":"2021-07-01T06:58:40.000Z","updated":"2021-11-30T08:59:44.258Z","comments":true,"path":"api/articles/加薪秘籍.json","keywords":"node.js blogs IT 互联网 服务端 游戏 mysql redis","cover":[],"text":"题目：从 innodb 的索引结构分析，为什么索引的 key 长度不能太长？key 太长会导致一个页当中能够存放的 key 的数目变少，间接导致索引树的页数目变多，索引层次增加，从而影响整体查询变更的效率。 题目：请解释下为什么鹿晗发布恋情的时候，微博系统会崩溃，如何解决？A. ...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"IT笔记","slug":"IT笔记","count":21,"path":"api/categories/IT笔记.json"}],"tags":[{"name":"面试","slug":"面试","count":1,"path":"api/tags/面试.json"}],"author":{"name":"Fly","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个在夏天会被芒果砸到的城市靠写代码为生的前职业电竞选手","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}