{"title":"Pomelo学习笔记","uid":"eb22ca4ed9e8d1628dcb03e5412b9b1b","slug":"pomelo学习笔记","date":"2018-10-23T11:34:45.000Z","updated":"2021-11-30T09:05:36.961Z","comments":true,"path":"api/articles/pomelo学习笔记.json","keywords":"node.js blogs IT 互联网 服务端 游戏 mysql redis","cover":null,"content":"<p>重新认识pomelo<br>服务器配置在server.json里，通过app.js设置服务器及路由，每一个服务器在server下对应一个文件及为一个进程，其中一定包含handler逻辑代码部分不一定包含remote（远程通信、服务器监听用）例如以下</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">self.app.rpc.chat.chatRemote.add(session, uid, self.app.get(&#39;serverId&#39;), rid, true, function(users)&#123;\n\t\tnext(null, &#123;\n\t\t\tusers:users\n\t\t&#125;);\n\t&#125;);</code></pre>\n<p>增加服务器改server.json扩充，然后在连接服务器中逻辑进行选服</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">module.exports.dispatch &#x3D; function(uid, connectors) &#123;\n\tvar index &#x3D; Math.abs(crc.crc32(uid)) % connectors.length;\n\treturn connectors[index];\n&#125;;</code></pre>\n<p>filter用于请求前及请求后的处理,可以用于请求排队，或者测试接口时间<br>app.js中可以配置路由压缩及回包压缩方式</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">app.set(&#39;connectorConfig&#39;,\n\t&#123;\n\t\tconnector : pomelo.connectors.hybridconnector,\n\t\tuseProtobuf : true,\n\t\tuseDict: true &#x2F;&#x2F; enable dict\n\t&#125;);\n&#125;);</code></pre>\n<p>自建组件在app文件夹下在建立一个自己定义的文件夹，里面有start afterStart stop</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">app.configure(&#39;production|development&#39;, &#39;master&#39;, function() &#123;\n  app.load(helloWorld, &#123;interval: 5000&#125;);\n&#125;);</code></pre>\n\n<p>一个admin module中一般包括四个回调方法，monitorHandler，masterHandler，clientHandler, start。其中monitorHandler是monitor收到master的请求或者通知时由monitor回调，masterHandler是master收到monitor的请求或者通知时回调，clientHandler是master收到client的请求或通知时回调的, start是当admin module加载完成后，用来执行一些初始化监控时调用。</p>\n<p>组件<br>master组件<br>monitor组件<br>connector组件<br>session组件<br>connection组件<br>server组件<br>pushScheduler组件<br>proxy组件<br>remote组件<br>dictionary组件<br>protobuf组件<br>channel组件<br>backendSession组件<br>具体看<a href=\"https://github.com/NetEase/pomelo/wiki/%E7%BB%84%E4%BB%B6%E6%A6%82%E8%BF%B0\">https://github.com/NetEase/pomelo/wiki/%E7%BB%84%E4%BB%B6%E6%A6%82%E8%BF%B0</a></p>\n<p>环境</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">getBase()\t Application.getBase(); 获取应用程序的基本路径\nset(setting, val, attach);\t Application.set();  setting:应用程序的配置；val:需要设置的值；attach:是否将设配置应用到程序。设置或返回配置的值。\nget(setting)\t Application.get(); setting:应用程序的配置。获取配置的值\nenabled(setting)\t Application.enabled(); setting:应用程序的配置。检查配置是否启用\ndisabled(setting)\t Application.disabled(); setting:应用程序的配置。检查配置是否禁用\nenbale(setting)\t Application.enbale(); setting:应用程序的配置。启用配置\ndisable(setting)\t Application.disabled(); setting:应用程序的配置。禁用配置\nconfigure(env,fn,type)\tApplication.configure();env:应用环境;fn:回调函数;type:服务类型.</code></pre>\n<p>初始化</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">start()\t Application.start(); 启动应用程序。它会加载默认的组件和启动所有加载的组件。\nregisterAdmin(moduleId,module,opts)\t Application.registerAdmin();  moduleId:(可选参数)模块id或者有modeule提供的模块Id;module:模块对象或者模块的工程函数;opts:模块构造函数的参数。\nfilter(filter)\t Application.filter(); filter:provide before and after filter method。add a filter to before and after filter\nbefore(bf)\t Application.before(); bf:before filter。Add before filter\nafter(af)\t Application.after(); af:after filter。Add after filter\nload(name, component, opts)\t Application.load(); name:组件的名称（可选）；component：组件的实例或者组件的工厂函数；opts：组件构造函数的参数（可选）。加载组件\nloadConfig(key,val)\t Application.loadConfig(); key:环境配置的关键字;val:环境配置的值。导入json文件来配置环境。</code></pre>\n<span id=\"more\"></span>\n<p>组件相关</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">route(serverType, routeFunc)\t\n Application.route(); serverType:服务类型;routeFunc:路由功能函数,如：routeFunc(session, msg, app, cb)\n\n未指定的服务类型设置路由功能。如：\n\napp.route(&#39;area&#39;, routeFunc);\n\nvar routeFunc &#x3D; function(session, msg, app, cb) &#123;\n\n　　&#x2F;&#x2F; all request to area would be route to the first area server\n\n　　var areas &#x3D; app.getServersByType(&#39;area&#39;);\n\n　　cb(null, areas[0].id);\n\n&#125;</code></pre>\n<p>获取相关配置，组件方法</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">getMaster()\tApplication.getMaster() 获得Maseter服务的信息\ngetCurServer()\tApplication.getCurServer() 获得当前服务的信息\ngetServerId()\tApplication.getServerId() 获得当前服务的ID\ngetServerType()\tApplication.getServerType() 获得当前服务的类型\ngetServers()\tApplication.getServers() 获得所有当前服务的信息\ngetServersFromConfig()\tApplication.getServersFromConfig() 从server.json中获得所有服务的信息\ngetServerTypes()\tApplication.getServerTypes() 获得所有服务的类型\ngetServerById(serverId)\tApplication.getServerById() 根据服务ID从服务集群中获得服务的信息\ngetServerFromConfig(serverId)\tApplication.getServerFromConfig() 根据服务ID从server.json中获得服务的信息\ngetServersByType(serverType)\tApplication.getServersByType() 根据服务类型获取服务信息\nisFrontend(server)\tApplication.isFrontend() 检查服务是否是一个前端服务\nisBackend(server)\tApplication.isBackend() 检查服务是否是一个后端服务\nisMaster()\tApplication.isMaster() 检查当前服务是否是主服务\naddServers(servers)\tApplication.addServers() servers：新服务信息列表。添加新服务信息到正在运行的应用程序中\nremoverServers(ids)\tApplication.removerServers() ids：服务id列表。从当前运行的应用程序中删除服务信息。</code></pre>\n<p>创建和维护本地服务的信道。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">createChannel(name)\tChannelService.prototype.createChannel() 根据信道名称创建信道，如果该信道已存在则返回已存在的信道\ngetChannel(name,create)\tChannelService.prototype.getChannel() name:信道名称，create:如果为true，并且信道不存在时，则创建新的信道。根据信道名称获取信道\ndestroyChannel(name)\tChannelService.prototype.destroyChannel() 根据信道名称，删除信道\npushMessageByUids(route, msg, uids, cb)\tChannelService.prototype.pushMessageByUids() route：消息路由；msg：发送到客户端的消息；uids：接收消息的客户端列表，格式 [&#123;uid: userId, sid: frontendServerId&#125;]；cb：回调函数 cb(err)。根据uids将消息推送给客户端，如果uids中的sid未指定，则忽略相应的客户端\nbroadcast(stype,route, msg, opts, cb)\tChannelService.prototype.broadcast() stype：前端服务的类型;route：路由;msg：消息;opts：广播参数;cb：回调函数。广播消息到所有连接的客户端。</code></pre>\n<p>Channel</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">add(uid,sid)\tChannel.prototype.add() uid:用户编号；sid：用户连接到的前端服务id。添加指定用户到信道。\nleave(uid,sid)\tChannel.prototype.leave() uid:用户编号；sid：用户连接到的前端服务id。从信道中移除用户。\ngetMembers()\tChannel.prototype.getMembers() 获得信道中的成员\ngetMember(uid)\tChannel.prototype.getMember() 根据uid获取成员信息\ndestroy()\tChannel.prototype.destroy() 销毁信道\npushMessage(route,msg,cb)\tChannel.prototype.pushMessage()  route：消息路由，msg：要推送的消息，cb：回调函数。将消息推送给信道的所有成员。</code></pre>\n<p>GlobalChannelService</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">destroyChannel(name,cb)\tGlobalChannelService.prototype.destroyChannel() uid:用户编号；sid：用户连接到的前端服务id。添加指定用户到信道。\nadd(name,uid,sid,cb)\t\nGlobalChannelService.prototype.add() name:信道名称；uid：用户id；sid：前端服务id；cb：回调函数。\n\n添加成员到信道。\n\nleave(name,uid,sid,cb)\tGlobalChannelService.prototype.leave() \nname:信道名称；uid：用户id；sid：前端服务id；cb：回调函数。\n\n从信道中移除成员。\n\npushMessage()\t\nGlobalChannelService.prototype.pushMessage(serverType, route, msg,channelName, opts, cb)\n\nserverType：前端服务的类型, route：路由, msg：需要推送的消息,channelName：信道名称, opts：参数, cb：回调函数\n\n通过全局信道发送消息</code></pre>\n<p>LocalSessionService</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">get(frontendId,sid,cb)\tLocalSeesionService.prototype.get() frontendId:会话链接的前端服务id,sid:会话Id,cb:回调函数。根据前端服务和会话id获得本地会话\ngetByUid(name,uid,sid,cb)\t\nLocalSeesionService.prototype.getByUid()  frontendId:会话链接的前端服务id,uid：绑定到会话的用户id，cb：回调函数。args: cb(err, localSessions)。根据前端服务和用户id获取本地会话。\n\nkickBySid(name,uid,sid,cb)\tLocalSeesionService.prototype.kickBySid() frontendId:会话链接的前端服务id,sid:会话Id,cb:回调函数。根据会话id踢掉该会话。\nkickByUid()\t\nLocalSeesionService.prototype.kickByUid() frontendId:会话链接的前端服务id,uid：用户id,cb:回调函数。根据用户id踢掉该会话。</code></pre>\n<p>LocalSession</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">bind(uid,cb)\tLocalSeesion.prototype.bind() uid:用户编号;cb:回调函数。callfunction(err)。绑定当前会话，用于前端服务的推送和全局会话的绑定。\nunbind(uid,cb)\t\nLocalSeesion.prototype.unbind() uid:用户编号;cb:回调函数。callfunction(err)。取消绑定。\n\nset(key,value)\tLocalSeesion.prototype.set() 将key&#x2F;value添加到本地会话中\nget(key)\t\nLocalSeesion.prototype.get() 根据key从本地会话中获取值。\n\npush(key,cb)\t\nLocalSeesion.prototype.push() 将本地会话中的key&#x2F;value添加到全局会话中\n\npushAll(cb)\tLocalSeesion.prototype.pushAll() 将本地会话中的所有key&#x2F;value添加到全会话中</code></pre>\n<p>SessionService</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">kick(uid,cb)\tSeesionService.prototype.kick() 踢掉该用户的所有离线会话\nkickBySession(sid,cb)\t\nSeesionService.prototype.kickBySession() sid:会话编号;cb:回调函数。根据会话id踢掉一个在线用户\n\nsendMessage(sid,msg)\tSeesionService.prototype.sendMessage()根据会话id向客户端发送消息\nsendMessageByUid(uid,msg)\t\nSeesionService.prototype.sendMessageByUid() 根据用户id向客户端发送消息</code></pre>\n<p>Pomelo</p>\n<pre><code class=\"bash\">createApp(opts)    Pomelo.create() 创建一个Pomelo 应用程序\n\n\n</code></pre>\n","text":"重新认识pomelo服务器配置在server.json里，通过app.js设置服务器及路由，每一个服务器在server下对应一个文件及为一个进程，其中一定包含handler逻辑代码部分不一定包含remote（远程通信、服务器监听用）例如以下 self.app.rpc.chat.c...","link":"","photos":[],"count_time":{"symbolsCount":"7k","symbolsTime":"6 mins."},"categories":[{"name":"IT笔记","slug":"IT笔记","count":21,"path":"api/categories/IT笔记.json"}],"tags":[{"name":"node.js","slug":"node-js","count":7,"path":"api/tags/node-js.json"}],"toc":"","author":{"name":"Fly","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个在夏天会被芒果砸到的城市靠写代码为生的前职业电竞选手","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"C++设计模式","uid":"7a8e11fd23f49077811a339d4019e863","slug":"c++设计模式","date":"2018-12-25T14:38:51.000Z","updated":"2021-11-30T09:04:19.712Z","comments":true,"path":"api/articles/c++设计模式.json","keywords":"node.js blogs IT 互联网 服务端 游戏 mysql redis","cover":null,"text":"c++设计模式： 简单工厂模式 工厂模式有一种非常形象的描述，建立对象的类就如一个工厂，而需要被建立的对象就是一个个产品；在工厂中加工产品，使用产品的人，不用在乎产品是如何生产出来的。从软件开发的角度来说，这样就有效的降低了模块之间的耦合。 使用情景： 在不确定会有多少个处理操作...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"IT笔记","slug":"IT笔记","count":21,"path":"api/categories/IT笔记.json"}],"tags":[{"name":"c++","slug":"c","count":1,"path":"api/tags/c.json"},{"name":"设计模式","slug":"设计模式","count":1,"path":"api/tags/设计模式.json"}],"author":{"name":"Fly","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个在夏天会被芒果砸到的城市靠写代码为生的前职业电竞选手","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Node笔记","uid":"5d576bc5d97b72bd5c880644e758fd3d","slug":"node笔记","date":"2018-08-21T09:04:37.000Z","updated":"2021-11-30T09:05:19.236Z","comments":true,"path":"api/articles/node笔记.json","keywords":"node.js blogs IT 互联网 服务端 游戏 mysql redis","cover":null,"text":"第一章 node简介1.1 node的特点 1.1.1 异步I/O 绝大多数操作以异步方式进行调用 1.1.2 事件与回调函数 1.1.3 单线程，但是可以用WebWorkers的方式解决单线程的问题（子进程），用Master-Worker用master统一管理子进程 1.1.4...","link":"","photos":[],"count_time":{"symbolsCount":"18k","symbolsTime":"16 mins."},"categories":[{"name":"IT笔记","slug":"IT笔记","count":21,"path":"api/categories/IT笔记.json"}],"tags":[{"name":"node.js","slug":"node-js","count":7,"path":"api/tags/node-js.json"}],"author":{"name":"Fly","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个在夏天会被芒果砸到的城市靠写代码为生的前职业电竞选手","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}