{"title":"Node笔记","uid":"5d576bc5d97b72bd5c880644e758fd3d","slug":"node笔记","date":"2018-08-21T09:04:37.000Z","updated":"2021-11-30T09:05:19.236Z","comments":true,"path":"api/articles/node笔记.json","keywords":"node.js blogs IT 互联网 服务端 游戏 mysql redis","cover":null,"content":"<p>第一章 node简介<br>1.1 node的特点<br>    1.1.1 异步I/O 绝大多数操作以异步方式进行调用<br>    1.1.2 事件与回调函数<br>    1.1.3 单线程，但是可以用WebWorkers的方式解决单线程的问题（子进程），用Master-Worker用master统一管理子进程<br>    1.1.4 跨平台<br>    1.1.5 c++速度大约是node的2.5倍</p>\n<p>1.2 模块机制<br>    1.2.1 分为核心模块和文件模块，require没带路径的为核心模块，直接加载进内存，带路径的为文件模块,核心模块中有c++和javascript两部分，其中buffer、crypto、evals、fs、os、等都是c++部分的<br>    1.2.2 npm安装的核心模块插件在package.json中定义</p>\n<p>1.3 异步I/O<br>    1.3.1 操作系统内核对I/O只有：阻塞I/O和非阻塞I/O，node中的异步I/O模型由事件循环、观察者、请求对象、I/O线程池<br>    整个系统可以理解为事件循环相当于厨子，不停的询问是否有新的订单，观察者相当于收银员，收到用户的订单将订单分给厨子，而订单相当于请求对象，参数、方法、回调函数斗封装在请求对象中,<br>    以上是异步I/O的第一步，io线程池相当于放订单的桌子，  请求对象-&gt;I/O线程池-&gt;观察者-&gt;事件循环<br>    1.3.2 非异步的I/O主要是setTimeout(),setInterval(),setImmediate(),process.nextTick()</p>\n<span id=\"more\"></span>\n<p>1.4 异步编程<br>    1.4.1 异步编程的解决方案分为3个：<br>        1）事件发布/订阅模式<br>        2）Promise/Deferred模式<br>        3）流程控制库<br>    1.4.2 事件发布/订阅模式<br>    <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">&#x2F;&#x2F;订阅\nemitter.on(&quot;event1&quot;,function(message)&#123;\n\tconsole.log(message);\n&#125;);\n&#x2F;&#x2F;发布\nemitter.emit(&#39;event1&#39;,&quot;I Love you&quot;);</code></pre><br>    1）继承events模块<br>    <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">var events &#x3D; require(&#39;events&#39;);\n\nfunction Stream()&#123;\n\tevents.EventEmitter.call(this);\n&#125;\nutil.inherits(Stream,events.EventEmitter);</code></pre><br>    2)利用事件队列解决崩溃问题<br>    事件发布/订阅模式中一般只有一个once()方法，用一个『状态锁』或者『事件队列』防止崩溃<br>    状态锁<br>    <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">var status &#x3D; &quot;ready&quot;;\nvar select &#x3D; function(callback)&#123;\n\tif(status &#x3D;&#x3D; &quot;ready&quot; )&#123;\n\t\tstatus &#x3D; &quot;pending&quot;;\n\t\tdb.select(&quot;SQL&quot;, function(results)&#123;\n\t\t\tstatus &#x3D; &quot;ready&quot;;\n\t\t\tcallback(results);\n\t\t&#125;);\n\t&#125;\n&#125;;</code></pre><br>    事件队列<br>    <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">var proxy &#x3D; new events.EventEmitter();\nvar status &#x3D; function (callback) \n\tproxy.once(&quot;selected&quot;, callback);\n\tif(status &#x3D;&#x3D;&#x3D; &quot;ready&quot;)&#123;\n\t\tstatus &#x3D; &quot;pending&quot;;\n\t\tdb.select(&quot;SQL&quot;, function(result)&#123;\n\t\t\tproxy.emit(&quot;selected&quot;,result);\n\t\t\tstatus &#x3D; &quot;ready&quot;;\n\t\t&#125;);\n\t&#125;\n&#125;</code></pre><br>    3）多异步之间的协作方案<br>    借组一个第三方函数和第三方变量来处理异步协作的结果<br>    <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">var after &#x3D; function (times,callback)&#123;\n\tvar count &#x3D; 0, results &#x3D; &#123;&#125;;\n\treturn function (key, value)&#123;\n\t\tresult[key] &#x3D; value;\n\t\tcount++;\n\t\tif(count &#x3D;&#x3D;&#x3D; times)&#123;\n\t\t\tcallback(results);\n\t\t&#125;\n\t&#125;\n&#125;\n\nvar done &#x3D; after(times, render);</code></pre><br>    1.4.3 Promise/Deferred模式<br>    Promise是高级接口，事件是低级接口，Promise更像链表<br>    Promise中有3种状态<br>    pending - 进行中<br>    fulfilled - 成功<br>    rejected - 失败<br>    状态一旦改变就不可更改，在回调还是同样结果，但是事件错过了监听是得不到结果的<br>    1.4.4 async流程控制模块<br>    1）async的series()方法实现串行（不传参）<br>    <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">async.series([\n\tfunction (callback)&#123;\n\t\tfs.readFile(&#39;file1.txt&#39;,&#39;utf-8&#39;,calback);\n\t&#125;,\n\tfunction (callback)&#123;\n\t\tfs.readFile(&#39;file2.txt&#39;,&#39;utf-8&#39;,calback);\n\t&#125;\n],function (err,result)&#123;\n\t&#x2F;&#x2F;result &#x3D; [file1.txt,file2.txt]等价于先处理file1.txt，在处理file2.txt，错误回调\n&#125;);</code></pre><br>    2）async的parallel()方法实现并行<br>    <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">async.parallel([\n\tfunction (callback)&#123;\n\t\tfs.readFile(&#39;file1.txt&#39;,&#39;utf-8&#39;,calback);\n\t&#125;,\n\tfunction (callback)&#123;\n\t\tfs.readFile(&#39;file2.txt&#39;,&#39;utf-8&#39;,calback);\n\t&#125;\n],function (err,result)&#123;\n\t&#x2F;&#x2F;result &#x3D; [file1.txt,file2.txt]等价于并行处理file1.txt，在处理file2.txt，错误回调\n&#125;);</code></pre><br>    3）async的waterfall()方法实现串行（传参）<br>    略<br>    4）async.auto()可以根据依赖关系自动分析，以最佳顺序执行<br>    略<br>    1.4.5 流程控制模块Step<br>    1)Step接受任意数量任务，所有任务传行执行<br>    <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">Step(\n\tfunction (callback)&#123;\n\t\tfs.readFile(&#39;file1.txt&#39;,&#39;utf-8&#39;,this);\n\t&#125;,\n\tfunction (callback)&#123;\n\t\tfs.readFile(&#39;file2.txt&#39;,&#39;utf-8&#39;,this);\n\t&#125;,\n\tfunction done(err, content) &#123;\n\t\t console.log(content);\n\t&#125;\n);</code></pre><br>    2)Step实现异步任务并行执行要用this的parallel()<br>    <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">Step(\n\tfunction (callback)&#123;\n\t\tfs.readFile(&#39;file1.txt&#39;,&#39;utf-8&#39;,this.parallel());\n\t&#125;,\n\tfunction (callback)&#123;\n\t\tfs.readFile(&#39;file2.txt&#39;,&#39;utf-8&#39;,this.parallel());\n\t&#125;,\n\tfunction done(err, content) &#123;\n\t\t console.log(arguments);\n\t&#125;\n);</code></pre><br>    1.4.6流程控制模块wind<br>    1)wind的$await()方法实现异步等待<br>    2）wind的whenAll()处理并发</p>\n<p>1.5 异步并发控制<br>    1.5.1 bagpipe解决办法（API添加过载保护，用队列控制并发）<br>    <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">var Bagpipe &#x3D; require(&#39;bagpipe&#39;);\n&#x2F;&#x2F;设定最大并发数为10\nvar bagpipe &#x3D; new Bagpipe(10);\nfor(var i &#x3D; 0; i&lt; 100;i++)&#123;\n\tbagpipe.push(async, function ()&#123;\n\n\t&#125;);\n&#125;\nbagpipe.on(&#39;full&#39;,function (length)&#123;\n\tconsole.warn(&#39;底层系统处理不及时&#39;);\n&#125;);</code></pre><br>    1.5.2 拒绝模式<br>    <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">var bagpipe &#x3D; new Bagpipe(10,&#123;\n\trefuse: true\n&#125;);</code></pre><br>    1.5.3 超时控制<br>    <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">var bagpipe &#x3D; new Bagpipe(10, &#123;\n\ttimeout: 3000\n&#125;);</code></pre></p>\n<p>1.6 内存管理<br>    1.6.1 v8内存分为新生代和老生代的<br>    node –max-old-space-size 2048 xxx.js 调整内存大小执行某个脚本<br>    v8堆内存64位系统是1.4G,32位系统是0.7G<br>    新生代内存的回收机制是将堆内存一分为2，使用中的是From，空的是to，进行垃圾回收时，是将from中的存活对象复制到to中，然后释放非存活的，同时from和to对换，缺点是只能使用一半的内存空间<br>    老生带内存的回收机制是将from中的使用的标记，回收未使用的<br>    1.6.2 内部变量无法被外部方法访问 叫闭包<br>    1.6.3 查看内存使用process.memoryUsage() os.totalmem os.freemem </p>\n<p>1.7 Buffer<br>    1.7.1 Buffer与字符串转换<br>    <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">new Buffer(str, [encoding]);\nbuf.write(string, [offset], [length], [encodeing]);\nbuf.tostring([encoding], [start], [end]);</code></pre><br>1.8 网络<br>    1.8.1 tcp协议中的osi模型（分为 物理层、数据链路层、网络层、传输层、会话层、表示层、应用层）<br>    server<br>    <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">var net &#x3D; require(&#39;net&#39;);\nvar server &#x3D; net.createServer(function(socket)&#123;\n\tserver.on(&#39;data&#39;,function(data)&#123;\n\t&#125;);\n\tserver.on(&#39;end&#39;,function(data)&#123;\n\t&#125;);\n\tserver.on(&#39;error&#39;,function(data)&#123;\n\t&#125;);\n\tserver.write(&#39;data&#39;);\n&#125;);\n\nserver.listen(port,function()&#123;\n&#125;)</code></pre><br>    client<br>    <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">var net &#x3D; require(&#39;net&#39;);\nvar client &#x3D; net.connect(&#123;port: 8124&#125;,function(socket)&#123;\n\tclient.on(&#39;data&#39;,function(data)&#123;\n\t&#125;);\n\tclient.on(&#39;end&#39;,function(data)&#123;\n\t&#125;);\n\tclient.on(&#39;error&#39;,function(data)&#123;\n\t&#125;);\n\tclient.write(&#39;data&#39;);\n&#125;);</code></pre><br>    1.8.2 UDP是用户数据包协议，一个套接字可以与多个UDP通信<br>    server<br>    <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">var dgrm &#x3D; require(&quot;dgrm&quot;);\nvar server &#x3D; dgrm.createSocket(&quot;udp4&quot;);\nserver.on(&quot;message&quot;, function (msg, rinfo)&#123;\n\tconsole.log(&quot;xxx&quot;);\n&#125;);\nserver.on(&quot;listening&quot;, function() &#123;\n\tvar address &#x3D; server.address();\n\tconsole.log(&quot;xxx&quot;);\n&#125;);\nserver.bind(41234);</code></pre><br>    client<br>    <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">var dgram &#x3D; require(&#39;dgram&#39;);\nvar messgae &#x3D; new Buffer(&quot;xxxx&quot;);\nvar client &#x3D; dgram.createSocket(&quot;udp4&quot;);\nclinet.send(message, 0, message.length, 41234, &quot;localhost&quot;, function(err,bytes)&#123;\n\tclient.close();\n&#125;);</code></pre><br>    1.8.3 HTTP是构建在TCP之上属于应用层协议<br>    <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">https_request : function(host, path, post_data, cb)&#123;\n    var reqdata &#x3D; JSON.stringify(post_data);\n\tvar options &#x3D; &#123;\n\t    hostname: host,\n\t    port: 443,\n\t    method: &#39;POST&#39;,\n\t    path: path,\n\t    headers: &#123;\n\t        &#39;Content-Type&#39;: &#39;application&#x2F;json&#39;\n\t    &#125;\n\t&#125;;\n\n\tvar req_time_out &#x3D; setTimeout(function() &#123;\n    \t\treq.abort();\n    \t\tcb(400, &#123;code:400,message:&#39;请求超时&#39;&#125;);\n    \t\tlogger.n.info(&#39;Got Request Timeout.&#39;);\n\t&#125;, 10000);\n\n\tvar req &#x3D; https.request(options, function (res) &#123;\n\t\tclearTimeout(req_time_out);\n\t\t&#x2F;&#x2F;等待响应60秒超时\n\t\tvar res_time_out &#x3D; setTimeout(function() &#123;\n\t\t\tres.destroy();\n\t\t\tcb(400, &#123;code:400,message:&#39;响应超时&#39;&#125;);\n\t\t\tlogger.n.info(&#39;Got Response Timeout.&#39;);\n\t\t&#125;, 60000);\n\t\tvar status_code &#x3D; res.statusCode;\n\t\tvar body &#x3D; null;\n\t\tlogger.n.info(&quot;Got status_code: &quot; + status_code);\n\t\tres.on(&#39;data&#39;,function(data)&#123;\n            body &#x3D; JSON.parse(data);\n        &#125;).on(&#39;end&#39;, function()&#123;\n        \tclearTimeout(res_time_out);\n        \tcb(status_code, body);\n        &#125;);\n\t&#125;).on(&#39;error&#39;, function(e) &#123;\n\t\tcb(400, &#123;code:400,message:e.message&#125;);\n\t\tlogger.n.info(&quot;Got error: &quot; + e.message);\n    &#125;);\n\treq.write(reqdata);\n\treq.end();\n   &#125;</code></pre><br>    1.8.4 WebSocket<br>    client<br>    <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">   var client&#x3D; new net.Socket();\nvar flag &#x3D; true;\nvar port &#x3D; 0;\n\nclient.on(&#39;connect&#39;,function ()&#123;\n    &#x2F;&#x2F;正常连接\n    flag &#x3D; true;\n    logger.boot.info(&#39;socket Connection succeed&#39;);\n&#125;);\nclient.on(&#39;end&#39;, function() &#123;\n    &#x2F;&#x2F;flag&#x3D;false;\n    logger.n.warn(&#39;!!!!!tcp_client disconnected&#39;);\n    setTimeout(Fight_Service.tcp_reconnect, 1000);\n&#125;);\nclient.on(&#39;data&#39;,function(data)&#123;\n    &#x2F;&#x2F;得到服务端返回来的数据\n    Fight_Service.processResp(data);\n&#125;);\nclient.on(&#39;error&#39;,function(error)&#123;\n    &#x2F;&#x2F;错误出现之后关闭连接\n    flag &#x3D; false;\n    logger.n.error(&#39;socket error:&#39; + error);\n    client.destroy();\n    setTimeout(Fight_Service.tcp_reconnect, 1000);\n&#125;);\nclient.on(&#39;close&#39;,function()&#123;\n    &#x2F;&#x2F;正常关闭连接\n    flag &#x3D; false;\n    logger.n.warn(&#39;socket Connection closed&#39;);\n    client.destroy();\n&#125;);\n\nFight_Service.tcp_reconnect &#x3D; function(worker_id)&#123;\n   &#x2F;&#x2F;创建socket客户端\n   client.setEncoding(&#39;binary&#39;);\n\n   if (port &#x3D;&#x3D; 0 )&#123;\n       &#x2F;&#x2F;连接到服务端115.159.186.60 8400\n       &#x2F;&#x2F; logger.boot.info(&quot;socket process_work_id:&quot; + worker_id);\n       worker_id &#x3D; worker_id % 8;\n       port &#x3D; 8400 + worker_id;\n   &#125;else&#123;\n       logger.boot.info(&quot;socket tcp_reconnect&quot;);\n   &#125;\n\n   logger.boot.info(&quot;socket_port_id:&quot; + port);\n\n   client.connect(port,&quot;10.96.71.91&quot;);\n&#125;</code></pre></p>\n<p>1.9 多进程<br>    1.9.1 child_process模块<br>    1）spawn()启动一个子进程执行命令，无回调，无超时<br>    2）exec()启动一个子进程执行命令，有回调，有超时<br>    3）execFile()启动一个子进程执行可执行文件<br>    4）fork()启动node子进程执行js文件模块<br>    node.js在js执行中是单线程的，但是单线程的进程没办法用像多线程那样直接利用多核cpu，那么node.js就得用主从进程的方式fork出新的子进程，在用master主进程管理分配给子进程，通过多个node子进程的使用来利用多核cpu<br>    <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">var fork &#x3D; require(&#39;child_process&#39;).fork;\nvar cpus &#x3D; require(&#39;os&#39;).cpus();\nfor(var i &#x3D; 0; i &lt; cpus.length; i++)&#123;\n\tfork(&#39;.&#x2F;worker.js&#39;);\n&#125;</code></pre><br>    1.9.2 进程间通信IPC，主线程与工作线程之间通过onmessage()和postMessage()进行通信，子进程对象则由send()方法实现主进程向子进程发送数据<br>    1.9.3 句柄是一种用来标识资源的引用，用来拓展有限的文件描述符<br>    <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">child.send(message,[sandHandle])如（child.send(&#39;server&#39;,server)）;\n子进程代码\nprocess.on(&#39;message&#39;,function(m, server)&#123;\n\tif(m &#x3D;&#x3D; &#39;server&#39;)&#123;\n\txxxxx\n&#125;\n&#125;)</code></pre><br>    1.9.4 父进程可以通过kill()方法给子进程发送一个SIGTERM信号杀进程<br>    <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">chid.kill([signal]);\nprocess.kill(pid, [signal]);</code></pre><br>    在退出中加入自动重启可能会有新用户进来请求丢失的情况，工作进程在得知退出时，向主进程发送一个自杀信号（达到先创建在退出进程）<br>    <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">&#x2F;**\n * cluster mode\n *&#x2F;\nif (   opts.get(&#39;cluster&#39;)\n    || config.APP_CLUSTER.ENABLE) &#123;\n    var cluster &#x3D; require(&#39;cluster&#39;);\n    if (cluster.isMaster) &#123;\n        console.log(&#39;[CLUSTER MODE] MASTER&#39;);\n        for (var i&#x3D;0; i&lt;config.APP_CLUSTER.NUM; i++) &#123;\n            cluster.fork();\n        &#125;\n        cluster.on(&#39;exit&#39;, function(worker, code, signal) &#123;\n            console.log(&#39;worker &#39; + worker.process.pid + &#39; died&#39;);\n            cluster.fork();\n        &#125;);\n        return;\n    &#125;\n    console.log(&#39;[CLUSTER MODE] WORKER&#39;);\n&#125;</code></pre><br>    每个新的子进程监听新对应的端口，同时主进程给子进程的分配中大部分是根据一个特点id,比如玩家的特定id%开的进程数平均分配给不同的进程，没有用户要求的情况可以根据子进程数量随机分配请求如下<br>    <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">export function repoRouteTmp(_session: any, msg: any, app: any, next: Function) &#123;\n    let servers &#x3D; app.getServersByType(&#39;repo&#39;);\n    if (!servers || servers.length &#x3D;&#x3D;&#x3D; 0) &#123;\n        next(new Error(&#39;can not find server info for type: &#39; + msg.serverType));\n        return;\n    &#125;\n    let str &#x3D; app.getServerId();\n    let id &#x3D; parseInt(str.replace(&#x2F;[^\\d]&#x2F;g, &#39;&#39;));\n    let server_list: any &#x3D; [];\n    if (id) &#123;\n        let len &#x3D; servers.length;\n        for (let i &#x3D; 0; i &lt; len; i++) &#123;\n            let repo_id &#x3D; parseInt(servers[i].id.replace(&#x2F;[^\\d]&#x2F;g, &#39;&#39;));\n            if (repo_id &gt; 20 &amp;&amp; id &gt; 20) &#123;\n                server_list.push(servers[i].id);\n            &#125; else if (repo_id &lt; 20 &amp;&amp; id &lt; 20) &#123;\n                server_list.push(servers[i].id);\n            &#125;\n        &#125;\n    &#125;\n    let serverId &#x3D; 0\n    if (server_list &amp;&amp; server_list.length) &#123;\n        let end &#x3D; server_list.length - 1;\n        let index &#x3D; randomRange(0, end);\n        serverId &#x3D; server_list[index]\n    &#125; else &#123;\n        let user_id &#x3D; (msg.data || msg).user_id || &#96;$&#123;randomNum()&#125;&#96;; &#x2F;&#x2F; 游客时使用随机\n        let count: number &#x3D; Array.isArray(servers) ? servers.length : 1;\n        let index &#x3D; Math.abs(crc.crc32(user_id)) % count;\n        serverId &#x3D; servers[index].id || 0;\n    &#125;\n    next(undefined, serverId);\n&#125;;</code></pre><br>    虽然利用了多进程调度的形式利用了多核的cpu来提升效率，但是进程间的通信开销还是不小的</p>\n<pre><code>同时进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。\n\n在加上node本身底层的异步io与事件循环本身用的是Libuv的库，这是一个c/c++的跨平台的的基于事件驱动的异步io库，本身是可以利用多线程的属性处理密集io，但是不可否认js本身的优势地方和js的局限性，决定了node.js的性能会低于c++\n\n虽然线程和进程有本质的区别，但是在串行程序的基础上，线程和进程都是为了能提高程序的效率，线程执行开销小，但不利于资源的管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移\n\n在进程内创建、终止线程比创建、终止进程要快；\n\n同一进程内的线程间切换比进程间的切换要快,尤其是用户级线程间的切换。</code></pre><p>1.10 插件<br>    1.10.1 Sequelizejs  此插件在option索引的位置千万不能写错，写错有大几率导致db堵塞<br>    <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">Model.findAll(&#123;\n \t\tattributes: [&#39;foo&#39;, [&#39;bar&#39;, &#39;baz&#39;]]\n&#125;);\nSELECT foo, bar AS baz ...\nModel.findAll(&#123;\n  attributes: [[sequelize.fn(&#39;COUNT&#39;, sequelize.col(&#39;hats&#39;)), &#39;no_hats&#39;]]\n&#125;);\nSELECT COUNT(hats) AS no_hats ...\nPost.findAll(&#123;\n  where: &#123;\n    [Op.or]: [&#123;authorId: 12&#125;, &#123;authorId: 13&#125;]\n  &#125;\n&#125;);\nSELECT * FROM post WHERE authorId &#x3D; 12 OR authorId &#x3D; 13;\nOrder.findAll(&#123;attributes:[&#39;name&#39;, [sequelize.fn(&#39;SUM&#39;, sequelize.col(&#39;price&#39;)), &#39;sum&#39;]], group:&#39;name&#39;, having:[&#39;COUNT(?)&gt;?&#39;, &#39;name&#39;, 1], raw:true&#125;).then(function(result)&#123;\n console.log(result);\n&#125;)\nSELECT &#96;name&#96;, sum(&#96;price&#96;) AS &#96;sum&#96; FROM &#96;orders&#96; AS &#96;Orders&#96; GROUP BY name HAVING COUNT(&#39;name&#39;)&gt;1;</code></pre></p>\n<pre><code>1.10.2 Lodashjs\n[文档](https://www.lodashjs.com/docs/4.17.5.html)\n\n_.indexOf(array, value, [fromIndex=0])\nnumber): Returns the index of the matched value, else -1.\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">_.indexOf([1, 2, 1, 2], 2);\n&#x2F;&#x2F; &#x3D;&gt; 1\n \n&#x2F;&#x2F; Search from the &#96;fromIndex&#96;.\n_.indexOf([1, 2, 1, 2], 2, 2);\n&#x2F;&#x2F; &#x3D;&gt; 3</code></pre>\n_.dropRight(array, [n=1])\n(Array): Returns the slice of array.\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">_.dropRight([1, 2, 3]);\n&#x2F;&#x2F; &#x3D;&gt; [1, 2]\n \n_.dropRight([1, 2, 3], 2);\n&#x2F;&#x2F; &#x3D;&gt; [1]\n\n_.dropRight([1, 2, 3], 0);\n&#x2F;&#x2F; &#x3D;&gt; [1, 2, 3]</code></pre>\n_.filter(collection, [predicate=_.identity])\n(Array): Returns the new filtered array.\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">var users &#x3D; [\n  &#123; &#39;user&#39;: &#39;barney&#39;, &#39;age&#39;: 36, &#39;active&#39;: true &#125;,\n  &#123; &#39;user&#39;: &#39;fred&#39;,   &#39;age&#39;: 40, &#39;active&#39;: false &#125;\n];\n \n_.filter(users, function(o) &#123; return !o.active; &#125;);\n&#x2F;&#x2F; &#x3D;&gt; objects for [&#39;fred&#39;]</code></pre>\n_.find(collection, [predicate=_.identity], [fromIndex=0])\n(*): Returns the matched element, else undefined.\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">\tvar users &#x3D; [\n  &#123; &#39;user&#39;: &#39;barney&#39;,  &#39;age&#39;: 36, &#39;active&#39;: true &#125;,\n  &#123; &#39;user&#39;: &#39;fred&#39;,    &#39;age&#39;: 40, &#39;active&#39;: false &#125;,\n  &#123; &#39;user&#39;: &#39;pebbles&#39;, &#39;age&#39;: 1,  &#39;active&#39;: true &#125;\n];\n \n_.find(users, function(o) &#123; return o.age &lt; 40; &#125;);\n&#x2F;&#x2F; &#x3D;&gt; object for &#39;barney&#39;</code></pre>\n_.forEach(collection, [iteratee=_.identity])\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">_.forEach([1, 2], function(value) &#123;\n  console.log(value);\n&#125;);\n&#x2F;&#x2F; &#x3D;&gt; Logs &#96;1&#96; then &#96;2&#96;.\n \n_.forEach(&#123; &#39;a&#39;: 1, &#39;b&#39;: 2 &#125;, function(value, key) &#123;\n  console.log(key);\n&#125;);</code></pre>\n_.groupBy(collection, [iteratee=_.identity])\n(Object): Returns the composed aggregate object.\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">_.groupBy([6.1, 4.2, 6.3], Math.floor);\n&#x2F;&#x2F; &#x3D;&gt; &#123; &#39;4&#39;: [4.2], &#39;6&#39;: [6.1, 6.3] &#125;\n \n&#x2F;&#x2F; The &#96;_.property&#96; iteratee shorthand.\n_.groupBy([&#39;one&#39;, &#39;two&#39;, &#39;three&#39;], &#39;length&#39;);\n&#x2F;&#x2F; &#x3D;&gt; &#123; &#39;3&#39;: [&#39;one&#39;, &#39;two&#39;], &#39;5&#39;: [&#39;three&#39;] &#125;</code></pre>\n#Promise.map Promise.all 相当于事务 \n_.map(collection, [iteratee=_.identity])\n(Array): Returns the new mapped array.\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">function square(n) &#123;\n  return n * n;\n&#125;\n\n_.map([4, 8], square);\n&#x2F;&#x2F; &#x3D;&gt; [16, 64]\n \n_.map(&#123; &#39;a&#39;: 4, &#39;b&#39;: 8 &#125;, square);\n&#x2F;&#x2F; &#x3D;&gt; [16, 64] (iteration order is not guaranteed)</code></pre>\n#Promise.reduce是顺序执行\n_.reduce(collection, [iteratee=_.identity], [accumulator])  -\n(*): Returns the accumulated value.\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">f_.reduce([1, 2], function(sum, n) &#123;\n  return sum + n;\n&#125;, 0);\n&#x2F;&#x2F; &#x3D;&gt; 3</code></pre>\n_.isEmpty(value)\n(boolean): Returns true if value is empty, else false.\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">_.isEmpty(null);\n&#x2F;&#x2F; &#x3D;&gt; true\n \n_.isEmpty(true);\n&#x2F;&#x2F; &#x3D;&gt; true\n \n_.isEmpty(1);\n&#x2F;&#x2F; &#x3D;&gt; true\n \n_.isEmpty([1, 2, 3]);\n&#x2F;&#x2F; &#x3D;&gt; false\n \n_.isEmpty(&#123; &#39;a&#39;: 1 &#125;);\n&#x2F;&#x2F; &#x3D;&gt; false</code></pre>\n项目案例 略\n\n1.10.3 Moment.js\n[文档](http://momentjs.cn)\n案例使用\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">moment(event.start_time).startOf(&#39;day&#39;)&#x2F;1000;\nmoment.unix(moment().startOf(&#39;month&#39;)&#x2F;1000).utcOffset(config.TIME_ZONE_DIFF).format(&quot;YYYY-MM-DD HH:mm:ss&quot;);</code></pre></code></pre>","text":"第一章 node简介1.1 node的特点 1.1.1 异步I/O 绝大多数操作以异步方式进行调用 1.1.2 事件与回调函数 1.1.3 单线程，但是可以用WebWorkers的方式解决单线程的问题（子进程），用Master-Worker用master统一管理子进程 1.1.4...","link":"","photos":[],"count_time":{"symbolsCount":"18k","symbolsTime":"16 mins."},"categories":[{"name":"IT笔记","slug":"IT笔记","count":21,"path":"api/categories/IT笔记.json"}],"tags":[{"name":"node.js","slug":"node-js","count":7,"path":"api/tags/node-js.json"}],"toc":"","author":{"name":"Fly","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个在夏天会被芒果砸到的城市靠写代码为生的前职业电竞选手","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Pomelo学习笔记","uid":"eb22ca4ed9e8d1628dcb03e5412b9b1b","slug":"pomelo学习笔记","date":"2018-10-23T11:34:45.000Z","updated":"2021-11-30T09:05:36.961Z","comments":true,"path":"api/articles/pomelo学习笔记.json","keywords":"node.js blogs IT 互联网 服务端 游戏 mysql redis","cover":null,"text":"重新认识pomelo服务器配置在server.json里，通过app.js设置服务器及路由，每一个服务器在server下对应一个文件及为一个进程，其中一定包含handler逻辑代码部分不一定包含remote（远程通信、服务器监听用）例如以下 self.app.rpc.chat.c...","link":"","photos":[],"count_time":{"symbolsCount":"7k","symbolsTime":"6 mins."},"categories":[{"name":"IT笔记","slug":"IT笔记","count":21,"path":"api/categories/IT笔记.json"}],"tags":[{"name":"node.js","slug":"node-js","count":7,"path":"api/tags/node-js.json"}],"author":{"name":"Fly","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个在夏天会被芒果砸到的城市靠写代码为生的前职业电竞选手","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"翻译提取替换","uid":"1537605682febdfac8db68bbbd2d14a8","slug":"翻译提取替换","date":"2018-08-03T03:02:18.000Z","updated":"2021-11-30T08:58:03.986Z","comments":true,"path":"api/articles/翻译提取替换.json","keywords":"node.js blogs IT 互联网 服务端 游戏 mysql redis","cover":[],"text":" 提取提取客户端资源文件之前先要用uc-utf8.php转utf-8 把unicode码转成utf-8的日文在提取将要提取文字的文件整合与getFromHtml.sh 放在同目录下#!&#x2F;bin&#x2F;bash #sh getFromHtml.sh under the...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"脚本工具","slug":"脚本工具","count":3,"path":"api/categories/脚本工具.json"}],"tags":[{"name":"游戏","slug":"游戏","count":8,"path":"api/tags/游戏.json"}],"author":{"name":"Fly","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个在夏天会被芒果砸到的城市靠写代码为生的前职业电竞选手","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}