{"title":"微信Baidu审核对接方案实现","uid":"9d448e38833c6c56c1bb282d7671bf10","slug":"微信baidu审核对接方案实现","date":"2021-05-10T10:03:17.000Z","updated":"2021-11-30T08:59:56.618Z","comments":true,"path":"api/articles/微信baidu审核对接方案实现.json","keywords":"node.js blogs IT 互联网 服务端 游戏 mysql redis","cover":null,"content":"<p>微信和百度都有文字及图片视频啥的AI审核接口，文字审核这里就不说了，时间短也比较快，唯一缺点是测试版每秒的并发最多5个，在并发的情况下会出现未审核，有钱的可以升级付费版，没钱的可以在比较空闲的进程中对未审核的作品和评论，进行2次审核，起一个定时器半小时或者1小时来做</p>\n<p>下面着重说下图片审核，至于视频及其他的大文件类似</p>\n<p>百度审核图片分为2种，1种是图片下载地址的方式，1种是图片base64字符串，第一种方式依据下载图片的大小等因素变动比较大，普遍在2秒左右，所以顺序执行会阻塞当前进程，所以也得并行异步审核，审核结束去更新审核状态。第二种方式base64字符串，那么这里涉及的一个问题，图片如果保存在服务端本地必然占用空间，也不好管理（定期删除啥的），全依赖客户端传图片的网络消耗也比较大，所以用异步下载在直接取BUFFER数据base64转字符串就比较合适，当然存本地临时文件会更快，具体可以根据不同方案来定。</p>\n<p>微信审核图片只有1种，就是图片的buffer数据完整审核，性能也比较快，所以服务端的问题也是选择下载还是存临时文件读取临时文件来做审核，可根据需求来定</p>\n<p>具体实现代码如下</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">export async function check(consumer: any, msg: any, _msgObject: any) &#123;\n    &#x2F;&#x2F; consumer.shift(); &#x2F;&#x2F; 回复写入成功\n    const AiTypeMap:any &#x3D; &#123;&#39;1&#39;:&#123;&#39;1&#39;:true,&#39;10&#39;:true,&#39;13&#39;:true&#125;,&#39;4&#39;:&#123;&#39;1&#39;:true,&#39;6&#39;:true&#125;&#125;;&#x2F;&#x2F;AI审核类型初始\n    let files &#x3D; msg.files || [];\n    let id &#x3D; msg.id || &#39;&#39;;\n    let platform_id &#x3D; msg.platform_id || &#39;&#39;;\n    const wx &#x3D; &quot;103&quot;;&#x2F;&#x2F;微信小程序渠道号\n    if (!files || !files.length || !id) &#123;\n        logger.error(&quot;error checkImgSync&quot;);\n        consumer.shift(); &#x2F;&#x2F; 回复写入成功\n        return\n    &#125;\n    let errFlag &#x3D; false;\n    let imgSensitivePlugin &#x3D; pomelo.app.get(&#39;imgSensitiveService&#39;);\n    for(let i &#x3D; 0;files &amp;&amp; i &lt; files.length; i++)&#123;\n        let path &#x3D; files[i][&#39;path&#39;] || &#39;&#39;;\n        let n_type &#x3D; files[i][&#39;n_type&#39;] || 0;\n        let fileName &#x3D; files[i][&#39;fileName&#39;] || &#39;&#39;;\n        let result:any &#x3D; &#123;conclusionType : 2&#125;;\n        let pos &#x3D; fileName.indexOf(&#39;.&#39;);\n        let type &#x3D; fileName.substring(pos+1,fileName.length);\n        if(n_type &#x3D;&#x3D; 1)&#123;&#x2F;&#x2F;图片\n            if(platform_id &#x3D;&#x3D; wx)&#123;\n                let binaryData &#x3D; await downImg(path);\n                if(binaryData)&#123;\n                    let wxResult &#x3D; await wxImgCheck(binaryData, type);\n                    if(wxResult)&#123;\n                        let  base64Img &#x3D; binaryData.toString(&#39;base64&#39;);\n                        result &#x3D; await baiduImgCheck(base64Img, type);\n                    &#125;else&#123;&#x2F;&#x2F;审核不通过\n                        errFlag &#x3D; true;\n                        break;\n                    &#125;\n                &#125;\n            &#125;else&#123;\n                result &#x3D; await baiduImgPathCheck(path, type);\n            &#125;\n           \n            &#x2F;&#x2F; if(result)&#123;&#x2F;&#x2F;测试\n            if(result.conclusionType !&#x3D; 1 &amp;&amp; result.data)&#123;\n                let list &#x3D; result.data;\n                for(let l &#x3D;0; l &lt; list.length; l++)&#123;\n                    if(AiTypeMap[list[0][&#39;type&#39;]] &amp;&amp; AiTypeMap[list[0][&#39;type&#39;]][list[0][&#39;subType&#39;]])&#123;\n                        continue;\n                    &#125;else&#123;\n                        errFlag &#x3D; true;\n                        break;\n                    &#125;\n                &#125;\n            &#125;\n            if(errFlag)break;\n        &#125;\n    &#125;\n    if(!errFlag)&#123;\n        await imgSensitivePlugin.update(id);&#x2F;&#x2F;更新缓存及db数据\n    &#125;\n    consumer.shift(); &#x2F;&#x2F; 回复写入成功\n&#125;</code></pre>\n<span id=\"more\"></span>\n\n<p>//百度图片路径审核</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">async function baiduImgPathCheck(path: string, type:string): Promise&lt;any&gt; &#123;\n    let imgSensitivePlugin &#x3D; pomelo.app.get(&#39;imgSensitiveService&#39;);\n    return new Promise((resolve, _reject) &#x3D;&gt; &#123;\n        imgSensitivePlugin.checkPath(path, type).then((res: any) &#x3D;&gt; &#123;\n            resolve(res);\n        &#125;).catch((_err: any) &#x3D;&gt; &#123;\n            logger.error(&#39;checkImg error error:%s&#39;, _err)\n            let data &#x3D; &#123;conclusionType : 2&#125;;\n            resolve(data)\n        &#125;)\n    &#125;);\n&#125;</code></pre>\n<p>//百度图片审核</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">async function baiduImgCheck(binaryData: any, type:string): Promise&lt;any&gt; &#123;\n    let imgSensitivePlugin &#x3D; pomelo.app.get(&#39;imgSensitiveService&#39;);\n    return new Promise((resolve, _reject) &#x3D;&gt; &#123;\n        imgSensitivePlugin.checkImg(binaryData, type).then((res: any) &#x3D;&gt; &#123;\n            resolve(res);\n        &#125;).catch((_err: any) &#x3D;&gt; &#123;\n            logger.error(&#39;checkImg error error:%s&#39;, _err)\n            let data &#x3D; &#123;conclusionType : 2&#125;;\n            resolve(data)\n        &#125;)\n    &#125;);\n&#125;</code></pre>\n<p>//微信图片审核</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">async function wxImgCheck(binaryData: any, type:string): Promise&lt;any&gt; &#123;\n    let imgSensitivePlugin &#x3D; pomelo.app.get(&#39;imgSensitiveService&#39;);\n    return new Promise((resolve, _reject) &#x3D;&gt; &#123;\n        imgSensitivePlugin.wxCheckImg(binaryData, type).then((res: any) &#x3D;&gt; &#123;\n            if(res &amp;&amp; res.errcode  &#x3D;&#x3D; 0)&#123;\n                resolve(true);\n            &#125;\n            resolve(false);\n        &#125;).catch((_err: any) &#x3D;&gt; &#123;\n            logger.error(&#39;wxCheck error error:%s&#39;, JSON.stringify(_err));\n            let data &#x3D; false;\n            resolve(data)\n        &#125;)\n    &#125;);\n&#125;</code></pre>\n<p>//下载图片</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">async function downImg(path: string): Promise&lt;any&gt; &#123;\n    let imgSensitivePlugin &#x3D; pomelo.app.get(&#39;imgSensitiveService&#39;);\n    return new Promise((resolve, _reject) &#x3D;&gt; &#123;\n        imgSensitivePlugin.downImg(path).then((res: any) &#x3D;&gt; &#123;\n            resolve(res);\n        &#125;).catch((_err: any) &#x3D;&gt; &#123;\n            logger.error(&#39;downImg error error:%s&#39;, _err)\n            let data &#x3D; null;\n            resolve(data)\n        &#125;)\n    &#125;);\n&#125;</code></pre>\n<p>下载图片异步下载下载完成后将图片数据保存或者直接使用，不用promise就是异步下载，但是因为审核需要逐一审核所以使用选择顺序执行，也可以异步下载保存后再需要使用的时候读取来使用</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">public downImg(path:string)&#123;\n        return new Promise((resolve, reject)&#x3D;&gt;&#123;\n            https.request(path, function(response) &#123;                                       \n                var data &#x3D; new stream.Transform();                                                   \n             \n                response.on(&#39;data&#39;, function(chunk) &#123;                                      \n                    data.push(chunk);                                 \n                &#125;); \n               \n                response.on(&#39;error&#39;, function(err) &#123;                                      \n                    return reject(err);                                       \n                &#125;); \n             \n                response.on(&#39;end&#39;, function() &#123;  \n                    &#x2F;&#x2F; fs.writeFileSync(&#39;image.png&#39;, data.read()); \n                    return resolve(data.read());                                                              \n                &#125;);                                                                        \n            &#125;).end();\n        &#125;); \n    &#125;</code></pre>\n<p>baidu的路径和图片两种审核方式区别就一个参数image:imgData,换成imgUrl:path</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">&#x2F;**\n     * 检查图片\n     * @param imgData 图片二进制数据\n     * @see https:&#x2F;&#x2F;ai.baidu.com&#x2F;ai-doc&#x2F;ANTIPORN&#x2F;jk42xep4e\n     * @see http:&#x2F;&#x2F;wiki.bigdata.99.com&#x2F;bin&#x2F;view&#x2F;%E6%99%BA%E8%83%BD%E9%97%AE%E7%AD%94%E7%B3%BB%E7%BB%9F&#x2F;AI%E6%95%8F%E6%84%9F%E8%AF%8D%E6%A8%A1%E5%9D%97&#x2F;\n     *&#x2F;\n     public async checkImg(imgData: any, type:string): Promise&lt;any&gt; &#123;\n        let conf &#x3D; this.app.get(&#39;imgSensitiveConfig&#39;);\n        if (!imgData) &#123;\n            throw &#39;invalid params &quot;checkImg&quot;.&#39;\n        &#125;\n        let url &#x3D;  conf.url || &#39;http:&#x2F;&#x2F;apiproxy.debug.web.nd&#x2F;v0.2&#x2F;&#39;,\n            ai_method &#x3D; conf.ai_method || &#39;visitor&#x2F;forwards&#x2F;baidu&#x2F;img_censor&#39;,\n            baidu_app_id &#x3D; conf.baidu_app_id || &#39;&#39;, &#x2F;&#x2F;增加应用自定义的敏感词库导入\n            baidu_api_key &#x3D; conf.baidu_api_key || &#39;&#39;,\n            baidu_secret_key &#x3D; conf.baidu_secret_key || &#39;&#39;;\n        let imgType &#x3D; type &#x3D;&#x3D; &quot;gif&quot; ? 1 : 0;\n        let data &#x3D; &#123;\n            baidu_app_id: baidu_app_id,\n            baidu_api_key:baidu_api_key,\n            baidu_secret_key:baidu_secret_key,\n            image:imgData,\n            imgType:imgType\n        &#125;\n        url &#x3D; url + ai_method;\n        return this.request(url, &#39;POST&#39;, data, baidu_app_id);\n    &#125;</code></pre>\n<p>wx审核参数比较重要缺1不可，错误码41005一定是参数有误，41001一定是access_token不对</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">&#x2F;**\n     * 微信检查图片\n     * @param imgData 图片二进制数据\n     * @see https:&#x2F;&#x2F;developers.weixin.qq.com&#x2F;miniprogram&#x2F;dev&#x2F;api-backend&#x2F;open-api&#x2F;sec-check&#x2F;security.imgSecCheck.html\n     * @see http:&#x2F;&#x2F;wiki.bigdata.99.com&#x2F;bin&#x2F;view&#x2F;%E6%99%BA%E8%83%BD%E9%97%AE%E7%AD%94%E7%B3%BB%E7%BB%9F&#x2F;AI%E6%95%8F%E6%84%9F%E8%AF%8D%E6%A8%A1%E5%9D%97&#x2F;\n     *&#x2F;\n     public async wxCheckImg(imgData: any, type:string): Promise&lt;any&gt; &#123;\n        let conf &#x3D; this.app.get(&#39;imgSensitiveConfig&#39;);\n        if (!Buffer.isBuffer(imgData)) &#123;\n            throw &#39;invalid params &quot;wxCheckImg&quot;.&#39;\n        &#125;\n        let access_token &#x3D; await this.getWxAccessToken();\n        let checkUrl &#x3D; conf.wx_check_url || &quot;https:&#x2F;&#x2F;api.weixin.qq.com&#x2F;wxa&#x2F;&quot;;\n        checkUrl +&#x3D; &quot;img_sec_check?access_token&#x3D;&quot; + access_token;\n        return this.requestFrom(checkUrl, &#39;POST&#39;, imgData, &quot;image&#x2F;&quot;+type, &quot;1.png&quot;);\n    &#125;\nprivate async requestFrom(url: string, method: string, data: any, typeStr:string, fileName:string): Promise&lt;any&gt; &#123;\n        let formData &#x3D; new FormData();\n        formData.append(&#39;media&#39;, data, &#123;filename:fileName, contentType: typeStr&#125;);&#x2F;&#x2F;media必须是key,fileName必须要有\n        let resp &#x3D; await fetch(url, &#123; method: method, body: formData, headers: formData.getHeaders() &#125;);\n        return new Promise((resolve, reject) &#x3D;&gt; &#123;\n            if (!resp || resp.status !&#x3D; 200) &#123;\n                logger.warn(&#96;imgSnsitive $&#123;method&#125; $&#123;url&#125; body:%j&#96;, data);\n                let status &#x3D; resp &amp;&amp; resp.status || 0;\n                resp.json().then(res &#x3D;&gt; &#123;\n                    logger.warn(&#96;sensitive resp:%s res:%j&#96;, status, res);\n                &#125;);\n                return reject(&#39;sensitive resp status:&#39; + status);\n            &#125;\n            &#x2F;&#x2F; resolve(resp.json());\n            &#x2F;&#x2F;尝试以json结果返回\n            resp.json().then(data &#x3D;&gt; &#123;\n                resolve(data);\n            &#125;).catch(_ &#x3D;&gt; &#123;\n                &#x2F;&#x2F;尝试以text结果返回\n                resp.text().then(data &#x3D;&gt; &#123;\n                    resolve(data);\n                &#125;).catch(error &#x3D;&gt; &#123;\n                    return reject(error);\n                &#125;);\n            &#125;)\n        &#125;);\n    &#125;</code></pre>","text":"微信和百度都有文字及图片视频啥的AI审核接口，文字审核这里就不说了，时间短也比较快，唯一缺点是测试版每秒的并发最多5个，在并发的情况下会出现未审核，有钱的可以升级付费版，没钱的可以在比较空闲的进程中对未审核的作品和评论，进行2次审核，起一个定时器半小时或者1小时来做 下面着重说下...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"IT笔记","slug":"IT笔记","count":21,"path":"api/categories/IT笔记.json"}],"tags":[{"name":"node.js","slug":"node-js","count":7,"path":"api/tags/node-js.json"}],"toc":"","author":{"name":"Fly","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个在夏天会被芒果砸到的城市靠写代码为生的前职业电竞选手","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"算法","uid":"7b15f460606fcb4d23e6a93344af8c37","slug":"算法","date":"2021-06-23T07:06:23.000Z","updated":"2021-11-30T08:59:49.772Z","comments":true,"path":"api/articles/算法.json","keywords":"node.js blogs IT 互联网 服务端 游戏 mysql redis","cover":null,"text":"最常用的几种算法1.快速排序快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排...","link":"","photos":[],"count_time":{"symbolsCount":"6.2k","symbolsTime":"6 mins."},"categories":[{"name":"IT笔记","slug":"IT笔记","count":21,"path":"api/categories/IT笔记.json"}],"tags":[{"name":"算法","slug":"算法","count":1,"path":"api/tags/算法.json"}],"author":{"name":"Fly","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个在夏天会被芒果砸到的城市靠写代码为生的前职业电竞选手","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Skynet","uid":"000e187a17a937440770c60b6bdf94f6","slug":"skynet","date":"2021-02-20T09:26:44.000Z","updated":"2021-11-30T09:06:00.566Z","comments":true,"path":"api/articles/skynet.json","keywords":"node.js blogs IT 互联网 服务端 游戏 mysql redis","cover":null,"text":"Skynet 是一个基于 Actor 模式的开源并发框架。 skynet 节点，通过 master ，认识网络中所有其它 skynet 节点。它们相互一一建立单向通讯通道。也就是说，如果一共有 100 个 skynet 节点，在它们启动完毕后，会建立起 1 万条通讯通道。 这个系...","link":"","photos":[],"count_time":{"symbolsCount":949,"symbolsTime":"1 mins."},"categories":[{"name":"IT笔记","slug":"IT笔记","count":21,"path":"api/categories/IT笔记.json"}],"tags":[{"name":"游戏","slug":"游戏","count":8,"path":"api/tags/游戏.json"}],"author":{"name":"Fly","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个在夏天会被芒果砸到的城市靠写代码为生的前职业电竞选手","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}