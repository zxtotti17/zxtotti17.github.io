{"title":"Redis 数据结构","uid":"90377550ef5a56f28985406fa3be8444","slug":"redis-数据结构","date":"2021-02-05T09:22:19.000Z","updated":"2021-05-12T11:43:14.504Z","comments":true,"path":"api/articles/redis-数据结构.json","keywords":"node.js blogs IT 互联网 服务端 游戏 mysql redis","cover":null,"content":"<p>redis 的数据存储类型分为String Hash  List  Set(集合） zset(有序集合)</p>\n<p>1.String为最基本的类型， 及Key value的形式，我们可以根据具体业务上的需求去定义key来达到1对1的关系，可以理解为一个最简单的m<br>struct sdshdr {</p>\n<pre><code>// 记录 buf 数组中已使用字节的数量\n// 等于 SDS 所保存字符串的长度\nint len;\n\n// 记录 buf 数组中未使用字节的数量\nint free;\n\n// 字节数组，用于保存字符串\nchar buf[];</code></pre><p>};</p>\n<p>SDS 的空间分配策略：</p>\n<p>len 和free会分配扩充需要的同样空间，知道所有都不够才会在需要分配，string尽量不要超过1MB</p>\n<p>缩减字符串的时候原先的len减少多余的放到free中，总大小不变</p>\n<p>2.Hash是（key =&gt; value）的集合，相当于一个二级map ，可以通过secoundKey 来确定二级key下的唯一数据，如果遇到复杂业务逻辑需要多个字段来确定唯一性的时候可以考虑用hash的形式保存数据</p>\n<p>Hash表的底层原理：</p>\n<p>typedef struct dictht {</p>\n<pre><code>// 哈希表数组\ndictEntry **table;\n\n// 哈希表大小\nunsigned long size;\n\n// 哈希表大小掩码，用于计算索引值\n// 总是等于 size - 1\nunsigned long sizemask;\n\n// 该哈希表已有节点的数量\nunsigned long used;</code></pre><p>} dictht;</p>\n<p><a href=\"graphviz-bd3eecd927a4d8fc33b4a1c7f5957c52d67c5021.png\">!hash1</a><br>哈希表节点使用 dictEntry 结构表示</p>\n<p>typedef struct dictEntry {</p>\n<pre><code>// 键\nvoid *key;\n\n// 值\nunion &#123;\n    void *val;\n    uint64_t u64;\n    int64_t s64;\n&#125; v;\n\n// 指向下个哈希表节点，形成链表\nstruct dictEntry *next;</code></pre><p>} dictEntry;</p>\n<p>key 属性保存着键值对中的键， 而 v 属性则保存着键值对中的值， 其中键值对的值可以是一个指针， 或者是一个 uint64_t 整数， 又或者是一个 int64_t 整数。</p>\n<p>next 属性是指向另一个哈希表节点的指针， 这个指针可以将多个哈希值相同的键值对连接在一次， 以此来解决键冲突（collision）的问题。</p>\n<span id=\"more\"></span>\n\n<p>Redis 中的字典由 dict.h/dict 结构表示：</p>\n<p>typedef struct dict {</p>\n<pre><code>// 类型特定函数\ndictType *type;\n\n// 私有数据\nvoid *privdata;\n\n// 哈希表\ndictht ht[2];\n\n// rehash 索引\n// 当 rehash 不在进行时，值为 -1\nint rehashidx; /* rehashing not in progress if rehashidx == -1 */</code></pre><p>} dict;<br><a href=\"graphviz-e73003b166b90094c8c4b7abbc8d59f691f91e27.png\">!hash2</a></p>\n<p>Hash结构的扩容与回收是一种rehash的机制，类似string的扩容，将ht[1]中保存新的数据及同样大小的空数据[]，然后ht[0]释放<br>ht[1]变ht[0],ht[1]重新变成空结构</p>\n<p>List是简单的字符串列表,是双向链表， 增删快，数据类型是可重复的，相当于一个数组，适合最新消息显示这样的，头插入或者尾插入</p>\n<p>typedef struct listNode {</p>\n<pre><code>// 前置节点\nstruct listNode *prev;\n\n// 后置节点\nstruct listNode *next;\n\n// 节点的值\nvoid *value;</code></pre><p>} listNode;</p>\n<p>用多个 listNode 结构就可以组成链表</p>\n<p>typedef struct list {</p>\n<pre><code>// 表头节点\nlistNode *head;\n\n// 表尾节点\nlistNode *tail;\n\n// 链表所包含的节点数量\nunsigned long len;\n\n// 节点值复制函数\nvoid *(*dup)(void *ptr);\n\n// 节点值释放函数\nvoid (*free)(void *ptr);\n\n// 节点值对比函数\nint (*match)(void *ptr, void *key);</code></pre><p>} list;</p>\n<p>set是String类型的无序集合，且集合的数据有唯一性，更新集合中的一条数据需要remove在add，最好在外部rowKey确定是唯一数据的时候，比如一个玩家包含玩家的关卡列表<br>数据结构是intset或者hashtable</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">typedef struct intset &#123;\n\n    &#x2F;&#x2F; 编码方式\n    uint32_t encoding;\n\n    &#x2F;&#x2F; 集合包含的元素数量\n    uint32_t length;\n\n    &#x2F;&#x2F; 保存元素的数组\n    int8_t contents[];\n\n&#125; intset;</code></pre>\n\n<p>比如1对1对多的形式，不要用多对1对多来去存储，在并发的时候会导致原子性取不到的情况</p>\n<p>zset是set的有序形式，多了一个socure字段进行排序，socure为double型，适用于排行榜去做自动排序</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">typedef struct zset &#123;\n\n    zskiplist *zsl;\n\n    dict *dict;\n\n&#125; zset;</code></pre>\n<p>zset 结构中的 zsl 跳跃表按分值从小到大保存了所有集合元素， 每个跳跃表节点都保存了一个集合元素： 跳跃表节点的 object 属性保存了元素的成员， 而跳跃表节点的 score 属性则保存了元素的分值。 通过这个跳跃表， 程序可以对有序集合进行范围型操作， 比如 ZRANK 、 ZRANGE 等命令就是基于跳跃表 API 来实现的。<br>zset 结构中的 dict 字典为有序集合创建了一个从成员到分值的映射， 字典中的每个键值对都保存了一个集合元素： 字典的键保存了元素的成员， 而字典的值则保存了元素的分值。 通过这个字典， 程序可以用 O(1) 复杂度查找给定成员的分值， ZSCORE 命令就是根据这一特性实现的， 而很多其他有序集合命令都在实现的内部用到了这一特性。</p>\n<p>参考文献：<a href=\"http://redisbook.com/\">http://redisbook.com/</a></p>\n","text":"redis 的数据存储类型分为String Hash List Set(集合） zset(有序集合) 1.String为最基本的类型， 及Key value的形式，我们可以根据具体业务上的需求去定义key来达到1对1的关系，可以理解为一个最简单的mstruct sdshdr { ...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"数据库","slug":"数据库","count":1,"path":"api/categories/数据库.json"}],"tags":[{"name":"redis","slug":"redis","count":2,"path":"api/tags/redis.json"}],"toc":"","author":{"name":"Fly","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个在夏天会被芒果砸到的城市靠写代码为生的前职业电竞选手","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Skynet","uid":"000e187a17a937440770c60b6bdf94f6","slug":"skynet","date":"2021-02-20T09:26:44.000Z","updated":"2021-11-30T09:06:00.566Z","comments":true,"path":"api/articles/skynet.json","keywords":"node.js blogs IT 互联网 服务端 游戏 mysql redis","cover":null,"text":"Skynet 是一个基于 Actor 模式的开源并发框架。 skynet 节点，通过 master ，认识网络中所有其它 skynet 节点。它们相互一一建立单向通讯通道。也就是说，如果一共有 100 个 skynet 节点，在它们启动完毕后，会建立起 1 万条通讯通道。 这个系...","link":"","photos":[],"count_time":{"symbolsCount":949,"symbolsTime":"1 mins."},"categories":[{"name":"IT笔记","slug":"IT笔记","count":21,"path":"api/categories/IT笔记.json"}],"tags":[{"name":"游戏","slug":"游戏","count":8,"path":"api/tags/游戏.json"}],"author":{"name":"Fly","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个在夏天会被芒果砸到的城市靠写代码为生的前职业电竞选手","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"消息队列","uid":"a238c8f44f70d50de3377d42da7a86a2","slug":"消息队列","date":"2021-01-22T08:57:26.000Z","updated":"2021-11-30T09:00:19.903Z","comments":true,"path":"api/articles/消息队列.json","keywords":"node.js blogs IT 互联网 服务端 游戏 mysql redis","cover":[],"text":"消息队列是分布式应用间交换信息的重要组件，消息队列可驻留在内存或磁盘上, 队列可以存储消息直到它们被应用程序读走。 通过消息队列，应用程序可以在不知道彼此位置的情况下独立处理消息，或者在处理消息前不需要等待接收此消息。 所以消息队列可以解决应用解耦、异步消息、流量削锋等问题，是实...","link":"","photos":[],"count_time":{"symbolsCount":858,"symbolsTime":"1 mins."},"categories":[{"name":"IT笔记","slug":"IT笔记","count":21,"path":"api/categories/IT笔记.json"}],"tags":[{"name":"MQ","slug":"MQ","count":1,"path":"api/tags/MQ.json"}],"author":{"name":"Fly","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个在夏天会被芒果砸到的城市靠写代码为生的前职业电竞选手","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}