{"title":"node.js插件","uid":"772f75bc85a5f28f8e914897060b12ef","slug":"node-js插件","date":"2020-11-11T07:03:25.000Z","updated":"2021-11-30T09:05:06.460Z","comments":true,"path":"api/articles/node-js插件.json","keywords":"node.js blogs IT 互联网 服务端 游戏 mysql redis","cover":null,"content":"<p>方便开发者根据自身的需求对pomelo原有的功能进行有效的扩展，此目录下可以扩展业务插件。</p>\n<p>1.高并发下的统计数据插件</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">import readNumPlugin &#x3D; require(&#39;.&#x2F;plugins&#x2F;read-num-plugin&#39;);\n\napp.use(readNumPlugin, &#123;\n     readNum: &#123;\n        minute:10,\n        expired:24 * 3600,\n        redis_dbid:dbConfig.REDIS.master,\n        worksTable:&quot;works&quot;,\n        clickTable:&quot;click&quot;\n    &#125;\n&#125;);</code></pre>\n<ul>\n<li>调用方式<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">let readNum &#x3D; pomelo.app.get(&#39;readNumService&#39;);\nlet arrWorks &#x3D; [];\nlet res &#x3D; await readNum.addWorksClick(arrWorks);\n\nlet readNum &#x3D; pomelo.app.get(&#39;readNumService&#39;);\nlet workId &#x3D; &quot;123456&quot;;\nlet res &#x3D; await readNum.getWorkClick(workId);</code></pre>\n\n</li>\n</ul>\n<p>游客或者会员在点击文章的时候，需要对文章的点击量做一个计数统计。考虑到点击量计数的准确性，有以下几个需求：</p>\n<p>用户可以不需要登录<br>每当用户点击文章的详情页面，这个文章的点击量+1<br>用户能实时看到文章点击量，也就是用户点击后能及时看到+1<br>点击量最终保存在数据库中，最终一致性<br>作者在后台编辑文章然后保存时，如果这期间有点击量的增加，保存文章时不能覆盖掉这段时间的增量<br>需要对用户去重处理，也就是一个人在一定时间内多次点击只计数一次，防止用户不断刷新或者使用爬虫不断请求某个API<br>要过滤掉百度和谷歌的爬虫请求（根据User-Agent头判断，可以先不做）<br>一、设计思路</p>\n<p>1、因为用户的数量可能很多，所以要求做到高并发，直接在数据库做加1操作不行，考虑利用缓存计数；</p>\n<p>2、要求最终数据库数据一致性，考虑利用定时任务从缓存中获取；</p>\n<p>3、用户可以匿名，所以缓存的key设计可以用文章标题的hash+用户ip；</p>\n<p>4、防止爬虫或者快速刷接口，需要在后端对同一个用户的同一篇文章在缓存中打标；</p>\n<p>5、保存文章更新的时候，不能更新点击量，点击量通过定时任务从缓存中获取，防止数据被覆盖；</p>\n<p>5、考虑到缓存的使用效率，需要对缓存的key做过期设置，或者主动清除旧的key。</p>\n<p> 所以设计的时候将统计在缓存中进行统计每隔10分钟（可配置）更新一次统计数据到db，减小了db再高并发情况下的压力</p>\n<p>用string类型缓存用户ip的时间，10分钟内只计算一次</p>\n<p>用hash类型缓存作品点击数，定时更新，及删除</p>\n<p>//验证添加点击</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">\npublic async checkAndAdd(works_id: string, ip: string): Promise&lt;any&gt; &#123;\n        let update_time &#x3D; await this.getWorkIp(works_id, ip);\n        let now &#x3D; Math.floor(new Date().getTime() &#x2F; 1000 &#x2F; 60 &#x2F; this.minute);\n        if(update_time &lt; now)&#123;\n            let addWorkClick &#x3D; await this.addWorkIp(works_id, ip, now);\n            if(addWorkClick)&#123;\n                await this.addWorkClick(works_id, now);&#x2F;&#x2F;1\n            &#125;\n        &#125;\n        return true;\n    &#125;</code></pre>\n<p>//统计更新db</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">public async sensitiveReadNum():Promise&lt;any&gt;&#123;\n        let now &#x3D; Math.floor(new Date().getTime() &#x2F; 1000 &#x2F; 60 &#x2F; this.minute);\n        let create_time &#x3D; new Date(new Date().toLocaleDateString() + &quot; 00:00:00&quot;).getTime()&#x2F;1000;\n        let ret &#x3D; await this.getAllWorkClick(now - 1);\n        if(!ret) return false;\n        for(let k in ret)&#123;\n            let workInfo &#x3D; await this.getWorkInfo(k);\n            if(workInfo &amp;&amp; workInfo.length &gt; 0)&#123;\n                workInfo[0].click_num +&#x3D; Number(ret[k]);\n            &#125; \n            this.execSync(&#39;worksSync.update&#39;, workInfo[0]);\n            if(!await this.addDailyClicks(workInfo[0].id, workInfo[0].user_id, ret[k], workInfo[0].click_num, create_time))&#123;\n                logger.error(&quot;addDailyClicks fail&quot;, now);\n            &#125;\n        &#125;\n        return ret;\n    &#125;</code></pre>\n<p>db更新用mq队列的形式保证更新正常执行及并发压力，同时可以将统计的丢到另一个进程，在另一个进程异步做统计</p>\n<span id=\"more\"></span>\n<p>2.验证码插件<br>将验证码写成一个外置插件，这样需要调用的时候只需要在入口处引入在特定地方调用即可非常方便，同时也可挂载到别的应用</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">import verifierApiPlugin &#x3D; require(&#39;.&#x2F;plugins[表情]erifier-api-plugin&#39;);\n\n    app.use(verifierApiPlugin, &#123;\n         verifierApi: &#123;\n            file:&#39;verifierApi.json&#39;,\n            codeNum:4,\n            expired:24 * 3600,\n            redis_dbid:dbConfig.REDIS.master,\n            tableName:&quot;verifier&quot;\n        &#125;\n    &#125;);</code></pre>\n<ul>\n<li>调用方式<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">    let verifierApi &#x3D; pomelo.app.get(&#39;verifierApiService&#39;);\n    let code &#x3D; &#39;xxxx&#39;;\n    let res &#x3D; await verifierApi.check(text);\n&#96;&#96;&#96;   \n\n前置依赖需要安装\n\n&#96;&#96;&#96; bash\n    cnpm i svg-captcha --save </code></pre>\n  或者<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">npm install --save svg-captcha</code></pre>\n\n</li>\n</ul>\n<p>主要功能是验证验证码和刷新生成验证码</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">&#x2F;**\n     * 检查验证码\n     *\n     *&#x2F;\n    public async check(text: string, route:string, userCode:string, platformId:number): Promise&lt;number&gt; &#123;\n        let conf &#x3D; this.app.get(&#39;verifierApiConfig&#39;);\n        let platform &#x3D; conf[route].platform;\n        let max &#x3D; conf[route].max_pre_day || 10;\n        let begin &#x3D; conf[route].bagin_pre_day || 1;\n        if(platform &amp;&amp; platform[platformId])&#123;\n            max &#x3D; platform[platformId].max_pre_day || 21;\n            begin &#x3D; platform[platformId].bagin_pre_day || 20;\n        &#125;\n        \n        let date &#x3D; new Date().toLocaleDateString();\n        if(!conf[route])&#123;\n            throw &#39;invalid params &quot;route&quot;.&#39;\n        &#125;\n        let storage &#x3D; this.app.get(&#39;dbstorageService&#39;);\n        let rows &#x3D; await this.getCache(date, route, userCode, storage);\n        if (rows &amp;&amp; rows.length) &#123;\n            if(rows[0].num &gt; max)&#123;\n                return 2;\n            &#125;else if(rows[0].num &lt; begin || rows[0].code &#x3D;&#x3D; text.toLowerCase())&#123;\n                rows[0].num++;\n                if(await this.addCache(rows[0], storage))&#123;\n                    return 1;\n                &#125;\n            &#125; \n        &#125;\n        return 0;\n    &#125;\n\n&#x2F;&#x2F;刷新验证码得到图形验证码\n\n public async getCode(route:string, userCode:string): Promise&lt;any&gt; &#123;\n        let conf &#x3D; this.app.get(&#39;verifierApiConfig&#39;);\n        let date &#x3D; new Date().toLocaleDateString();\n        if(!route)&#123;\n            throw &#39;invalid params &quot;route&quot;.&#39;\n        &#125;\n        if(conf[route])&#123;\n            let begin &#x3D; conf[route].bagin_pre_day || 1;\n            let storage &#x3D; this.app.get(&#39;dbstorageService&#39;);\n            let rows &#x3D; await this.getCache(date, route, userCode, storage);\n            let codeMap &#x3D; this.createCode();\n            if (rows &amp;&amp; rows.length) &#123;\n                rows[0].code &#x3D; codeMap.code;\n                if(rows[0].num &gt;&#x3D; begin)&#123;\n                    if(await this.addCache(rows[0], storage))&#123;\n                        return &#123;is_verify:1, verify_svg:codeMap.data&#125;;\n                    &#125;\n                &#125; \n            &#125;else&#123;\n                let opts &#x3D; &#123;\n                    userCode:userCode,\n                    date:date,\n                    route:route,\n                    code:codeMap.code,\n                    num:0\n                &#125;\n                await this.addCache(opts, storage);\n            &#125;\n        &#125;\n        return &#123;is_verify:0, verify_svg:&#39;&#39;&#125;;\n    &#125;\n\n&#x2F;&#x2F;插件生成验证码部分 可根据需求自行更改生成字数及干扰条纹配置\n\npublic createCode():any&#123;\n        const colorMap &#x3D; [&#39;#eeeeee&#39;, &#39;skyblue&#39;, &#39;#c8c8c8&#39;] &#x2F;&#x2F; 配置背景图片颜色集合\n     const randomColor &#x3D; colorMap[Math.floor(Math.random() * colorMap.length)] &#x2F;&#x2F;随机颜色\n        let option &#x3D; &#123;\n            size: this.codeNum,  &#x2F;&#x2F;验证码长度\n            width: 200,\n            height: 150,\n            background: randomColor,&#x2F;&#x2F;干扰线条数\n            noise: 2,\n            fontSize: 32,\n            ignoreChars: &#39;0o1i&#39;,   &#x2F;&#x2F;验证码字符中排除&#39;0o1i&#39;\n            color: true &#x2F;&#x2F; 验证码的字符是否有颜色，默认没有，如果设定了背景，则默认有\n        &#125;\n        let code &#x3D; svgCaptcha.create(option);\n        let strCode &#x3D; code.text.toLowerCase();\n        &#x2F;&#x2F; let sCode &#x3D; &quot;A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,1,2,3,4,5,6,7,8,9,0&quot;;\n  &#x2F;&#x2F; let arrCode &#x3D; sCode.split(&quot;,&quot;);\n        &#x2F;&#x2F; let strCode &#x3D; &quot;&quot;;\n        &#x2F;&#x2F; for(let i &#x3D; 0;i &lt; this.codeNum; i++)&#123;\n        &#x2F;&#x2F;     let random &#x3D; Math.floor(Math.random()*arrCode.length);\n        &#x2F;&#x2F;     strCode +&#x3D; arrCode[random];\n        &#x2F;&#x2F; &#125;\n        return &#123;code:strCode, data:code.data&#125;;\n    &#125;</code></pre>","text":"方便开发者根据自身的需求对pomelo原有的功能进行有效的扩展，此目录下可以扩展业务插件。 1.高并发下的统计数据插件 import readNumPlugin &#x3D; require(&#39;.&#x2F;plugins&#x2F;read-num-plugin&#39...","link":"","photos":[],"count_time":{"symbolsCount":"7.7k","symbolsTime":"7 mins."},"categories":[{"name":"IT笔记","slug":"IT笔记","count":21,"path":"api/categories/IT笔记.json"}],"tags":[{"name":"node.js","slug":"node-js","count":7,"path":"api/tags/node-js.json"}],"toc":"","author":{"name":"Fly","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个在夏天会被芒果砸到的城市靠写代码为生的前职业电竞选手","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"消息队列","uid":"a238c8f44f70d50de3377d42da7a86a2","slug":"消息队列","date":"2021-01-22T08:57:26.000Z","updated":"2021-11-30T09:00:19.903Z","comments":true,"path":"api/articles/消息队列.json","keywords":"node.js blogs IT 互联网 服务端 游戏 mysql redis","cover":[],"text":"消息队列是分布式应用间交换信息的重要组件，消息队列可驻留在内存或磁盘上, 队列可以存储消息直到它们被应用程序读走。 通过消息队列，应用程序可以在不知道彼此位置的情况下独立处理消息，或者在处理消息前不需要等待接收此消息。 所以消息队列可以解决应用解耦、异步消息、流量削锋等问题，是实...","link":"","photos":[],"count_time":{"symbolsCount":858,"symbolsTime":"1 mins."},"categories":[{"name":"IT笔记","slug":"IT笔记","count":21,"path":"api/categories/IT笔记.json"}],"tags":[{"name":"MQ","slug":"MQ","count":1,"path":"api/tags/MQ.json"}],"author":{"name":"Fly","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个在夏天会被芒果砸到的城市靠写代码为生的前职业电竞选手","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Mongodb笔记","uid":"03ffe00e2e1072f20d7bd09de5fd3f01","slug":"mongodb笔记","date":"2020-07-28T04:54:03.000Z","updated":"2021-12-09T11:36:06.983Z","comments":true,"path":"api/articles/mongodb笔记.json","keywords":"node.js blogs IT 互联网 服务端 游戏 mysql redis","cover":null,"text":"下载地址：https://www.mongodb.com/download-center#community 解压sudo tar -zxvf mongodb-osx-ssl-x86_64-4.0.9.tgzexport PATH=/usr/local/mongodb/bin:$...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[{"name":"IT笔记","slug":"IT笔记","count":21,"path":"api/categories/IT笔记.json"}],"tags":[{"name":"mongodb","slug":"mongodb","count":1,"path":"api/tags/mongodb.json"}],"author":{"name":"Fly","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个在夏天会被芒果砸到的城市靠写代码为生的前职业电竞选手","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}