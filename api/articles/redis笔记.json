{"title":"Redis笔记","uid":"cf4d6c3460b72521408e1365a505bd53","slug":"redis笔记","date":"2019-08-01T08:52:31.000Z","updated":"2021-11-30T09:05:53.076Z","comments":true,"path":"api/articles/redis笔记.json","keywords":"node.js blogs IT 互联网 服务端 游戏 mysql redis","cover":null,"content":"<ol>\n<li><p>Redis是什么、特点、优势<br>redis是Key-Value数据库,数据包含各种数据 字符串String、字典Hash、列表List、集合Set、有序集合SortedSet等<br>redis支持数据持久化，重启再次加载,支持数据备份(支持分布式),Redis是单进程单线程的<br>Redis的优势<br>性能高 读速度110000/s 写速度81000/s<br>丰富的数据类型</p>\n</li>\n<li><p>redis安装（Linux）、启动、退出、设置密码、远程连接</p>\n</li>\n<li><p>1 安装redis<br>下载redis安装包（如：redis-2.8.17.tar.gz）<br>cd  redis-5.0.5<br>make<br>src/redis-server  也可改配置redis.conf 并修改 daemonize no 为 daemonize yes  启动服务端<br>redis-server /usr/local/redis-5.0.5/redis.conf<br>src/redis-cli 启动客户端<br>src/redis-cli shutdown 停止服务</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">tar -zxvf redis-2.8.17.tar.gz\ncd redis-2.8.17\nmake\nsudo make install</code></pre></li>\n<li><p>2 后台启动服务端</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">nohup redis-server &amp;</code></pre></li>\n<li><p>3 启动客户端、验证</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">cd &#x2F;usr&#x2F;local&#x2F;bin\nredis-cli\nset var &quot;hello world&quot;\nget var</code></pre>\n<span id=\"more\"></span>\n</li>\n<li><p>Reis key<br>序号    Redis keys命令及描述<br>1    DEL key<br>该命令用于在 key 存在是删除 key。<br>2    DUMP key<br>序列化给定 key ，并返回被序列化的值。<br>3    EXISTS key<br>检查给定 key 是否存在。<br>4    EXPIRE key seconds<br>为给定 key 设置过期时间。<br>5    EXPIREAT key timestamp<br>EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。<br>6    PEXPIRE key milliseconds<br>设置 key 的过期时间亿以毫秒计。<br>7    PEXPIREAT key milliseconds-timestamp<br>设置 key 过期时间的时间戳(unix timestamp) 以毫秒计<br>8    KEYS pattern<br>查找所有符合给定模式( pattern)的 key 。例如keys * 返回所有的key<br>9    MOVE key db<br>将当前数据库的 key 移动到给定的数据库 db 当中。<br>10    PERSIST key<br>移除 key 的过期时间，key 将持久保持。<br>11    PTTL key<br>以毫秒为单位返回 key 的剩余的过期时间。<br>12    TTL key<br>以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。<br>13    RANDOMKEY<br>从当前数据库中随机返回一个 key 。<br>14    RENAME key newkey<br>修改 key 的名称<br>15    RENAMENX key newkey<br>仅当 newkey 不存在时，将 key 改名为 newkey 。<br>16    TYPE key<br>返回 key 所储存的值的类型。<br>…<br><a href=\"http://redisdoc.com\">中文文档</a></p>\n</li>\n<li><p>Redis 发布订阅<br>占时没用过，看起来跟微信公众号一样,Pub/Sub做延时队列可以用在玩家登录排队上</p>\n</li>\n<li><p>Redis事务<br>一个事务从开始到结束经过以下三个阶段：</p>\n</li>\n</ol>\n<p>开始事务<br>命令入队<br>执行事务<br>例子</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">localhost:6379&gt; MULTI\nOK\nlocalhost:6379&gt; set name jihite\nQUEUED\nlocalhost:6379&gt; get name\nQUEUED\nlocalhost:6379&gt; sadd language &quot;c++&quot; &quot;python&quot; &quot;java&quot;\nQUEUED\nlocalhost:6379&gt; smembers language\nQUEUED\nlocalhost:6379&gt; exec</code></pre>\n<p>说明：事务以MULTI开始，以EXEC结束</p>\n<ol start=\"6\">\n<li>关闭持久化与持久化<br>(RDB)bgsave做镜像全量持久化，aof做增量持久化<br>RDB相当于快照，是fork一个子进程，快照成功后替换<br>aof相当于日志，cow，copy and write,一条一条的数据</li>\n</ol>\n<p>这是redis与其他缓存服务的比较明显的特点,如memcache<br>修改配置文件，改完后重启。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">#save 900 1  \n#save 300 10  \n#save 60 10000  </code></pre>\n<p>或执行操作命令</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">CONFIG SET save &quot;&quot;</code></pre>\n\n<ol start=\"7\">\n<li>redis相比memcached有哪些优势？</li>\n</ol>\n<p>(1) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型<br>(2) redis的速度比memcached快很多<br>(3) redis可以持久化其数据</p>\n<ol start=\"8\">\n<li>redis常见性能问题和解决方案：</li>\n</ol>\n<p>(1) Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件<br>(2) 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次<br>(3) 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内<br>(4) 尽量避免在压力很大的主库上增加从库<br>(5) 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3…</p>\n<p>这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。</p>\n<ol start=\"9\">\n<li><p>Redis 常见的性能问题都有哪些？如何解决？<br>1).Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以Master最好不要写内存快照。<br>2).Master AOF持久化，如果不重写AOF文件，这个持久化方式对性能的影响是最小的，但是AOF文件会不断增大，AOF文件过大会影响Master重启的恢复速度。Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化,如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。<br>3).Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。<br>4). Redis主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内</p>\n</li>\n<li><p>Redis分布式锁<br>拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。</p>\n</li>\n<li><p>Redis做异步队列<br>一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。</p>\n</li>\n<li><p>Hash结构原子性操作<br>Redis中提供了原子性命令SETEX或SET来写入STRING类型数据并设置Key的过期时间：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">SET key value EX 60 NX\nok\n&gt; SETEX key 60 value\nok</code></pre>\n<p>但对于HASH结构则没有这样的命令，只能先写入数据然后设置过期时间：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">HSET key field value\nok\n&gt; EXPIRE key 60\nok</code></pre>\n<p>这样就带了一个问题：HSET命令执行成功而EXPIRE命令执行失败（如命令未能成功发送到Redis服务器），那么数据将不会过期。推荐2种解决方式</p>\n</li>\n</ol>\n<p>一.LUA脚本形式</p>\n<p>脚本部分的lua代码如下</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">local fieldIndex&#x3D;3\nlocal valueIndex&#x3D;4\nlocal key&#x3D;KEYS[1]\nlocal fieldCount&#x3D;ARGV[1]\nlocal expired&#x3D;ARGV[2]\nfor i&#x3D;1,fieldCount,1 do\n  redis.pcall(&#39;HSET&#39;,key,ARGV[fieldIndex],ARGV[valueIndex])\n  fieldIndex&#x3D;fieldIndex+2\n  valueIndex&#x3D;valueIndex+2\nend\nredis.pcall(&#39;EXPIRE&#39;,key,expired)</code></pre>\n<p>具体可以根据需求改造</p>\n<p>一般有2种形式</p>\n<p>1).eval 立即执行一段lua脚本代码，redisAPI函数有两个参数，第一个是lua脚本的字符串，第二个是对应脚本参数数组项目中具体使用如下</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">&#x2F;**\n* hash原子批量操作\n* count 插入多少条数据\n* time 过期时间\n* data 数据key - value\n*&#x2F;\n    public async setOrAddList(databaseId: string, rowKey:string, count:number, time:number, data: any, flag?: QueryFlag): Promise&lt;boolean&gt; &#123;\n        rowKey &#x3D; this.getRowKey(rowKey);\n        let redisDb: Database &#x3D; this.service.connect(databaseId);\n        let dispatch &#x3D; redisDb.dispatch(flag);\n        let client &#x3D; dispatch.adapter;\n        let arr &#x3D; [];\n        arr.push(CommandMode.Key);&#x2F;&#x2F;key 标识1\n        arr.push(rowKey);\n        arr.push(count);\n        arr.push(time);\n        for(let k in data)&#123;\n            arr.push(k);\n            arr.push(data[k]);\n        &#125;\n        let luaStr &#x3D; &quot;local fieldIndex&#x3D;3;local valueIndex&#x3D;4;local key&#x3D;KEYS[1];local fieldCount&#x3D;ARGV[1];local expired&#x3D;ARGV[2];for i&#x3D;1,fieldCount,1 do redis.pcall(&#39;HSET&#39;,key,ARGV[fieldIndex],ARGV[valueIndex]) fieldIndex&#x3D;fieldIndex+2 valueIndex&#x3D;valueIndex+2 end;redis.pcall(&#39;EXPIRE&#39;,key,expired);&quot;\n        let result &#x3D; await client.EVAL(luaStr, arr);\n        if(!result)&#123;\n            logger.error(&#39;setOrAddList rowKey:%s count:%s&#39;, rowKey, count)\n        &#125;\n        return result\n    &#125;</code></pre>\n<p>2). evalsha 这个先将lua脚本加载内存中得到一串文件码字符串，在通过字符串读取及传参</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">SCRIPT LOAD &quot;local fieldIndex&#x3D;3;local valueIndex&#x3D;4;local key&#x3D;KEYS[1];local fieldCount&#x3D;ARGV[1];local expired&#x3D;ARGV[2];for i&#x3D;1,fieldCount,1 do redis.pcall(&#39;HSET&#39;,key,ARGV[fieldIndex],ARGV[valueIndex]) fieldIndex&#x3D;fieldIndex+2 valueIndex&#x3D;valueIndex+2 end;redis.pcall(&#39;EXPIRE&#39;,key,expired);&quot;\n&quot;e03e7868920b7669d1c8c8b16dcee86ebfac650d&quot;\n&gt; evalsha e03e7868920b7669d1c8c8b16dcee86ebfac650d 1 key 2 1000 field1 value1 field2 value2</code></pre>\n<p>二：事务<br>Redis命令只会在有语法错误或对Key使用了错误的数据类型时执行失败。因此，只要我们保证将正确的写数据和设置过期时间的命令作为一个整体发送到服务器端即可，使用Lua脚本正式基于此。<br> <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">public async Task&lt;bool&gt; WriteAsync(string key, IDictionary&lt;string, string&gt; valueDict, TimeSpan expiry)\n&#123;\n    var tranc &#x3D; Database.CreateTransaction();\n    foreach (var item in valueDict)\n    &#123;\n        tranc.HashSetAsync(key, item.Key, item.Value);\n    &#125;\n    tranc.KeyExpireAsync(key, expiry);\n    return await tranc.ExecuteAsync();\n&#125;</code></pre></p>\n","text":" Redis是什么、特点、优势redis是Key-Value数据库,数据包含各种数据 字符串String、字典Hash、列表List、集合Set、有序集合SortedSet等redis支持数据持久化，重启再次加载,支持数据备份(支持分布式),Redis是单进程单线程的Redis的...","link":"","photos":[],"count_time":{"symbolsCount":"6k","symbolsTime":"5 mins."},"categories":[{"name":"IT笔记","slug":"IT笔记","count":21,"path":"api/categories/IT笔记.json"}],"tags":[{"name":"redis","slug":"redis","count":2,"path":"api/tags/redis.json"}],"toc":"","author":{"name":"Fly","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个在夏天会被芒果砸到的城市靠写代码为生的前职业电竞选手","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"游戏全局通知红点系统","uid":"c3f4727b2c3a19f39df59e9531fb513f","slug":"游戏全局通知红点系统","date":"2019-08-23T09:44:00.000Z","updated":"2021-11-30T09:00:43.135Z","comments":true,"path":"api/articles/游戏全局通知红点系统.json","keywords":"node.js blogs IT 互联网 服务端 游戏 mysql redis","cover":[],"text":"红点功能贯穿游戏所有功能，像是一个全局的通知，用一个配置表记录所有游戏功能及入口和红点、开启的方法名加载进内存主入口界面时候调用取得已开启的功能列表mod_function:get_all_game_function() 构造成带父子关系的功能列表 &#123;Id,[&#123...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"设计方法","slug":"设计方法","count":5,"path":"api/categories/设计方法.json"}],"tags":[{"name":"游戏","slug":"游戏","count":8,"path":"api/tags/游戏.json"}],"author":{"name":"Fly","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个在夏天会被芒果砸到的城市靠写代码为生的前职业电竞选手","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"游戏中大型自动比赛玩法设计","uid":"64fa7148428d7d977cb2502b7dbd3115","slug":"游戏中大型比赛玩法设计思路","date":"2019-07-30T08:08:45.000Z","updated":"2021-11-30T09:00:52.167Z","comments":true,"path":"api/articles/游戏中大型比赛玩法设计思路.json","keywords":"node.js blogs IT 互联网 服务端 游戏 mysql redis","cover":[],"text":"争霸赛赛程范例3月1日 0：00~3月3日 12:00 报名 40级以上手动报名3月3日 13：00 淘汰赛 “13:00取数据，提前1小时向玩家发送邮件提醒13:10开始出战报，每隔5分钟出1场战报天榜负5局进入地榜，地榜负5局则被淘汰”3月4日 14:00 16强赛（32进1...","link":"","photos":[],"count_time":{"symbolsCount":"18k","symbolsTime":"17 mins."},"categories":[{"name":"设计方法","slug":"设计方法","count":5,"path":"api/categories/设计方法.json"}],"tags":[{"name":"游戏","slug":"游戏","count":8,"path":"api/tags/游戏.json"}],"author":{"name":"Fly","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个在夏天会被芒果砸到的城市靠写代码为生的前职业电竞选手","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}