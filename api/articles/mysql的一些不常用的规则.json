{"title":"Mysql的一些不常用的规则","uid":"6607396c684bdaf6e6783930fc77d6ef","slug":"mysql的一些不常用的规则","date":"2021-11-24T08:59:23.000Z","updated":"2021-11-30T09:05:00.544Z","comments":true,"path":"api/articles/mysql的一些不常用的规则.json","keywords":"node.js blogs IT 互联网 服务端 游戏 mysql redis","cover":null,"content":"<p>mysql的全文索引主要用在用户搜索查询，达人秀中应用是用来匹配作品内容及标题全文搜索</p>\n<p>传统的匹配方式是like “%xxx%”但这样效率是很低的，在mysql 5.7版本之后提供了inodb的全文索引方式，用的是分词的形式</p>\n<p>达人秀中用户主要用的是中文查找内容，但是在标题和内容中存在网页html  css等标签及无关的标点符号会影响搜索的速度，同时mysql全文索引只支持 char varchar text三种数据类型</p>\n<p>那么当出现较多文字的同时就需要缩减文字精炼存储，在用专门的字段存储查询</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ALTER TABLE &#96;works&#96; ADD COLUMN &#96;search_content&#96; text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT &#39;&#39; COMMENT &#39;搜索文本&#39; AFTER &#96;rich_content&#96;;\nALTER TABLE &#96;works&#96; add fulltext index &#96;title_search_content&#96; (&#96;title&#96;, &#96;search_content&#96;) WITH PARSER ngram;</code></pre>\n<p>先给对应的表结构加上字段及全文索引，包含标题及内容，采用分词的形式</p>\n<p>在作品添加及更新的时候用正则表达式匹配字符串中文精炼字符串长度保证text的长度能放下，同时过滤只存在中文去掉其他</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">public getSearchContent(content:string, rich_content:string)  &#123;\n        let str &#x3D; matchChinses(content) + matchChinses(rich_content);\n        if(str.length &gt; 16382)&#123;&#x2F;&#x2F;中文按4个字节来算\n            return str.slice(0,16382);\n        &#125;\n        return str;\n    &#125;\n\n&#x2F;**\n * 正则匹配中文\n *&#x2F;\n export function matchChinses(content: string): any &#123;\n    if (content !&#x3D;&#x3D; null &amp;&amp; content !&#x3D;&#x3D; &#39;&#39;) &#123;\n        const reg &#x3D; &#x2F;[\\u4e00-\\u9fa5]&#x2F;g;\n        return content.match(reg).join(&#39;&#39;);\n    &#125;\n    return &#39;&#39;;\n&#125;</code></pre>\n<p>这样就能保证存储数据准确性又不太影响搜索的准确性及时效性</p>\n<p>对于之前发布的作品采用脚本的形式一次性做匹配更新操作，定到凌晨3点跑一次做同步，避免死循环加上超时机制</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">public async syncUpdateSearchContent(): Promise&lt;any&gt; &#123;\n        setTimeout(async () &#x3D;&gt;&#123;\n            let page &#x3D; 1;\n            while(1)&#123;\n                if(await this.worksService.updateSearchContent(page))&#123;\n                    page++;\n                &#125;else&#123;\n                    break;\n                &#125;\n            &#125;\n            return \n        &#125;, 60*5);\n    &#125;\n\npublic async updateSearchContent(page:number) &#123;\n        let repo &#x3D; WorksRepository.getInstance();\n        let ids &#x3D; await repo.getNeedSearchContent(page);&#x2F;&#x2F;取数据\n        if(!ids || !ids.length) return false;\n        let data &#x3D; await repo.getIdsWorksData(ids);\n        for(let i &#x3D; 0; i &lt; data.length; i++)&#123;\n            let worksData:Works &#x3D; data[i];\n            worksData.search_content &#x3D; this.getSearchContent(worksData.content,worksData.rich_content);\n            let editor &#x3D; this.getEditor(worksData);\n            await this.setCharacter(worksData, editor);\n        &#125;\n        return true;\n    &#125;</code></pre>\n<p>如果是mysql 8.0以上版本可以用REGEXP_REPLACE的方法直接在sql中匹配替换更新</p>\n<ol start=\"2\">\n<li>有些不常被使用的mysql语法</li>\n<li>1.union 和 union all、 Intersect 这些sql语法主要用在当我们需要查询多表数据同时需要使用多表不同字段数据的时候用这个语句避免多次连接数据库查询<br>如：<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">SELECT ANY_VALUE(t.works_id) AS works_id, ANY_VALUE(SUM(t.score)) AS score FROM (SELECT ANY_VALUE(works_id) AS works_id, ANY_VALUE(SUM(click_num)) AS score FROM view_click WHERE works_id &#x3D; ? AND create_time &lt;&#x3D; ? GROUP BY works_id \n        UNION ALL SELECT ANY_VALUE(works_id) AS works_id, ANY_VALUE(COUNT(id) * 30) AS score FROM log_first_like WHERE works_id &#x3D; ? AND create_time &lt;&#x3D; ? GROUP BY works_id </code></pre>\n同时union 与 union all的区别在与 当连接查询的表有同样字段的时候union all中对两个结果集进行并集操作，包括重复行，不进行排序， union则会对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序， Intersect：对两个结果集进行交集操作，不包括重复行，同时进行默认规则的排序</li>\n</ol>\n<p>2.2.视图View 视图就是SELECT语句执行后返回的结果集，比如当我们需要用新表的替换旧表，但需要重旧表中获取数据，可以用视图 view，将两个结果集合并视图，在查询视图，但是视图肯定不会那么高效的，所以尽量少用<br>如：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">CREATE VIEW view_click\nAS \nSELECT * FROM click UNION ALL SELECT * FROM log_click</code></pre>\n<p>后续当我要按时间查找新旧表数据的时候就可以直接select * from view_click where … 查找视图来查找新旧数据</p>\n<p>2.3.ON DUPLICATE KEY UPDATE 这个是专门使用在插入语句中，在并发的情况的下有可能会导致业务数据判断错误，引起插入语句违反数据库限制，如主键唯一  或者 唯一索引限制引起报错，但实际上索要做的是更新对应业务数据的值就可以使用ON DUPLICATE KEY UPDATE在插入语句中去替换因为限制条件下的数据，需要注意的限制条件在插入语句中要去掉，如id做主键就需要在更新后面去掉id，唯一索引也是同理<br>如：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">INSERT INTO table (a,b,c) VALUES (1,2,3)  ON DUPLICATE KEY UPDATE c&#x3D;c+1;  a为主键，b为唯一索引那么update语句中就不要带这两个字段</code></pre>\n<p>但是这个语法容易导致死锁所以使用上要格外小心</p>\n","feature":true,"text":"mysql的全文索引主要用在用户搜索查询，达人秀中应用是用来匹配作品内容及标题全文搜索 传统的匹配方式是like “%xxx%”但这样效率是很低的，在mysql 5.7版本之后提供了inodb的全文索引方式，用的是分词的形式 达人秀中用户主要用的是中文查找内容，但是在标题和内容中...","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"IT笔记","slug":"IT笔记","count":21,"path":"api/categories/IT笔记.json"}],"tags":[{"name":"mysql","slug":"mysql","count":3,"path":"api/tags/mysql.json"}],"toc":"","author":{"name":"Fly","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个在夏天会被芒果砸到的城市靠写代码为生的前职业电竞选手","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"文章名","uid":"dff573c37ee274635402fd33e69bcfcf","slug":"文章名","date":"2021-12-09T11:34:30.000Z","updated":"2021-12-09T11:34:30.369Z","comments":true,"path":"api/articles/文章名.json","keywords":"node.js blogs IT 互联网 服务端 游戏 mysql redis","cover":null,"text":"","link":"","photos":[],"count_time":{"symbolsCount":0,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"Fly","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个在夏天会被芒果砸到的城市靠写代码为生的前职业电竞选手","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"游戏成就任务系统设计","uid":"a327ba097d8097f094e2ffa26497e116","slug":"游戏成就任务系统设计","date":"2020-06-29T01:07:21.000Z","updated":"2021-11-30T09:07:18.828Z","comments":true,"path":"api/articles/游戏成就任务系统设计.json","keywords":"node.js blogs IT 互联网 服务端 游戏 mysql redis","cover":null,"text":"游戏中的成就任务一般是伴随着玩家操作，及一些游戏次数记录所以可以用一个监听如node里面的 var EventEmitter &#x3D; require(&#39;events&#39;).EventEmitter; var life &#x3D; new EventEmitt...","link":"","photos":[],"count_time":{"symbolsCount":907,"symbolsTime":"1 mins."},"categories":[{"name":"设计方法","slug":"设计方法","count":5,"path":"api/categories/设计方法.json"}],"tags":[{"name":"游戏","slug":"游戏","count":8,"path":"api/tags/游戏.json"}],"author":{"name":"Fly","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个在夏天会被芒果砸到的城市靠写代码为生的前职业电竞选手","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}