{"title":"算法","uid":"7b15f460606fcb4d23e6a93344af8c37","slug":"算法","date":"2021-06-23T07:06:23.000Z","updated":"2021-11-30T08:59:49.772Z","comments":true,"path":"api/articles/算法.json","keywords":"node.js blogs IT 互联网 服务端 游戏 mysql redis","cover":null,"content":"<p>最常用的几种算法<br>1.快速排序<br>快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">function quickSort(arr, left, right) &#123;\n    var len &#x3D; arr.length,\n        partitionIndex,\n        left &#x3D; typeof left !&#x3D; &#39;number&#39; ? 0 : left,\n        right &#x3D; typeof right !&#x3D; &#39;number&#39; ? len - 1 : right;\n\n    if (left &lt; right) &#123;\n        partitionIndex &#x3D; partition(arr, left, right);\n        quickSort(arr, left, partitionIndex-1);\n        quickSort(arr, partitionIndex+1, right);\n    &#125;\n    return arr;\n&#125;\n\nfunction partition(arr, left ,right) &#123;     &#x2F;&#x2F; 分区操作\n    var pivot &#x3D; left,                      &#x2F;&#x2F; 设定基准值（pivot）\n        index &#x3D; pivot + 1;\n    for (var i &#x3D; index; i &lt;&#x3D; right; i++) &#123;\n        if (arr[i] &lt; arr[pivot]) &#123;\n            swap(arr, i, index);\n            index++;\n        &#125;        \n    &#125;\n    swap(arr, pivot, index - 1);\n    return index-1;\n&#125;\n\nfunction swap(arr, i, j) &#123;\n    var temp &#x3D; arr[i];\n    arr[i] &#x3D; arr[j];\n    arr[j] &#x3D; temp;\n&#125;\nfunction partition2(arr, low, high) &#123;\n  let pivot &#x3D; arr[low];\n  while (low &lt; high) &#123;\n    while (low &lt; high &amp;&amp; arr[high] &gt; pivot) &#123;\n      --high;\n    &#125;\n    arr[low] &#x3D; arr[high];\n    while (low &lt; high &amp;&amp; arr[low] &lt;&#x3D; pivot) &#123;\n      ++low;\n    &#125;\n    arr[high] &#x3D; arr[low];\n  &#125;\n  arr[low] &#x3D; pivot;\n  return low;\n&#125;\n\nfunction quickSort2(arr, low, high) &#123;\n  if (low &lt; high) &#123;\n    let pivot &#x3D; partition2(arr, low, high);\n    quickSort2(arr, low, pivot - 1);\n    quickSort2(arr, pivot + 1, high);\n  &#125;\n  return arr;\n&#125;</code></pre>\n<span id=\"more\"></span>\n\n<p>2.冒泡排序<br>O(n²)</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">function bubbleSort(arr) &#123;\n    var len &#x3D; arr.length;\n    for (var i &#x3D; 0; i &lt; len - 1; i++) &#123;\n        for (var j &#x3D; 0; j &lt; len - 1 - i; j++) &#123;\n            if (arr[j] &gt; arr[j+1]) &#123;        &#x2F;&#x2F; 相邻元素两两对比\n                var temp &#x3D; arr[j+1];        &#x2F;&#x2F; 元素交换\n                arr[j+1] &#x3D; arr[j];\n                arr[j] &#x3D; temp;\n            &#125;\n        &#125;\n    &#125;\n    return arr;\n&#125;</code></pre>\n\n<p>3.归并排序<br>O(nlogn) 的时间复杂度。代价是需要额外的内存空间。<br>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</p>\n<p>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</p>\n<p>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</p>\n<p>重复步骤 3 直到某一指针达到序列尾；</p>\n<p>将另一序列剩下的所有元素直接复制到合并序列尾。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">function mergeSort(arr) &#123;  &#x2F;&#x2F; 采用自上而下的递归方法\n    var len &#x3D; arr.length;\n    if(len &lt; 2) &#123;\n        return arr;\n    &#125;\n    var middle &#x3D; Math.floor(len &#x2F; 2),\n        left &#x3D; arr.slice(0, middle),\n        right &#x3D; arr.slice(middle);\n    return merge(mergeSort(left), mergeSort(right));\n&#125;\n\nfunction merge(left, right)\n&#123;\n    var result &#x3D; [];\n\n    while (left.length &amp;&amp; right.length) &#123;\n        if (left[0] &lt;&#x3D; right[0]) &#123;\n            result.push(left.shift());\n        &#125; else &#123;\n            result.push(right.shift());\n        &#125;\n    &#125;\n\n    while (left.length)\n        result.push(left.shift());\n\n    while (right.length)\n        result.push(right.shift());\n\n    return result;\n&#125;</code></pre>\n\n<p>4.选择排序<br>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</p>\n<p>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p>\n<p>重复第二步，直到所有元素均排序完毕。<br>无论什么数据进去都是 O(n²) 的时间复杂度</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">function selectionSort(arr) &#123;\n    var len &#x3D; arr.length;\n    var minIndex, temp;\n    for (var i &#x3D; 0; i &lt; len - 1; i++) &#123;\n        minIndex &#x3D; i;\n        for (var j &#x3D; i + 1; j &lt; len; j++) &#123;\n            if (arr[j] &lt; arr[minIndex]) &#123;     &#x2F;&#x2F; 寻找最小的数\n                minIndex &#x3D; j;                 &#x2F;&#x2F; 将最小数的索引保存\n            &#125;\n        &#125;\n        temp &#x3D; arr[i];\n        arr[i] &#x3D; arr[minIndex];\n        arr[minIndex] &#x3D; temp;\n    &#125;\n    return arr;\n&#125;</code></pre>\n\n<p>5.插入排序<br>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</p>\n<p>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）<br>O(N^(1-2))</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">function insertionSort(arr) &#123;\n    var len &#x3D; arr.length;\n    var preIndex, current;\n    for (var i &#x3D; 1; i &lt; len; i++) &#123;\n        preIndex &#x3D; i - 1;\n        current &#x3D; arr[i];\n        while(preIndex &gt;&#x3D; 0 &amp;&amp; arr[preIndex] &gt; current) &#123;\n            arr[preIndex+1] &#x3D; arr[preIndex];\n            preIndex--;\n        &#125;\n        arr[preIndex+1] &#x3D; current;\n    &#125;\n    return arr;\n&#125;</code></pre>\n\n<p>6.桶排序<br>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p>\n<p>在额外空间充足的情况下，尽量增大桶的数量<br>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中<br>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。</p>\n<ol>\n<li><p>什么时候最快<br>当输入的数据可以均匀的分配到每一个桶中。O(n)</p>\n</li>\n<li><p>什么时候最慢<br>当输入的数据被分配到了同一个桶中。时间复杂度为O(nlogn)</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">function bucketSort(arr, bucketSize) &#123;\n    if (arr.length &#x3D;&#x3D;&#x3D; 0) &#123;\n      return arr;\n    &#125;\n\n    var i;\n    var minValue &#x3D; arr[0];\n    var maxValue &#x3D; arr[0];\n    for (i &#x3D; 1; i &lt; arr.length; i++) &#123;\n      if (arr[i] &lt; minValue) &#123;\n          minValue &#x3D; arr[i];                &#x2F;&#x2F; 输入数据的最小值\n      &#125; else if (arr[i] &gt; maxValue) &#123;\n          maxValue &#x3D; arr[i];                &#x2F;&#x2F; 输入数据的最大值\n      &#125;\n    &#125;\n\n    &#x2F;&#x2F;桶的初始化\n    var DEFAULT_BUCKET_SIZE &#x3D; 5;            &#x2F;&#x2F; 设置桶的默认数量为5,理论上有多少数有多少桶最快，时间复杂度为O(n)\n    bucketSize &#x3D; bucketSize || DEFAULT_BUCKET_SIZE;\n    var bucketCount &#x3D; Math.floor((maxValue - minValue) &#x2F; bucketSize) + 1;  \n    var buckets &#x3D; new Array(bucketCount);\n    for (i &#x3D; 0; i &lt; buckets.length; i++) &#123;\n        buckets[i] &#x3D; [];\n    &#125;\n\n    &#x2F;&#x2F;利用映射函数将数据分配到各个桶中\n    for (i &#x3D; 0; i &lt; arr.length; i++) &#123;\n        buckets[Math.floor((arr[i] - minValue) &#x2F; bucketSize)].push(arr[i]);\n    &#125;\n\n    arr.length &#x3D; 0;\n    for (i &#x3D; 0; i &lt; buckets.length; i++) &#123;\n        insertionSort(buckets[i]);                      &#x2F;&#x2F; 对每个桶进行排序，这里使用了插入排序\n        for (var j &#x3D; 0; j &lt; buckets[i].length; j++) &#123;\n            arr.push(buckets[i][j]);                      \n        &#125;\n    &#125;\n\n    return arr;\n&#125;</code></pre></li>\n</ol>\n","text":"最常用的几种算法1.快速排序快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排...","link":"","photos":[],"count_time":{"symbolsCount":"6.2k","symbolsTime":"6 mins."},"categories":[{"name":"IT笔记","slug":"IT笔记","count":21,"path":"api/categories/IT笔记.json"}],"tags":[{"name":"算法","slug":"算法","count":1,"path":"api/tags/算法.json"}],"toc":"","author":{"name":"Fly","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个在夏天会被芒果砸到的城市靠写代码为生的前职业电竞选手","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"加薪秘籍","uid":"2debb017808112f7c6dc95c7509d53b7","slug":"加薪秘籍","date":"2021-07-01T06:58:40.000Z","updated":"2021-11-30T08:59:44.258Z","comments":true,"path":"api/articles/加薪秘籍.json","keywords":"node.js blogs IT 互联网 服务端 游戏 mysql redis","cover":[],"text":"题目：从 innodb 的索引结构分析，为什么索引的 key 长度不能太长？key 太长会导致一个页当中能够存放的 key 的数目变少，间接导致索引树的页数目变多，索引层次增加，从而影响整体查询变更的效率。 题目：请解释下为什么鹿晗发布恋情的时候，微博系统会崩溃，如何解决？A. ...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"IT笔记","slug":"IT笔记","count":21,"path":"api/categories/IT笔记.json"}],"tags":[{"name":"面试","slug":"面试","count":1,"path":"api/tags/面试.json"}],"author":{"name":"Fly","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个在夏天会被芒果砸到的城市靠写代码为生的前职业电竞选手","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"微信Baidu审核对接方案实现","uid":"9d448e38833c6c56c1bb282d7671bf10","slug":"微信baidu审核对接方案实现","date":"2021-05-10T10:03:17.000Z","updated":"2021-11-30T08:59:56.618Z","comments":true,"path":"api/articles/微信baidu审核对接方案实现.json","keywords":"node.js blogs IT 互联网 服务端 游戏 mysql redis","cover":null,"text":"微信和百度都有文字及图片视频啥的AI审核接口，文字审核这里就不说了，时间短也比较快，唯一缺点是测试版每秒的并发最多5个，在并发的情况下会出现未审核，有钱的可以升级付费版，没钱的可以在比较空闲的进程中对未审核的作品和评论，进行2次审核，起一个定时器半小时或者1小时来做 下面着重说下...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"IT笔记","slug":"IT笔记","count":21,"path":"api/categories/IT笔记.json"}],"tags":[{"name":"node.js","slug":"node-js","count":7,"path":"api/tags/node-js.json"}],"author":{"name":"Fly","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一个在夏天会被芒果砸到的城市靠写代码为生的前职业电竞选手","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}