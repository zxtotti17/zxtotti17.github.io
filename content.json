{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://zxtotti17.github.io","root":"/"},"pages":[{"title":"Archives","date":"2017-09-20T12:49:56.000Z","updated":"2019-11-27T15:26:48.000Z","comments":false,"path":"archives/index.html","permalink":"http://zxtotti17.github.io/archives/index.html","excerpt":"","text":""},{"title":"About-me","date":"2018-10-03T02:48:33.000Z","updated":"2019-11-27T15:26:48.000Z","comments":true,"path":"about-me/index.html","permalink":"http://zxtotti17.github.io/about-me/index.html","excerpt":"","text":"一句话 Just do it ! (翻译：我只是个搞 IT的！哭笑脸) 关于我 一个莫名其妙的，喜欢敲代码，喜欢研究技术的，表面上高冷、不苟言笑的， 偶尔又嬉皮笑脸，偶尔又特立独行的，双重性格的技术爱好者！ 兴趣方向 游戏。 联系我 Email: 574215066@qq.com"},{"title":"Categories","date":"2018-09-20T12:49:56.000Z","updated":"2019-11-27T15:26:48.000Z","comments":false,"path":"categories/index.html","permalink":"http://zxtotti17.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-07-03T09:44:08.000Z","updated":"2019-11-27T15:26:48.000Z","comments":true,"path":"tags/index.html","permalink":"http://zxtotti17.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"游戏中写出的bug及思考","slug":"游戏中写出的bug及思考","date":"2020-06-16T01:48:20.000Z","updated":"2020-06-16T02:17:18.141Z","comments":true,"path":"2020/06/16/游戏中写出的bug及思考/","link":"","permalink":"http://zxtotti17.github.io/2020/06/16/%E6%B8%B8%E6%88%8F%E4%B8%AD%E5%86%99%E5%87%BA%E7%9A%84bug%E5%8F%8A%E6%80%9D%E8%80%83/","excerpt":"","text":"1.写出的功能一定要兼容旧版本及新版本，因为更新的不及时会导致可能有部分用户是在用旧版 2.node版本要用双数的正式版本，单数有个问题在时区的双数上会出现很大的问题 3.进程间通信的逻辑一定要注意，进程间的内存是单独的，所以如果没有公共存储最好不要操作内存","categories":[],"tags":[]},{"title":"Es6 js规范","slug":"js规范","date":"2020-06-09T09:59:15.000Z","updated":"2020-06-16T02:17:59.783Z","comments":true,"path":"2020/06/09/js规范/","link":"","permalink":"http://zxtotti17.github.io/2020/06/09/js%E8%A7%84%E8%8C%83/","excerpt":"","text":"数组拷贝const itemsCopy = […items]; 取值方式const [first, second] = arr; 函数初始化function f3(a) { const b = a || 1; // …} function f4(a = 1) { // …} 输出数组const x = [1, 2, 3, 4, 5];console.log(…x); new Date(…[2016, 8, 5]); 数组遍历let sum = 0;numbers.forEach((num) =&gt; { sum += num;});sum === 15;","categories":[],"tags":[]},{"title":"基础知识","slug":"基础知识","date":"2020-05-22T06:42:58.000Z","updated":"2020-06-11T02:45:48.376Z","comments":true,"path":"2020/05/22/基础知识/","link":"","permalink":"http://zxtotti17.github.io/2020/05/22/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"异步：异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。 基本功能 进程管理进程控制、进程同步、进程通信、死锁处理、处理机调度等。 内存管理内存分配、地址映射、内存保护与共享、虚拟内存等。 文件管理文件存储空间的管理、目录管理、文件读写管理和保护等。 设备管理完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。 主要包括缓冲管理、设备分配、设备处理、虛拟设备等。 ps查看某个时间点的进程信息。 示例：查看自己的进程 ps -l示例：查看系统所有进程 ps aux示例：查看特定的进程 ps aux | grep threadx pstree查看进程树。 示例：查看所有进程树 pstree -A top实时显示进程信息。 示例：两秒钟刷新一次 top -d 2 netstat查看占用端口的进程 示例：查看特定端口的进程 netstat -anp | grep port#计算机网络物理层、数据链路层、网络层、传输层、应用层物理层：单工通信：单向传输半双工通信：双向交替传输全双工通信：双向同时传输 数据链路层：模拟信号转换成数字信号，封装成帧等特点 网络层：IP协议 传输层：TCP/UDP协议 应用层：HTTP协议 长连接与短连接的理解：之所以网络上说HTTP分为长连接和短连接，其实本质上是说的TCP连接。TCP连接是一个双向dao的通道，它是可以保持一段时间不关闭的，因此TCP连接才有真正的长连接和短连接这一说。HTTP协议说到底是应用层的协议，而TCP才是真正的传输层协议，只有负责传输的这一层才需要建立连接。因此“HTTP连接”这一概念压根就不应该出现，HTTP只是一个应用层的协议，根本就没有连接这一说法，就像FTP协议一样，我们从来不会说“FTP连接”吧。归根到底，其实说的连接都是只传输层的TCP连接。相反说HTTP请求和HTTP响应反而更加准确一些都是通过TCP连接这个数据通道来传输请求和响应的。说到这里就彻底的改变了之前的错误认识，以后记住长连接，短连接都是指的传输层的TCP连接，而不是应用层的HTTP协议。HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠的传递数据包，使在网络上的另一端收到发端发出的所有包，并且顺序与发出顺序一致。TCP有可靠，面向连接的特点。现在的疑问既然说到了长连接，那么什么是长连接，短连接呢？HTTP1.1中又是如何实现长连接的呢？那么长短连接又分别有什么优缺点呢？正如我们学习一个新知识的时候，总是会问自己这三个问题一样：XXX是什么？XXX怎么用？XXX的好处？像我们一般的普通web应用，csdn写博客的平台，这种采用长连接有什么用呢？1，如何理解HTTP协议是无状态的HTTP协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。2，什么是长连接、短连接？在HTTP/1.0中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的 Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。但从 HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码：Connection:keep-alive 服务器和客户端都要设置在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接。HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。3，TCP连接当网络通信时采用TCP协议时，在真正的读写操作之前，server与client之间必须建立一个连接，当读写操作完成后，双方不再需要这个连接 时它们可以释放这个连接，连接的建立是需要三次握手的，而释放则需要4次握手，所以说每个连接的建立都是需要资源消耗和时间消耗的。经典的三次握手示意图：经典的四次分手关闭图：4，TCP短连接我们模拟一下TCP短连接的情况，client向server发起连接请求，server接到请求，然后双方建立连接。client向server发送消息，server回应client，然后一次读写就完成了，这时候双方任何一个都可以发起close操作，不过一般都是client先发起close操作。为什么呢，一般的server不会回复完client后立即关闭连接的，当然不排除有特殊的情况。从上面的描述看，短连接一般只会在client/server间传递一次读写操作。短连接的操作步骤是：建立连接——数据传输——关闭连接…建立连接——数据传输——关闭连接5，TCP长连接接下来我们再模拟一下长连接的情况，client向server发起连接，server接受client连接，双方建立连接。Client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。比如你请求了csdn的一个网页，这个网页里肯定还包含了CSS、JS等等一系列资源，如果你是短连接（也就是每次都要重新建立TCP连接）的话，那你每打开一个网页，基本要建立几个甚至几十个TCP连接，但如果是长连接的话，那么这么多次HTTP请求（这些请求包括请求网页内容，CSS文件，JS文件，图片等等），其实使用的都是一个TCP连接，很显然是可以节省很多消耗的。另外，最后关于长连接还要多提一句，那就是，长连接并不是永久连接的。如果一段时间内（具体的时间长短，是可以在header当中进行设置的，也就是所谓的超时时间），这个连接没有HTTP请求发出的话，那么这个长连接就会被断掉。这一点其实很容易理解，否则的话，TCP连接将会越来越多，直到把服务器的TCP连接数量撑爆到上限为止。现在想想，对于服务器来说，服务器里的这些个长连接其实很有数据库连接池的味道，大家都是为了节省连接重复利用嘛，对不对？长连接的操作步骤是：建立连接——数据传输…（保持连接）…数据传输——关闭连接","categories":[],"tags":[]},{"title":"游戏运营活动框架思路","slug":"游戏运营活动框架思路","date":"2019-11-22T08:15:07.000Z","updated":"2019-11-27T15:26:48.000Z","comments":true,"path":"2019/11/22/游戏运营活动框架思路/","link":"","permalink":"http://zxtotti17.github.io/2019/11/22/%E6%B8%B8%E6%88%8F%E8%BF%90%E8%90%A5%E6%B4%BB%E5%8A%A8%E6%A1%86%E6%9E%B6%E6%80%9D%E8%B7%AF/","excerpt":"游戏的运营活动一般会有好多种类型，但是这些类型的功能一般是有共同和非共同的部分，这里记录一个对多类型运营活动的管理框架通过模板表录入运营活动的参数，包括跳转模块，开启方法，红点方法，等级等。如果有类似活动结束发奖的奖励表也可以用表来记录不同活动operation_id对应的奖励进行管理。1.初始化玩家排行 12345678910111213141516171819202122232425262728293031323334init_sky_bless_rank() -&gt; List = [PlayerSkyBless || PlayerSkyBless &lt;- get_all_player_st_sky_bless(), PlayerSkyBless #player_st_sky_bless.bless_times &gt; 0], SortFunction = fun(A,B) -&gt; if A #player_st_sky_bless.bless_times =:= B #player_st_sky_bless.bless_times -&gt; A #player_st_sky_bless.last_time =&lt; B #player_st_sky_bless.last_time; true -&gt; A #player_st_sky_bless.bless_times &gt; B #player_st_sky_bless.bless_times end end, SortList = lists:sort(SortFunction,List), Num = length(SortList), Tran = fun() -&gt; if Num &gt; 0 -&gt; lists:foreach( fun(Seq) -&gt; PlayerSkyBless = lists:nth(Seq,SortList), lib_ets:insert(sky_bless_player_ranking,#sky_lantern_bless_player_ranking&#123; player_id = PlayerSkyBless #player_st_sky_bless.player_id,ranking = Seq&#125;,replace), BlessRanking = #sky_lantern_bless_ranking&#123; ranking = Seq, player_id = PlayerSkyBless #player_st_sky_bless.player_id, times = PlayerSkyBless #player_st_sky_bless.bless_times, bless_time = PlayerSkyBless #player_st_sky_bless.last_time &#125;, lib_ets:insert(sky_bless_ranking,BlessRanking,replace) end, lists:seq(1,Num) ); true -&gt; noop end end, game_db:do(Tran).","text":"游戏的运营活动一般会有好多种类型，但是这些类型的功能一般是有共同和非共同的部分，这里记录一个对多类型运营活动的管理框架通过模板表录入运营活动的参数，包括跳转模块，开启方法，红点方法，等级等。如果有类似活动结束发奖的奖励表也可以用表来记录不同活动operation_id对应的奖励进行管理。1.初始化玩家排行 12345678910111213141516171819202122232425262728293031323334init_sky_bless_rank() -&gt; List = [PlayerSkyBless || PlayerSkyBless &lt;- get_all_player_st_sky_bless(), PlayerSkyBless #player_st_sky_bless.bless_times &gt; 0], SortFunction = fun(A,B) -&gt; if A #player_st_sky_bless.bless_times =:= B #player_st_sky_bless.bless_times -&gt; A #player_st_sky_bless.last_time =&lt; B #player_st_sky_bless.last_time; true -&gt; A #player_st_sky_bless.bless_times &gt; B #player_st_sky_bless.bless_times end end, SortList = lists:sort(SortFunction,List), Num = length(SortList), Tran = fun() -&gt; if Num &gt; 0 -&gt; lists:foreach( fun(Seq) -&gt; PlayerSkyBless = lists:nth(Seq,SortList), lib_ets:insert(sky_bless_player_ranking,#sky_lantern_bless_player_ranking&#123; player_id = PlayerSkyBless #player_st_sky_bless.player_id,ranking = Seq&#125;,replace), BlessRanking = #sky_lantern_bless_ranking&#123; ranking = Seq, player_id = PlayerSkyBless #player_st_sky_bless.player_id, times = PlayerSkyBless #player_st_sky_bless.bless_times, bless_time = PlayerSkyBless #player_st_sky_bless.last_time &#125;, lib_ets:insert(sky_bless_ranking,BlessRanking,replace) end, lists:seq(1,Num) ); true -&gt; noop end end, game_db:do(Tran). 2.处理玩家排行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455deal_update_player_ranking(PlayerId) -&gt; PlayerSkyBless = get_player_st_sky_bless(PlayerId), BlessTimes = PlayerSkyBless #player_st_sky_bless.bless_times, BlessTime = PlayerSkyBless #player_st_sky_bless.last_time, NowRanking = get_sky_bless_player_ranking(PlayerId), Tran = fun() -&gt; if NowRanking == 0 -&gt; Len = length(get_all_sky_bless_ranking()), NewRanking = #sky_lantern_bless_ranking&#123; ranking = Len + 1, player_id = PlayerId, times = BlessTimes, bless_time = BlessTime &#125;, lib_ets:insert(sky_bless_ranking,NewRanking,replace), lib_ets:insert(sky_bless_player_ranking,#sky_lantern_bless_player_ranking&#123; player_id = PlayerId,ranking = Len + 1&#125;,replace), ranking_sort(PlayerId,BlessTimes,BlessTime,Len); true -&gt; lib_ets:update(sky_bless_ranking,NowRanking,[&#123;#sky_lantern_bless_ranking.times,BlessTimes&#125;, &#123;#sky_lantern_bless_ranking.bless_time,BlessTime&#125;]), ranking_sort(PlayerId,BlessTimes,BlessTime,NowRanking - 1) end end, game_db:do(Tran).ranking_sort(_,_,_,0) -&gt; noop;ranking_sort(PlayerId,BlessTimes,Time,Ranking) -&gt; BlessRanking = get_sky_bless_ranking(Ranking), case sort(BlessTimes,Time,BlessRanking #sky_lantern_bless_ranking.times,BlessRanking #sky_lantern_bless_ranking.bless_time) of true -&gt; NewRanking = #sky_lantern_bless_ranking&#123; ranking = Ranking, player_id = PlayerId, times = BlessTimes, bless_time = Time &#125;, ARanking = #sky_lantern_bless_ranking&#123; ranking = Ranking + 1, player_id = BlessRanking #sky_lantern_bless_ranking.player_id, times = BlessRanking #sky_lantern_bless_ranking.times, bless_time = BlessRanking #sky_lantern_bless_ranking.bless_time &#125;, lib_ets:insert(sky_bless_player_ranking,#sky_lantern_bless_player_ranking&#123; player_id = BlessRanking #sky_lantern_bless_ranking.player_id,ranking = Ranking + 1&#125;,replace), lib_ets:insert(sky_bless_player_ranking,#sky_lantern_bless_player_ranking&#123; player_id = PlayerId,ranking = Ranking&#125;,replace), lib_ets:insert(sky_bless_ranking,NewRanking,replace), lib_ets:insert(sky_bless_ranking,ARanking,replace), ranking_sort(PlayerId,BlessTimes,Time,Ranking - 1); false -&gt; noop end. 3.通过公共管理进程对活动进行管理发奖及消息通知 12345678handle_cast(&#123;async_send&#125;, &#123;true,State&#125;) -&gt; catch api_st_sky_bless:timer_notify(State), start_timer(1), &#123;noreply, &#123;true,[]&#125;&#125;;handle_cast(&#123;activity_stop&#125;,State) -&gt; mod_st_sky_bless:give_award(), &#123;noreply,State&#125;;","categories":[],"tags":[{"name":"游戏","slug":"游戏","permalink":"http://zxtotti17.github.io/tags/%E6%B8%B8%E6%88%8F/"}]},{"title":"游戏全局通知红点系统","slug":"游戏全局通知红点系统","date":"2019-08-23T09:44:00.000Z","updated":"2019-11-27T15:26:48.000Z","comments":true,"path":"2019/08/23/游戏全局通知红点系统/","link":"","permalink":"http://zxtotti17.github.io/2019/08/23/%E6%B8%B8%E6%88%8F%E5%85%A8%E5%B1%80%E9%80%9A%E7%9F%A5%E7%BA%A2%E7%82%B9%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"红点功能贯穿游戏所有功能，像是一个全局的通知，用一个配置表记录所有游戏功能及入口和红点、开启的方法名加载进内存主入口界面时候调用取得已开启的功能列表mod_function:get_all_game_function() 构造成带父子关系的功能列表 123&#123;Id,[&#123;GameFunction #game_function.id&#125;|List1]&#125;|lists:delete(&#123;Id,List1&#125;,L) 通过核心回调到所有模块的红点方法 123456789101112IsRed = if Mod =/= '', Func =/= '' -&gt; try erlang:apply(Mod,Func,[PlayerId]) of Result -&gt; Result catch _ : _ -&gt; false end; true -&gt; falseend, 最后将缓存中的玩家红点数据替换 123456789lib_ets:delete(player_red, PlayerId), lib_ets:insert( player_red, #player_red&#123; player_id = PlayerId, red_list = N &#125;, replace ), 不同的功能触发红点改变需要有个打点的函数,在功能需要改变红点状态的时候通知进来更新缓存 123456789101112131415161718192021222324252627notify_game_function_is_red (PlayerId,FunctionId) -&gt; case mod_function:check_lock(PlayerId,FunctionId) of false -&gt; noop; _ -&gt; GameFunction = code_db:get(game_function,[FunctionId]), Mod = list_to_atom(GameFunction #game_function.red_mod), Func = list_to_atom(GameFunction #game_function.red_func), IsRed = if Mod =/= '', Func =/= '' -&gt; try erlang:apply(Mod,Func,[PlayerId]) of Result -&gt; Result catch _ : _ -&gt; false end; true -&gt; false end, if GameFunction #game_function.relation &gt; 0 -&gt; notify_relation_game_function_is_red(PlayerId,GameFunction #game_function.relation,FunctionId,IsRed);%通知父类联动的函数 true -&gt; update_game_function_cache(PlayerId,FunctionId,IsRed) end end.","categories":[],"tags":[{"name":"游戏","slug":"游戏","permalink":"http://zxtotti17.github.io/tags/%E6%B8%B8%E6%88%8F/"}]},{"title":"游戏中大型自动比赛玩法设计","slug":"游戏中大型比赛玩法设计思路","date":"2019-07-30T08:08:45.000Z","updated":"2019-11-27T15:26:48.000Z","comments":true,"path":"2019/07/30/游戏中大型比赛玩法设计思路/","link":"","permalink":"http://zxtotti17.github.io/2019/07/30/%E6%B8%B8%E6%88%8F%E4%B8%AD%E5%A4%A7%E5%9E%8B%E6%AF%94%E8%B5%9B%E7%8E%A9%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/","excerpt":"争霸赛赛程范例3月1日 0：00~3月3日 12:00 报名 40级以上手动报名3月3日 13：00 淘汰赛 “13:00取数据，提前1小时向玩家发送邮件提醒13:10开始出战报，每隔5分钟出1场战报天榜负5局进入地榜，地榜负5局则被淘汰”3月4日 14:00 16强赛（32进16） “每小时1局，每局取1次数据，5局3胜制天地榜同时进行比赛开始前1小时向玩家发送邮件提醒取数据制度”3月5日 14:00 16进83月6日 14:00 8进43月7日 14:00 半决赛3月8日 14:00 决赛3月8日 决赛全部结束 统一发放奖励 比赛的时间控制由单独时间进程来控制时间的推进，相当于php中的crontab,表结构上一个玩家比赛进程表player_race,一个各阶段玩家成员信息表player_race_member，后期系统匹配各阶段玩家匹配信息表player_race_opponent，一个各阶段玩家战报信息表player_race_report，一个各阶段玩家结果表player_race_result，玩家表可以分为 玩家比赛信息表 player_st_jjc_race 玩家匹配信息表 player_st_jjc_race_opponent 玩家日志表 player_st_jjc_race_score_log 第一步 报名很简单直接报名请求记录玩家数据就行,报名时间结束时触发事件对所有玩家进行匹配 123456789101112131415161718192021222324252627282930313233343536373839404142434445case try_get_player_server_war(PlayerId) of null -&gt; Tran = fun() -&gt; game_db:write(#player_server_war &#123; player_id = PlayerId, apply_time = lib_misc:get_local_timestamp() &#125;) % mod_deploy:get(PlayerId, ?RACE_SERVER_WAR) end, game_db:do(Tran); _ -&gt; exit(already_apply)end.% 本服报名结束手机玩家数据apply_over() -&gt; List = get_all_player_server_war(), Tran = fun() -&gt; lists:foreach( fun(Rec) -&gt; game_db:write(Rec #player_server_war &#123; race_step = ?RS_TIAN_BANG_TAOTAI &#125;) end, List ) end, game_db:do(Tran), ?INFO(\"apply_over\",[]), ZoneList = lists:foldl( fun(PlayerServerWar, R) -&gt; [PlayerServerWar #player_server_war.player_id | R] end, [], get_all_player_server_war() ), mod_race:init_race_member( ?RACE_SERVER_WAR, 0, ?RS_TIAN_BANG_TAOTAI, 0, ZoneList, normal ). 注意的是用一个单独的进程来管理活动步骤开启结束","text":"争霸赛赛程范例3月1日 0：00~3月3日 12:00 报名 40级以上手动报名3月3日 13：00 淘汰赛 “13:00取数据，提前1小时向玩家发送邮件提醒13:10开始出战报，每隔5分钟出1场战报天榜负5局进入地榜，地榜负5局则被淘汰”3月4日 14:00 16强赛（32进16） “每小时1局，每局取1次数据，5局3胜制天地榜同时进行比赛开始前1小时向玩家发送邮件提醒取数据制度”3月5日 14:00 16进83月6日 14:00 8进43月7日 14:00 半决赛3月8日 14:00 决赛3月8日 决赛全部结束 统一发放奖励 比赛的时间控制由单独时间进程来控制时间的推进，相当于php中的crontab,表结构上一个玩家比赛进程表player_race,一个各阶段玩家成员信息表player_race_member，后期系统匹配各阶段玩家匹配信息表player_race_opponent，一个各阶段玩家战报信息表player_race_report，一个各阶段玩家结果表player_race_result，玩家表可以分为 玩家比赛信息表 player_st_jjc_race 玩家匹配信息表 player_st_jjc_race_opponent 玩家日志表 player_st_jjc_race_score_log 第一步 报名很简单直接报名请求记录玩家数据就行,报名时间结束时触发事件对所有玩家进行匹配 123456789101112131415161718192021222324252627282930313233343536373839404142434445case try_get_player_server_war(PlayerId) of null -&gt; Tran = fun() -&gt; game_db:write(#player_server_war &#123; player_id = PlayerId, apply_time = lib_misc:get_local_timestamp() &#125;) % mod_deploy:get(PlayerId, ?RACE_SERVER_WAR) end, game_db:do(Tran); _ -&gt; exit(already_apply)end.% 本服报名结束手机玩家数据apply_over() -&gt; List = get_all_player_server_war(), Tran = fun() -&gt; lists:foreach( fun(Rec) -&gt; game_db:write(Rec #player_server_war &#123; race_step = ?RS_TIAN_BANG_TAOTAI &#125;) end, List ) end, game_db:do(Tran), ?INFO(\"apply_over\",[]), ZoneList = lists:foldl( fun(PlayerServerWar, R) -&gt; [PlayerServerWar #player_server_war.player_id | R] end, [], get_all_player_server_war() ), mod_race:init_race_member( ?RACE_SERVER_WAR, 0, ?RS_TIAN_BANG_TAOTAI, 0, ZoneList, normal ). 注意的是用一个单独的进程来管理活动步骤开启结束 1234567891011121314151617181920212223242526272829% 每一个活动开始所要做的处理activity_start (ActivityId) -&gt; case mod_server:is_game_server() of true -&gt; xdh_race_srv:activity_start(ActivityId); false -&gt; case mod_server:is_cc_server() of true -&gt; % cc_server_war_cron_srv:activity_start(Id); noop; false -&gt; noop end end.% 每一个活动结束所要做的处理activity_stop (ActivityId) -&gt; case mod_server:is_game_server() of true -&gt; xdh_race_srv:activity_stop(ActivityId); false -&gt; case mod_server:is_cc_server() of true -&gt; % cc_server_war_cron_srv:activity_stop(Id); noop; false -&gt; noop end end. 在到点时间的相应上做特殊处理 第二步 开启淘汰赛淘汰赛的开启同样用时间进程来控制，到点后调用启动方法 （判断结束 、清上一轮数据）淘汰赛相当于一个递归的过程，全服玩家进行了一场比赛后记录玩家信息及淘汰结果直到淘汰赛结束的条件,同时需要一个全服步骤数据记录，然后循环比赛其中每一轮淘汰赛可分为 判断结束 、清上一轮数据 、不重复随机匹配 、 战斗及数据记录 、 循环 （不重复随机匹配 循环） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!-- 战斗部分及记录 --&gt;race_fight (RaceId, ZoneId, RaceStep, TeamIdA, TeamIdB) -&gt; #player_race &#123; race_times = RaceTimes &#125; = get_player_race(RaceId, ZoneId), Tran = fun() -&gt; case race_call(RaceId, fight, [RaceStep, TeamIdA, TeamIdB]) of [] -&gt; exit(&#123;invalid_fight, RaceId, TeamIdA, TeamIdB&#125;); ReportList -&gt; &#123;_, WinTeamId&#125; = lists:foldr( fun(Report, &#123;NowIndex, NowWinTeamId&#125;) -&gt; #war_result &#123; winner = &#123;_, WinnerId&#125;, army_result1 = #army_result &#123; army_key = &#123;_, PlayerIdA&#125; &#125;, army_result2 = #army_result &#123; army_key = &#123;_, PlayerIdB&#125; &#125; &#125; = Report, NewWinTeamId = if NowIndex =:= length(ReportList) -&gt; WinTeamId = if WinnerId =:= PlayerIdA -&gt; TeamIdA; true -&gt; TeamIdB end, game_db:write(#player_race_result &#123; race_id = RaceId, zone_id = ZoneId, race_step = RaceStep, player_id = TeamIdA, player_id1 = TeamIdB, race_times = RaceTimes, version = ?GET_ENV(vsn, \"\"), report_time = lib_misc:get_local_timestamp(), winner_id = WinTeamId &#125;), WinTeamId; true -&gt; NowWinTeamId end, game_db:write(#player_race_report &#123; race_id = RaceId, zone_id = ZoneId, race_step = RaceStep, player_id = TeamIdA, race_times = RaceTimes, index = NowIndex, attacker_id = PlayerIdA, defender_id = PlayerIdB, winner_id = WinnerId, report_id = war_report_srv:record_war_report(Report, 30 * 86400) &#125;), &#123; NowIndex - 1, NewWinTeamId &#125; end, &#123;length(ReportList), 0&#125;, ReportList ), WinTeamId end end, &#123;atomic, TeamId&#125; = game_db:do(Tran), TeamId. 在淘汰赛结束后，将剩余晋级玩家进入晋级赛步骤，同时初始化随机匹配一下两种匹配方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354init_race_member(RaceId, ZoneId, RaceStep, Group, TeamIdList, normal) -&gt; Tran = fun() -&gt; lists:foldl( fun(TeamId, NowIndex) -&gt; game_db:write(#player_race_member &#123; race_id = RaceId, race_step = RaceStep, zone_id = ZoneId, group = Group, index = NowIndex, player_id = TeamId &#125;), NowIndex + 1 end, 1, TeamIdList ) end, game_db:do(Tran);init_race_member(RaceId, ZoneId, RaceStep, Group, TeamIdList, random) -&gt; #race_step &#123; match_num = MatchNum &#125; = get_race_step(RaceStep), Step = get_index_step(length(TeamIdList), MatchNum), Tran = fun() -&gt; lists:foldl( fun(TeamId, NowIndex) -&gt; game_db:write(#player_race_member &#123; race_id = RaceId, race_step = RaceStep, zone_id = ZoneId, group = Group, index = NowIndex, player_id = TeamId &#125;), if NowIndex + Step &gt; MatchNum * 2 -&gt; 1 + Step div 2; true -&gt; NowIndex + Step end end, 1, lib_misc:shuffle(TeamIdList) ) end, game_db:do(Tran); 第三步 战报战报开启也是进程时间来控制 第四步 开启晋级赛同样是进程计时器开启，比赛流程除了一局定输赢以外和淘汰赛基本一致，比赛也是一次性打完，战报根据时间慢慢的播放 1234567891011121314151617181920212223242526272829303132% 开启杯赛timer_start_race() -&gt; case mod_server:is_cc_server() of true -&gt; % cc_server_war_cron_srv:start_race(0); noop; false -&gt; Times = mod_server:get_player_server_int_data(?SDT_SERVER_WAR_RACE_TIMES), xdh_race_srv:try_apply(mod_server,set_player_server_int_data,[?SDT_SERVER_WAR_RACE_TIMES,Times + 1]), start_race(), mod_timer:reset(1, ?TIMER_XIAN_DAO_HUI_BEI_SAI) end. start_race() -&gt; RaceStep = get_server_war_race_step(), PlayerRace = mod_race:get_player_race(?RACE_SERVER_WAR,0), IsOver = case mod_race:start_race(?RACE_SERVER_WAR, 0, RaceStep, 3) of true -&gt; true; _ -&gt; mod_timer:reset(0, ?TIMER_XIAN_DAO_HUI_BEI_SAI, 3420), false end, RaceTimes = if RaceStep =/= PlayerRace #player_race.race_step -&gt; 1; true -&gt; PlayerRace #player_race.race_times + 1 end, xdh_race_srv:try_apply(mod_server,set_player_server_int_data,[?SDT_SERVER_WAR_RACE_TIMES,RaceTimes]), deal_receive_beisai_data(RaceStep,IsOver). 战斗部分基本一致多一个匹配结果记录表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142start_race(RaceId, ZoneId, RaceStep, WinTimes) -&gt; #race_step &#123; match_num = MatchNum, next_race = NextRace, next_step = NextStep &#125; = get_race_step(RaceStep), Tran = fun() -&gt; PlayerRace = get_player_race(RaceId, ZoneId), if PlayerRace #player_race.race_step =:= RaceStep, PlayerRace #player_race.race_times =/= 0 -&gt; case check_race_over(RaceId, ZoneId, RaceStep) of true -&gt; exit(race_over); _ -&gt; noop end, game_db:write(PlayerRace #player_race &#123; race_times = PlayerRace #player_race.race_times + 1, last_time = lib_misc:get_local_timestamp() &#125;); true -&gt; clear_race_data(RaceId, ZoneId, RaceStep), init_race_opponent(RaceId, ZoneId, RaceStep), game_db:write(PlayerRace #player_race &#123; race_step = RaceStep, race_times = 1, last_time = lib_misc:get_local_timestamp(), win_times = WinTimes &#125;) end, lists:foreach( fun(Group) -&gt; lists:foreach( fun(Index) -&gt; RaceMemberA = try_get_player_race_member(RaceId, ZoneId, RaceStep, Group, Index * 2 - 1), RaceMemberB = try_get_player_race_member(RaceId, ZoneId, RaceStep, Group, Index * 2), if RaceMemberA =:= null, RaceMemberB =:= null -&gt; noop; %%轮空为全空或者B为空 % RaceMemberA =:= null -&gt; % game_db:write(#player_race_member &#123; % race_id = RaceId, % race_step = NextRace, % group = Group, % index = Index, % player_id = RaceMemberB #player_race_member.player_id % &#125;); RaceMemberB =:= null -&gt; TeamIdA = RaceMemberA #player_race_member.player_id, case check_opponent_over(RaceId, ZoneId, RaceStep, TeamIdA) of true -&gt; noop; _ -&gt; Opponent = try_get_player_race_opponent(RaceId, ZoneId, RaceStep, TeamIdA), game_db:write(Opponent #player_race_opponent &#123; winner_id = TeamIdA &#125;), game_db:write(#player_race_member &#123; race_id = RaceId, zone_id = ZoneId, race_step = NextRace, group = Group, index = Index, player_id = TeamIdA &#125;), race_call(RaceId, race_win, [TeamIdA, Group, RaceStep, NextRace]) end; true -&gt; TeamIdA = RaceMemberA #player_race_member.player_id, TeamIdB = RaceMemberB #player_race_member.player_id, case check_opponent_over(RaceId, ZoneId, RaceStep, TeamIdA) of true -&gt; noop; _ -&gt; case race_fight(RaceId, ZoneId, RaceStep, TeamIdA, TeamIdB) of 0 -&gt; noop; WinnerId -&gt; case check_opponent_over(RaceId, ZoneId, RaceStep, TeamIdA, TeamIdB) of true -&gt; Opponent = try_get_player_race_opponent(RaceId, ZoneId, RaceStep, TeamIdA), game_db:write(Opponent #player_race_opponent &#123; winner_id = WinnerId &#125;), game_db:write(#player_race_member &#123; race_id = RaceId, zone_id = ZoneId, race_step = NextRace, group = Group, index = Index, player_id = WinnerId &#125;), race_call(RaceId, race_win, [WinnerId, Group, RaceStep, NextRace]); _ -&gt; noop end end end end end, lists:seq(1, MatchNum) ) end, get_all_race_group() ), IsOver = check_race_over(RaceId, ZoneId, RaceStep), if IsOver =:= true -&gt; NowPlayerRace = get_player_race(RaceId, ZoneId), game_db:write(NowPlayerRace #player_race &#123; race_step = NextStep, race_times = 0, last_time = lib_misc:get_local_timestamp() &#125;); true -&gt; noop end, IsOver end, &#123;atomic, Result&#125; = game_db:do(Tran), Result. 第五步 出晋级赛战报 1234567891011121314151617181920212223242526272829303132333435363738% 播报战报及通知deal_receive_beisai_data(RaceStep,IsOver) -&gt; Tran = fun() -&gt; % write_race_data(RaceReportList,RaceResultList,MemberList,OpponentList, WorldWarList), if IsOver =:= true -&gt; #race_step &#123; next_step = NextStep &#125; = mod_race:get_race_step(RaceStep), % return_bet(RaceStep), if RaceStep =:= ?RS_RACE_1 -&gt; % give_award(),给予奖励 ZoneId = 0, case mod_race:try_get_player_race_member(?RACE_SERVER_WAR, ZoneId, ?RS_RACE_1_OVER, ?RG_TIAN_BANG, 1) of null -&gt; noop; Member -&gt; ServerId = mod_player:get_player_data(Member #player_race_member.player_id,server_id), ServerName = mod_server:get_server_name(ServerId), NickName = mod_player:get_player_data(Member #player_race_member.player_id,nickname), api_chat:centre_screen_message_notify( ?MEST_XIAN_DAO_HUI_GUAN_JUN, [&#123;ServerName&#125;,&#123;NickName&#125;] ) end; true -&gt; noop end, mod_server:set_player_server_int_data(?SDT_SERVER_WAR_RACE_STEP, NextStep), mod_server:set_player_server_int_data(?SDT_SERVER_WAR_RACE_TIMES, 0), mod_timer:close(1,?TIMER_XIAN_DAO_HUI_BEI_SAI); true -&gt; noop end end, game_db:do(Tran). % api_server_war:notify_new_report().","categories":[],"tags":[{"name":"游戏","slug":"游戏","permalink":"http://zxtotti17.github.io/tags/%E6%B8%B8%E6%88%8F/"}]},{"title":"Erlang List模块函数使用大全","slug":"Erlang List模块函数使用大全","date":"2019-05-07T11:49:16.000Z","updated":"2019-11-27T15:26:48.000Z","comments":true,"path":"2019/05/07/Erlang List模块函数使用大全/","link":"","permalink":"http://zxtotti17.github.io/2019/05/07/Erlang%20List%E6%A8%A1%E5%9D%97%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E5%A4%A7%E5%85%A8/","excerpt":"Erlang List模块函数使用大全 一，带函数Pred1, all(Pred, List) -&gt; boolean()如果List中的每个元素作为Pred函数的参数执行，结果都返回true，那么all函数返回true，否则返回false 例子： lists:all(fun(E) -&gt; true end,[1,2,3,4]). 结果 true 2, any(Pred, List) -&gt; boolean()如果List中至少有一个元素作为Pred函数的参数执行，结果返回true，那么any函数返回true，否则返回false 例子 lists:any(fun(E) -&gt; is_integer(E) end,[q,2,a,4]). 结果 true 3，dropwhile(Pred, List1) -&gt; List2将List1列表中的元素作为参数执行Pred函数，如果返回true，将其丢弃，最后返回剩余元素组成的列表 例子 lists:dropwhile(fun(E) -&gt; is_atom(E) end,[a,1,2,a,b]). 结果 [1,2,a,b] 4，filter(Pred, List1) -&gt; List2返回一个列表，这个列表是由List1中执行Pred函数返回true的元素组成。 lists:filter(fun(E) -&gt; is_integer(E) end,[q,2,a,4]). 结果： [2,4]","text":"Erlang List模块函数使用大全 一，带函数Pred1, all(Pred, List) -&gt; boolean()如果List中的每个元素作为Pred函数的参数执行，结果都返回true，那么all函数返回true，否则返回false 例子： lists:all(fun(E) -&gt; true end,[1,2,3,4]). 结果 true 2, any(Pred, List) -&gt; boolean()如果List中至少有一个元素作为Pred函数的参数执行，结果返回true，那么any函数返回true，否则返回false 例子 lists:any(fun(E) -&gt; is_integer(E) end,[q,2,a,4]). 结果 true 3，dropwhile(Pred, List1) -&gt; List2将List1列表中的元素作为参数执行Pred函数，如果返回true，将其丢弃，最后返回剩余元素组成的列表 例子 lists:dropwhile(fun(E) -&gt; is_atom(E) end,[a,1,2,a,b]). 结果 [1,2,a,b] 4，filter(Pred, List1) -&gt; List2返回一个列表，这个列表是由List1中执行Pred函数返回true的元素组成。 lists:filter(fun(E) -&gt; is_integer(E) end,[q,2,a,4]). 结果： [2,4] 5，map(Fun, List1) -&gt; List2将List1中的每个元素去在Fun中执行，然后返回一个元素，最后返回的这些元素组成一个列表，返回给List2例子：lists:map(fun(X)-&gt;[X,X] end, [a,b,c]).结果：[[a,a],[b,b],[c,c]] 6，flatmap(Fun, List1) -&gt; List2这个函数和map比较类似，相当于执行了lists:append(lists:map(List1)).也就是把map的结果进行append处理例子：lists:flatmap(fun(X)-&gt;[X,X] end, [a,b,c]).结果：[a,a,b,b,c,c] 7，foldl(Fun, Acc0, List) -&gt; Acc1Fun这个函数有两个参数第一个参数是List中的元素，第二个参数是Fun函数执行完后的返回值，这个参数第一次执行时就是Acc0例子：对[1,2,3,4,5]求和lists:foldl(fun(X, Sum) -&gt; X + Sum end, 0, [1,2,3,4,5]).结果：15执行过程：首先，Fun第一次执行时，X的值取列表List的第一个元素1，Sum取0, Fun第二次执行时，X的值取列表List的第二个元素2，Sum取Fun第一次的返回值 依次轮推，直到List中每个元素执行完，最后foldl返回最后一次的结果。 8，foldr(Fun, Acc0, List) -&gt; Acc1foldr这个函数和foldl比较相似不过是Fun执行时，X的值先取List的最后一个，然后取倒数第二个。 9，foreach(Fun, List) -&gt; ok以List中的每个元素为参数执行Fun函数，执行顺序按照List中元素的顺序，这个函数最后返回ok。是单边的例子 lists:foreach(fun(X)-&gt; %%using X to do somethings %% end,List) 10，keymap(Fun, N, TupleList1) -&gt; TupleList2对TupleList1中的每个元素的第N项作为参数在Fun中处理，然后这个第N项最后就被替换为Fun执行完返回的值例子：List1 = [{name,”zhangjing”},{name,”zhangsan”}].lists:keymap(fun(X)-&gt; list_to_atom(X) end,2,List1).结果：[{name,zhangjing},{name,zhangsan}] 11，mapfoldl(Fun, Acc0, List1) -&gt; {List2, Acc1}这个函数等于是把map和foldl函数结合起来。将List1中的每一个元素执行Fun函数，执行后花括号的第一个值作为返回值返回，第二个值作为参数传给Fun，作为下一次用。例子：lists:mapfoldl(fun(X, Sum) -&gt; {2*X, X+Sum} end,0, [1,2,3,4,5]).{[2,4,6,8,10],15} 12，mapfoldr(Fun, Acc0, List1) -&gt; {List2, Acc1}这个函数相当于将map和foldr结合起来 13，merge(Fun, List1, List2) -&gt; List3这个函数的功能也是把List1和List2合并到一起，只不过是List1和List2的元素要作为参数在Fun中执行，如果Fun返回true，那么返回值就是List1在前，List2在后。否则，反之。例子lists:merge(fun(A,B)-&gt; false end, [3,4],[2,1]).结果[2,1,3,4] 14，partition(Pred, List) -&gt; {Satisfying, NotSatisfying}这个函数的功能是将List分成两个List1和List2，List1是将List元素作为参数去Pred函数中执行返回true的元素组成，List2由Pred返回false的元素组成。注意，返回的是一个元组例子lists:partition(fun(A) -&gt; A rem 2 == 1 end, [1,2,3,4,5,6,7]).结果{[1,3,5,7],[2,4,6]} 15，sort(Fun, List1) -&gt; List2如果Fun函数返回true，则排序是从小到大的顺序，否则，从大到小。其中Fun有两个参数。例子lists:sort(fun(A,B)-&gt; false end,[1,2,3]).结果[3,2,1] 16，splitwith(Pred, List) -&gt; {List1, List2}将List分成List1和List2，List1由List中元素在Pred函数返回true的组成，但是有一点，如果遇到为false的，则将剩下的元素全部放到List2中，List1中就只有前面为true的。例子lists:splitwith(fun(A) -&gt; is_atom(A) end, [a,b,1,c,d,2,3,4,e]).结果{[a,b],[1,c,d,2,3,4,e]} 17，takewhile(Pred, List1) -&gt; List2List1中的元素element依次执行Pred(element),如果返回true，则获取这个元素，直到有元素执行Pred(element)返回false例子lists:takewhile(fun(E)-&gt; is_atom(E) end,[a,b,1,e,{c},[d]]).结果[a,b] 18,umerge(Fun, List1, List2) -&gt; List3这个函数和merge不同的是 当Fun返回true时，返回的List3中不能出现相同的元素疑问：但是当Fun返回false时，List3中可以有相同的元素。例子(Fun返回true的情况)lists:umerge(fun(A,B)-&gt; true end,[1,2],[2,3]).结果[1,2,3](Fun为false的情况)lists:umerge(fun(A,B)-&gt; false end,[1,2],[2,3]).[2,3,1,2]好神奇，竟然2有重复 19，usort(Fun, List1) -&gt; List2按照Fun函数进行排序，如果Fun返回true，那么只返回List1的第一个元素如果Fun返回false，那么List1从大到小排序例子1lists:usort(fun(A,B) -&gt; true end, [1,2,2,3,4]).结果[1] 例子2lists:usort(fun(A,B) -&gt; false end, [1,2,2,3,4]).结果[4,3,2,2,1] 20，zipwith(Combine, List1, List2) -&gt; List3将List1和list2中的每个元素执行Combine函数，然后返回一个元素，List3就是由Combine函数返回的一个个元素组成的。功能和map有点像，但是这里是对两个列表的操作。例子lists:zipwith(fun(X, Y) -&gt; X+Y end, [1,2,3], [4,5,6]).结果[5,7,9] 21，zipwith3(Combine, List1, List2, List3) -&gt; List4将List1和list2，list3中的每个元素执行Combine函数，然后返回一个元素，List4就是由Combine函数返回的一个个元素组成的。功能和map有点像，但是这里是对三个列表的操作。例子lists:zipwith3(fun(X, Y, Z) -&gt; X+Y+Z end, [1,2,3], [4,5,6],[7,8,9]).结果[12,15,18] 二，不带函数Pred1，append(ListOfLists) -&gt; List1ListOfLists都是由List组成的，而List一个列表，里面可以是任何类型的元素这个函数就是将ListOfLists里面的所有列表的元素按顺序编成一个列表提示：ListOfLists里面的元素必须都是列表才能用这个函数 例子 lists:append([[1, 2, 3], [a, b], [4, 5, 6]]). 结果： [1,2,3,a,b,4,5,6] 2，append(List1, List2) -&gt; List3将List1和List2两个列表连接起来，组成一个列表，然后返回新的这个列表这个函数的功能等同于List1 ++ List2 例子 lists:append(“abc”, “def”). 结果 “abcdef” 3，concat(Things) -&gt; string()这里的Things是一个列表，里面由atom() | integer() | float() | string()将这个列表里面的元素拼成一个字符串，然后返回 例子 lists:concat([doc, ‘/‘, file, ‘.’, 3]). 结果 doc/file.3” 4，delete(Elem, List1) -&gt; List2List1是由很多Element组成的，这个函数的功能是在List1中寻找第一个和Elem元素一样的，然后删除之，返回删除后新的列表。 例子 lists:delete({name,”zhangsan”},[{name,”lisi”},{name,”zhangsan”},{name,”wangmazi”})). 结果 [{name,”lisi”},{name,”wangmazi”}] 5，duplicate(N, Elem) -&gt; List返回一个由N个Elem组成的列表。 例子 lists:duplicate(5,”test”). 结果 [“test”,”test”,”test”,”test”,”test”] 6，flatlength(DeepList) -&gt; integer() &gt;= 0我的理解是DeepList就是列表里面套列表计算列表的长度，即用flatten函数将DeepList转化成List后元素的个数这个函数和length()的区别就是：length函数是得到列表元素的个数，而flatlength函数是先将DeepList转化成List后的个数譬如说List = [1,2,[3,4]]这个列表用length(List)求的值是：3lists:flatlength(List)求的值是：4其实lists:flatlength(List) = length(flatten(List)) 7，flatten(DeepList) -&gt; List将DeepList变成只有term()的list例子：lists:flatten([[a,a],[b,b],[c,c]]).结果：[a,a,b,b,c,c] 8，flatten(DeepList, Tail) -&gt; List就是将DeepList变成只有term的List后，在后面再加一个Tail。例子：lists:flatten([[a,a],[b,b],[c,c]],[dd]).结果：[a,a,b,b,c,c,dd] 9,keydelete(Key, N, TupleList1) -&gt; TupleList2这个函数适合处理列表里面的元素是元组的情况删除TupleList1中元素第N个元素和Key一致的元素，只删除第一个一样的，后面一样的不删除例子：List = [{name,”zhangjing”},{sex,”male”},{name,”zhangsan”},{sex,”male”}],lists:keydelete(“male”,2,List)结果：[{name,”zhangjing”},{name,”zhangsan”},{sex,”male”}] 10,keyfind(Key, N, TupleList) -&gt; Tuple | false查找TupleList中的一个Tuple，如果查找到，返回，如果没有查找到，则返回false这个Tuple必须满足第N个元素和key是一样。例子：List1 = [{name,”zhangjing”},{name,”zhangsan”}].lists:keyfind(“zhangjing”,2,List1)结果：{name,”zhangjing”} 11，keymember(Key, N, TupleList) -&gt; boolean()如果TupleList中的元素中存在第N个元素和key一致，则返回true，否则返回false例子：List1 = [{name,”zhangjing”},{name,”zhangsan”}].lists:keymember(“zhangjing”,2,List1).结果：true 12，keymerge(N, TupleList1, TupleList2) -&gt; TupleList3将TupleList1和TupleList2进行混合，组成一个TupleList，新组成的TupleList是按照Tuple的第N个元素进行排序的例子：List1 = [{name,”zhangjing”},{name,”zhangsan”}].List2 = [{nick,”zj”},{nick,”zs”}].lists:keymerge(2,List1,List2).结果：[{name,”zhangjing”}, {name,”zhangsan”}, {nick,”zj”}, {nick,”zs”}] 13，keyreplace(Key, N, TupleList1, NewTuple) -&gt; TupleList2在TupleList1的Tuple中找出第N个元素和Key一致，然后用NewTuple将这个Tuple替换掉，如果没有找到，则返回原来的TupleList1例子：List1 = [{name,”zhangjing”},{name,”zhangsan”}]lists:keyreplace(“zhangjing”,2,List1,{nickname,”netzj”}).结果：[{nickname,”netzj”},{name,”zhangsan”}] 14，keysearch(Key, N, TupleList) -&gt; {value, Tuple} | false这个函数和keyfind差不多，就是返回值的结构不一样也是在TupleList中找一个Tuple，这个Tuple的第N个元素和Key一样。例子：List1 = [{name,”zhangjing”},{name,”zhangsan”}]lists:keysearch(“zhangjing”,2,List1).结果：{value,{name,”zhangjing”}} 15，keysort(N, TupleList1) -&gt; TupleList2对TupleList1中的Tuple按照第N个元素进行排序，然后返回一个新的顺序的TupleList。不过这种排序是固定的。例子：List1 = [{name,”zhangsan”},{name,”zhangjing”}].lists:keysort(2,List1).结果：[{name,”zhangjing”},{name,”zhangsan”}] 16，keystore(Key, N, TupleList1, NewTuple) -&gt; TupleList2这个函数和keyreplace函数比较像，不同的是，这个keystore在没有找到对应的Tuple时，会将这个NewTuple追加在这个TupleList1的最后。例子：List1 = [{name,”zhangsan”},{name,”zhangjing”}].找到了的情况lists:keystore(“zhangjing”,2,List1,{name,”netzhangjing”}).[{name,”netzhangjing”},{name,”zhangsan”}]没有找到的情况lists:keystore(“zhanging”,2,List1,{name,”netzhangjing”}).[{name,”zhangjing”},{name,”zhangsan”},{name,”netzhangjing”}] 17，keytake(Key, N, TupleList1) -&gt; {value, Tuple, TupleList2} | false在TupleList1中找Tuple，这个Tuple的第N个元素和Key一致，如果找到了这么一个Tuple那么返回，{value, Tuple, TupleList2} 其中TupleList2是去掉Tuple的TupleList1.例子：List1 = [{name,”zhangjing”},{name,”zhangsan”},{name,”lisi”}].lists:keytake(“zhangjing”,2,List1).结果：{value,{name,”zhangjing”},[{name,”zhangsan”},{name,”lisi”}]} 18，last(List) -&gt; Last返回：List最后一个元素例子：List1 = [{name,”zhangjing”},{name,”zhangsan”},{name,”lisi”}].lists:last(List1).结果：{name,”lisi”} 19，max(List) -&gt; Max取出List中最大的元素，一般List是整型时比较适合。例子：lists:max([1,10,15,6]).结果：15 20，member(Elem, List) -&gt; boolean()如果Elem和List中的某个元素匹配（相同），那么返回true，否则返回false例子lists:member({sex,”1”},[{sex,”1”},{sex,”2”},{sex,”3”}]).结果：true 21，merge(ListOfLists) -&gt; List1ListOfLists是一个列表，里面由子列表构成这个函数的功能就是将这些子列表合并成一个列表。例子：lists:merge([[{11}],[{22}],[{33}]]).结果[{11},{22},{33}] 22，merge(List1, List2) -&gt; List3List1和List2分别是一个列表，这个函数的功能是将这两个列表合并成一个列表。例子：lists:merge([11],[22]).结果[11,22][2,1,3,4] 23, merge3(List1, List2, List3) -&gt; List4将List1，List2，List3合并成一个列表例子lists:merge3([11],[22],[33,44]).结果：[11,22,33,44] 24，min(List) -&gt; Min返回List中的最小的元素，和max函数对应例子lists:min([1,2,3]).结果1 25，nth(N, List) -&gt; Elem返回List中的第N个元素。例子lists:nth(2,[{name,”zhangsan”},{name,”lisi”},{name,”wangmazi”}]).结果{name,”lisi”} 26，nthtail(N, List) -&gt; Tail返回List列表中第N个元素后面的元素例子lists:nthtail(3, [a, b, c, d, e]).结果[d,e] 27，prefix(List1, List2) -&gt; boolean()如果List1是List2的前缀(也就是说List1和List2前部分相同)，那么返回true，否则返回false 28，reverse(List1) -&gt; List2将List1反转例子lists:reverse([1,2,3,4]).结果[4,3,2,1] 29,reverse(List1, Tail) -&gt; List2将List1反转，然后将Tail接在反转List1的后面，然后返回例子lists:reverse([1, 2, 3, 4], [a, b, c]).[4,3,2,1,a,b,c] 30，seq(From, To) -&gt; Seq其中From和To都是整型，这个函数返回一个从From到To的一个整型列表。例子lists:seq(1,10).结果[1,2,3,4,5,6,7,8,9,10] 31，seq(From, To, Incr) -&gt; Seq返回一个整型列表，这个列表的后一个元素比前一个元素大Incr。例子lists:seq(1,10,4).[1,5,9] 32，sort(List1) -&gt; List2将List1中的元素从小到大排序，然后返回新的一个列表。例子lists:sort([3,2,1]).结果[1,2,3] 33，split(N, List1) -&gt; {List2, List3}将List1分成List2和List3其中List2包括List1的前N个元素，List3包含剩余的。例子lists:split(3,[1,2,3,4,5]).结果{[1,2,3],[4,5]} 这个函数和partition数有区别，partition是遍历全部的List，而splitwith在遍历时遇到false的情况则马上结束遍历，返回结果。 34，sublist(List1, Len) -&gt; List2返回从第一个元素到第Len个元素的列表，这个Len大于List1的长度时，返回全部。例子lists:sublist([1,2,3,4,5,6],3).结果[1,2,3] 35，sublist(List1, Start, Len) -&gt; List2返回从List1的第Start个位置开始，后面Len个元素的列表。例子lists:sublist([1,2,3,4], 2, 2).结果[2,3] 36，subtract(List1, List2) -&gt; List3等同于 List1 – List2这个函数功能是返回一个List1的副本，对于List2中的每个元素，第一次在List1副本中出现时被删掉。例子lists:subtract(“112233”,”12”).结果“1233” 37，suffix(List1, List2) -&gt; boolean()如果List1是List2的后缀，那么返回true，否则返回false例子lists:suffix(“22”,”1122”).结果true 38，sum(List) -&gt; number()返回List中每个元素的和。其中List中的元素都应该是number()类型的。例子lists:sum([1,2,3,4]).结果10 39，ukeymerge(N, TupleList1, TupleList2) -&gt; TupleList3TupleList1和TupleList2里面的元素都是元组将TupleList1和TupleList2合并，合并的规则是按照元组的第N个元素，如果第N个元素有相同的，那么保留TupleList1中的，删除TupleList2中的。 40，ukeysort(N, TupleList1) -&gt; TupleList2TupleList1里面的元素都是元组这个函数也同样返回一个元素是元组的列表，返回的这个列表是按照元组的第N个元素来排序的，如果元组中有出现第N个元素相同的情况，删除掉后面的一个元组。例子lists:ukeysort(1,[{name,”zhangsan”},{sex,”male”},{name,”himan”}]).结果[{name,”zhangsan”},{sex,”male”}] 41，umerge(ListOfLists) -&gt; List1这个函数和merge唯一不同的就是，里面不能出现相同的元素，如果出现相同的，那么删除之，只保留一个唯一的例子lists:umerge([[1,2],[2,3]]).结果[1,2,3]分析：由于[[1,2],[2,3]]中merge后是[1,2,2,3],这个时候有两个相同的元素2，所以只保存一个2，所以结果是[1,2,3]. 42，umerge3(List1, List2, List3) -&gt; List4将List1, List2, List3合并和merge3不同的是返回的List4中不能出现重复的元素例子lists:merge3([1,2],[2,3],[3,4]).结果[1,2,3,4] 43，unzip(List1) -&gt; {List2, List3}List1里面的元素是元组，每个元组由两个元素组成，返回值List2包含每个List1中每个元组的第一个元素返回值List3包含每个List1中每个元组的第二个元素。例子lists:unzip([{name,”zhangsan”},{sex,”male”},{city,”hangzhou”}]).结果{[name,sex,city],[“zhangsan”,”male”,”hangzhou”]} 44，unzip3(List1) -&gt; {List2, List3, List4}List1里面的元素是元组，每个元组由三个元素组成，返回值List2包含每个List1中每个元组的第一个元素；返回值List3包含每个List1中每个元组的第二个元素；返回值List4包含每个List1中每个元组的第三个元素。例子lists:unzip3([{name,”zhangsan”,”apple”},{sex,”male”,”banana”},{city,”hangzhou”,”orange”}]).结果{[name,sex,city], [“zhangsan”,”male”,”hangzhou”], [“apple”,”banana”,”orange”]}注意，最终返回的是一个元组。 45，usort(List1) -&gt; List2将List1按照从小到大的顺序排序，如果排序后有重复的元素，删除重复的，只保存一个唯一的。例子lists:usort([4,3,2,1,2,3,4]).结果[1,2,3,4] 46，zip(List1, List2) -&gt; List3将两个长度相同的列表合并成一个列表List3是里面的每一个元组的第一个元素是从List1获取的，而每个元组的第二个元素是从List2中获取的例子lists:zip([name,sex,city],[“zhangsan”,”male”,”hangzhou”]).结果[{name,”zhangsan”},{sex,”male”},{city,”hangzhou”}]注意，如果List1和List2长度不一致，那么这个函数将会报错。 47，zip3(List1, List2, List3) -&gt; List4将三个长度相同的列表合并成一个列表List3是里面的每一个元组的第一个元素是从List1获取的，而每个元组的第二个元素是从List2中获取的每个元组的第三个元素是从List3中获取的。例子lists:zip3([name,sex,city],[“zhangsan”,”male”,”hangzhou”],[“nick”,”1”,”zhejiang”]).结果[{name,”zhangsan”,”nick”}, {sex,”male”,”1”}, {city,”hangzhou”,”zhejiang”}]","categories":[],"tags":[{"name":"Erlang","slug":"Erlang","permalink":"http://zxtotti17.github.io/tags/Erlang/"}]},{"title":"Erlang OTP学习","slug":"Erlang-OTP学习","date":"2019-04-09T08:50:32.000Z","updated":"2019-11-27T15:26:48.000Z","comments":true,"path":"2019/04/09/Erlang-OTP学习/","link":"","permalink":"http://zxtotti17.github.io/2019/04/09/Erlang-OTP%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"1.-behaviour(gen_server)它表示让编译器检查，当前module是否实现了gen_server指定的所有回调接口 2.gen_server:start_link(ServerName, Module, Args, Options) -&gt; Result这个方法用来启动一个server，其中：参数ServerName指定了服务名参数Module指定了该server的callback模块参数Args将作为服务初始化的启动参数（服务初始化时会调用：Module:init([Args])）参数Options指定了一些特性参数，通常可以直接使用[] 如果服务启动成功，返回{ok, Pid} 3.Module:init([Args])这个方法会在服务初始化时被回调，参数Args就是gen_server:start_link中倒数第二个参数，若初始化成功，该方法放回{ok, State},其中State将作为启动服务的State 4.gen_server:call(ServerRef, Request)这个方法供callback模块向ServerRef代表的服务发送Request请求（callback模块通常会在之上再封装一层接口供客户端调用，譬如这里的add，find方法），注意该方法是一个同步调用，它会一直等待服务器返回一个响应消息（除非等待超时，默认5s） 5.Module:handle_call(Request, From, State) -&gt; Result这是一个回调方法，用来处理gen_server:call(ServerRef, Request)发出的请求，其中：Request，表示客户端请求From，表示请求来自哪个客户端State，表示当前服务器状态 Result为handle_call 请求处理结果，它有以下几种类型{reply,Reply,NewState}{reply,Reply,NewState,Timeout}{reply,Reply,NewState,hibernate}{noreply,NewState}{noreply,NewState,Timeout}{noreply,NewState,hibernate}{stop,Reason,Reply,NewState} | {stop,Reason,NewState} 这几种返回值有什么区别呢？如果返回的是以reply开头，那么Reply将会作为响应返回给客户端如果返回的是以noreply开头，那么服务器将不会返回任何消息给客户端（这会导致客户端阻塞，因为客户端调用的gen_server:call方法是一个同步调用，当它发出请求后，会一直等待服务器发送响应消息，除非等待超时） 6.gen_server:cast(ServerRef, Request)这个方法同gen_server:call(ServerRef, Request)，但它最大的区别就是该调用是异步的，它不需要等待服务器返回任何处理结果 7.Module:handle_cast(Request, State) -&gt; Result这个方法用来处理gen_server:cast(ServerRef, Request)发出的请求，由于不会返回结果给客户端，所以参数列表中也没有From 8.检查进程是否加载 1erlang:whereis(?MODULE). 9.查看进程的信息 1erlang:process_info(pid(0,PID,0)).","categories":[],"tags":[{"name":"Erlang","slug":"Erlang","permalink":"http://zxtotti17.github.io/tags/Erlang/"}]},{"title":"充值流程","slug":"充值流程","date":"2019-03-06T12:01:38.000Z","updated":"2019-11-27T15:26:48.000Z","comments":true,"path":"2019/03/06/充值流程/","link":"","permalink":"http://zxtotti17.github.io/2019/03/06/%E5%85%85%E5%80%BC%E6%B5%81%E7%A8%8B/","excerpt":"","text":"接触到的充值流程是这样的客户端发起请求-&gt;lcm后台，lcm后台确认充值成功，会将充值的金额变成平台货币保存在平台端，并通知到客户端充值成功，收到充值成功的客户端对游戏服务端发起请求，游戏服务端收到请求后，请求lcm平台调用spend方法，平台确认信息相符就扣币并告诉游戏服务端消费成功，游戏服务端在将平台货币转换为对应的游戏币，同时告诉客户端充值成功 2.平台充值成功可能会产生回调直接通知游戏服务端，服务端接收请求，后请求平台spend，成功后发币记录，客户端请求服务端查到有记录就告知客户端成功不做spend 掉单：如果掉单1.平台回调请求会保证执行spend方法，达到补单的效果2.客户端能读到平台币，直接通过平台剩余币与游戏服务端直接交易 注意：任何时间判断以天为单位要特别小心，如果出现两版批次连续很容易出问题","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-01-01T08:50:32.000Z","updated":"2020-06-24T07:58:16.163Z","comments":true,"path":"2019/01/01/hello-world/","link":"","permalink":"http://zxtotti17.github.io/2019/01/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"c++设计模式","slug":"c-设计模式","date":"2018-12-25T14:38:51.000Z","updated":"2019-11-27T15:26:48.000Z","comments":true,"path":"2018/12/25/c-设计模式/","link":"","permalink":"http://zxtotti17.github.io/2018/12/25/c-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"c++设计模式： 简单工厂模式 工厂模式有一种非常形象的描述，建立对象的类就如一个工厂，而需要被建立的对象就是一个个产品；在工厂中加工产品，使用产品的人，不用在乎产品是如何生产出来的。从软件开发的角度来说，这样就有效的降低了模块之间的耦合。 使用情景： 在不确定会有多少个处理操作时应该考虑使用简单工厂模式，如针对同样的接收到的数据，处理的逻辑可能会不同，可能以后还会增加新的操作。案例：如果实现计算器的功能时，对于同样的输入数据，可能执行加、减、乘、除，甚至其他的功能。因此可以抽象出一个操作的抽象类或是接口，提供一个统一的处理方法(此处为process)，然后每种操作创建出一个子类出来。而判断具体使用哪个具体的实现类是在工厂类中进行判断的(将存放操作的变量传递给工厂的生产方法)。工厂类始终返回的是这个抽象类，这样如果对原有功能进行更改或是新添加新的功能，也不会对原来的其他类做修改，只编译修改的那个类或是新的类就可以了。这样就做到了把耦合降到最低，同时也便于维护。 简单工厂：针对同样的数据，不同的操作用同一个接口 工厂方法：针对同样的数据，不同的操作用不同的接口 抽象工厂：针对不同的数据，不同的操作用不同的接口 策略模式：依赖c++的多态，抽象类的指针可以访问所有子类对象，（纯虚函数），可以用一个指针访问所有策略的实现类 单例模式：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式(不能让一个程序打开两次 如：不能同时打开2个迅雷 迅雷用的单例模式) 访问者模式:适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。访问者模式使得增加新的操作变的很容易，就是增加一个新的访问者类。访问者模式将有关的行为集中到一个访问者对象中(做任何更改不需要修改基类，不依赖虚函数) 观察者模式：定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。(QT的信号机制，Windows的消息机制都应用了观察者模式，还有订阅邮件，邮件到了就会给你发邮件) 建造者模式：使得产品内部表象可以独立地变化，客户不必知道产品内部组成的细节。可以强制实行一种分步骤进行的建造过程。用一个接口完成不同的操作，需要对客户的需求进行把握。(如：登陆QQ，自动选择所在地的服务器) 解释器模式：给定一个语言后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。(如：360读取lua脚本，这个细节的实现就是解释器模式) 命令模式：把发出命令的责任和执行命令的责任分割开，委派给不同的对象允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。(命令模式在客户端与服务器之间用的最多 (C/S架构)) 模板模式：不同的子类可以以不同的方式实现这些抽象方法， 从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架， 而将逻辑的细节留给具体的子类去实现。(适用于本地化，做一个软件，在日本是日文，美国是英语…) 桥接模式：将抽象化与实现化脱离，使得二者可以独立的变化， 也就是指在一个软件系统的抽象化和实现化之间使用组合聚合关系而不是继承关系，从而使两者可以独立的变化。(相当于配电脑去装机，把各个模块组合到一起) 适配器模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。 外观模式：外部与一个子系统的通信必须通过一个统一的外观对象进行。每一个子系统只有一个外观类，而且此外观类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个外观类。(多个子系统方法都需要一个外观类统一管理，用统一的接口方便消费者使用) 享元模式：享元模式大幅度的降低内存中对象的数量，使用享元模式主要是为了优化内存，相同功能可以并行使用。 原型模式：允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。 责任链模式：在责任链模式中，很多对象由每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。(例如：晚上去上英语课，为了好开溜坐到了最后一排，哇，前面坐了好几个漂亮的MM哎，找张纸条，写上“Hi, 可以做我的女朋友吗？如果不愿意请向前传”，纸条就一个接一个的传上去了，糟糕，传到第一排的MM把纸条传给老师了) 中介者模式：中介者模式包装了一系列对象相互作用的方式， 使得这些对象不必相互明显作用。从而使他们可以松散偶合。 当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。（如：TCP/IP打洞技术） 装饰模式：装饰模式以对客户端透明的方式扩展对象的功能是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能。 状态模式：意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。(如：到了晚上12点要睡觉，到了早上8点要起床…这就是状态) 合成模式：将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。(用于树状结构)","categories":[],"tags":[{"name":"c++ 设计模式","slug":"c-设计模式","permalink":"http://zxtotti17.github.io/tags/c-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Mysql笔记","slug":"Mysql笔记","date":"2018-10-31T07:04:42.000Z","updated":"2020-06-21T08:14:59.952Z","comments":true,"path":"2018/10/31/Mysql笔记/","link":"","permalink":"http://zxtotti17.github.io/2018/10/31/Mysql%E7%AC%94%E8%AE%B0/","excerpt":"第1章 SQL基础1.数据分为DDL(数据定义语言)，DML(数据操纵语言)，DCL(数据控制语言) 1.1 DDL语句 123456789101112131415mysql -uroot -pcreate database test1;use test1;show tables; #查看所有表drop database test1;create table emp(ename varchar(10),hiredate date,sal decimal(2,10),deptno int(2));desc emp; #查看表信息show create table emp \\G; #\\G使得记录能够按照字段竖向排列 以便显示更长内容drop table emp;alter table emp modify ename varchar(20); #修改表字段alter table emp add column age int(3); #添加字段alter table emp drop colum age #删除字段alter table emp change age age123 int(4); #字段改名同时修改类型alter table emp add birth date after ename; #修改字段排列顺序alter table emp rename emp1;","text":"第1章 SQL基础1.数据分为DDL(数据定义语言)，DML(数据操纵语言)，DCL(数据控制语言) 1.1 DDL语句 123456789101112131415mysql -uroot -pcreate database test1;use test1;show tables; #查看所有表drop database test1;create table emp(ename varchar(10),hiredate date,sal decimal(2,10),deptno int(2));desc emp; #查看表信息show create table emp \\G; #\\G使得记录能够按照字段竖向排列 以便显示更长内容drop table emp;alter table emp modify ename varchar(20); #修改表字段alter table emp add column age int(3); #添加字段alter table emp drop colum age #删除字段alter table emp change age age123 int(4); #字段改名同时修改类型alter table emp add birth date after ename; #修改字段排列顺序alter table emp rename emp1; 1.2 DML语句 增删改查 12345678910insert into emp (ename,sal) values('dony',1000);delete from emp where ename = 'xxx';select distinct age from emp1; #查询的内容去重select * from emp order by age,deptno desc; #根据某个字段排序 select age,count(1) from emp group by age with rollup; #分类统计计数及总数 select age,count(1) from emp group by age having count(1)&gt;1; select ename,deptname from emp,dept where emp.age = dept.age; #联查,内链接 select ename,deptname from emp left jion dept on emp.deptno = dept.deptno; #表链接很多情况下优于子查询 select * from dept union all select * from emp; #集合显示不去重 select * from dept union select * from emp; #集合显示去重 You can&apos;t specify target table &apos; for update in FROM clause Mysql不让对查询到的目标语句进行更新 1DELETE FROM playeritems WHERE id IN(SELECT mid FROM (SELECT min(id) as mid FROM playeritems WHERE uid = '1300200112870961' GROUP BY iname HAVING count(iname) &gt; 1 )as tmp); 1.3 DCL语句 12grant select,insert on sakila.* to 'z1@localhost' identified by '123'; #赋予用户权限revoke insert on sakila.* from 'z1@localhost'; #回收权限2.常用函数 1234567891011select NOW(); #xxxx-xx-xx xx:xx:xxselect UNIX_TIMESTAMP(now()); #时间戳select FROM_UNIXTIME(时间戳); #xxxx-xx-xx xx:xx:xxIF(value,t,f) #如果value为真，返回t,否则返回fselect if(a &gt; 2000, 'high','low') from BIFNULL(value1,value2) #如果value1不为空，返回value1,否则返回value2select ifnull(a , 0) from BCASE WHEN value THEN res1 ... ELSE def END #如果value1真，返回res1,否则返回defselect case when a&lt;2000 then 'low' else 'high' end from BCASE exp WHEN value THEN res1 ... ELSE def END #如果exp = value1真，返回res1,否则返回defselect case a when 1000 then 'low' when 2000 then 'mid' else 'high' end from B 第2章 存储引擎1.mysql的存储引擎有好多种，这边记录2种 1.1 MyISAM 不支持事务、不支持外键、速度快、表锁 1.2 InnoDB 支持提交、回滚、奔溃恢复能力的事务安全，行锁 2.myssql事务 123start transaction;sql 操作commit and chain; 3.防止sql注入 123456$re = \"/(|\\'|(\\%27)|\\;|(\\%3b)|\\=|(\\%3d)|\\(|(\\%28)|\\)|(\\%29)|(\\/*) |(\\%2f%2a)|(\\ */)|(\\%2a%2f)|\\+|(\\%2b)|\\&lt;|(\\%3c)|\\&gt;|(\\%3e)|\\(--))|\\[|\\%5b|\\]|\\%5d)/\";if(preg_match($re, $aa) &gt;0)&#123; echo(\"参数不对\"); return 0;&#125; 4.SQL MODEANSI 使语法行为更符合sqlSTRICT_TRANS_TABLES 试用于事务，严格模式，报错不警告,不允许非法日期TRADITIONAL 严格模式，适用于事务非事务，不警告直接报错 5.sql分区RANGE分区：基于一个给定连续区间范围，把数据分配到不同分区LIST分区：类似RANGEHASH分区：基于给定的分区个数，把数据分配到不同分区KEY分区：类似于HASH分区RANGE\\LIST\\HASH分区键必须INT型 好处4点存储更多数据、优化查询、快速删除数据、获得更大查询吞吐量Range分区利用取值范围将数据分成分区 12345678910CREATE TABLE emp(id INT NOT NULL,NAME VARCHAR(20),age INT)PARTITION BY RANGE(ID)(PARTITION p0 VALUES LESS THAN (6),PARTITION p1 VALUES LESS THAN (11),PARTITION pmax VALUES LESS THAN maxvalue); LIST分区是建立离散的之列表告诉数据库特定值在哪个分区 123456789101112CREATE TABLE expense(expense_date DATE NOT NULL,category INT,amount DECIMAL (10,3))PARTITION BY LIST(category)(PARTITION p0 VALUES IN(3,5),#可字符串在5.5版本后PARTITION p1 VALUES IN(1,10),PARTITION p2 VALUES IN(4,9),PARTITION p3 VALUES IN(2),PARTITION p4 VALUES IN(6)); Columns分区可分为 RANGE Columns和LIST Columns分区都支持int\\date\\string,还支持多列 123456789CREATE TABLE expense(a INT,b INT)PARTITION BY RANGE COLUMS(a,b)(PARTITION p0 VALUES IN(0,10),#可字符串在5.5版本后PARTITION p1 VALUES IN(10,10),PARTITION p2 VALUES IN(10,29)); HASH分区用来分散热点读，确保数据在预留分区平均分布，有常规分区和线性分区 1234567891011121314#常规 平衡不方便CREATE TABLE emp(id INT NOT NULL,NAME VARCHAR(20),age INT)PARTITION BY HASH(ID) PARTITIONS 4;#线性 快速不平衡CREATE TABLE emp(id INT NOT NULL,NAME VARCHAR(20),age INT)PARTITION BY LINEAR HASH(ID) PARTITIONS 4; key分区类似HASH分区，数据类型除TEXThe BLOB以外都可以 RANGE&amp;LIST 分区管理 分区被删除了分区中的数据也被删除了 123456789alter table xxx drop partition p2; #删alter table xxx add partition (partiton p5 values less than (2025)) #增 不能添加一个包含现有分区值列表中的任意值分区alter table xxx reorganize partition p3 into ( partition p2 values less than (2005), partition p3 values less than (2015)); #拆分alter table xxx reorganize partition p1,p2,p3 into ( partition p1 values less than (2015)); #合并 HASH&amp;KEY 分区管理 12alter table xxx coalesce partition 2; #原4删2alter table xxx coalesce partition 8; #原4加8 6.SQL优化 通过慢查询日志定位效率低的sql,在查询过程中出现的情况可以用show processlist命令查看mysql进程，看锁表及进程状态 将慢的sql提取做explain分析，type的性能如下 ALL,全表扫瞄 index,索引全扫描 range,索引范围扫描 常见&lt;&lt;=&gt;&gt;=\\between ref,使用非唯一索引扫描或者唯一索引前缀扫描（联合索引） eq_ref,使用唯一索引 const/system,单表中最多有一个匹配行 NULL，不查表直接得到结果 自上而下效率越来越高 通过show profile分析sql123456select @@have_profiling; #查询是否支持select @@profiling; #查询是否开启set profiling=1; #开启show profiles; #显示sql的执行排列show profile for query 4; #查找具体某一条的状态show profile cpu for query 4; #查询莫一条在具体（all\\cpu\\block io\\context\\switch\\page faults） mac或者linux当mysql连接不上的时候加ALTER USER ‘root’@’localhost’ IDENTIFIED WITH mysql_native_password BY ‘password’;","categories":[{"name":"数据库","slug":"数据库","permalink":"http://zxtotti17.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://zxtotti17.github.io/tags/mysql/"}]},{"title":"pomelo学习笔记","slug":"pomelo学习笔记","date":"2018-10-23T11:34:45.000Z","updated":"2019-11-27T15:26:48.000Z","comments":true,"path":"2018/10/23/pomelo学习笔记/","link":"","permalink":"http://zxtotti17.github.io/2018/10/23/pomelo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"环境 12345678getBase() Application.getBase(); 获取应用程序的基本路径set(setting, val, attach); Application.set(); setting:应用程序的配置；val:需要设置的值；attach:是否将设配置应用到程序。设置或返回配置的值。get(setting) Application.get(); setting:应用程序的配置。获取配置的值enabled(setting) Application.enabled(); setting:应用程序的配置。检查配置是否启用disabled(setting) Application.disabled(); setting:应用程序的配置。检查配置是否禁用enbale(setting) Application.enbale(); setting:应用程序的配置。启用配置disable(setting) Application.disabled(); setting:应用程序的配置。禁用配置configure(env,fn,type) Application.configure();env:应用环境;fn:回调函数;type:服务类型. 初始化 1234567start() Application.start(); 启动应用程序。它会加载默认的组件和启动所有加载的组件。registerAdmin(moduleId,module,opts) Application.registerAdmin(); moduleId:(可选参数)模块id或者有modeule提供的模块Id;module:模块对象或者模块的工程函数;opts:模块构造函数的参数。filter(filter) Application.filter(); filter:provide before and after filter method。add a filter to before and after filterbefore(bf) Application.before(); bf:before filter。Add before filterafter(af) Application.after(); af:after filter。Add after filterload(name, component, opts) Application.load(); name:组件的名称（可选）；component：组件的实例或者组件的工厂函数；opts：组件构造函数的参数（可选）。加载组件loadConfig(key,val) Application.loadConfig(); key:环境配置的关键字;val:环境配置的值。导入json文件来配置环境。","text":"环境 12345678getBase() Application.getBase(); 获取应用程序的基本路径set(setting, val, attach); Application.set(); setting:应用程序的配置；val:需要设置的值；attach:是否将设配置应用到程序。设置或返回配置的值。get(setting) Application.get(); setting:应用程序的配置。获取配置的值enabled(setting) Application.enabled(); setting:应用程序的配置。检查配置是否启用disabled(setting) Application.disabled(); setting:应用程序的配置。检查配置是否禁用enbale(setting) Application.enbale(); setting:应用程序的配置。启用配置disable(setting) Application.disabled(); setting:应用程序的配置。禁用配置configure(env,fn,type) Application.configure();env:应用环境;fn:回调函数;type:服务类型. 初始化 1234567start() Application.start(); 启动应用程序。它会加载默认的组件和启动所有加载的组件。registerAdmin(moduleId,module,opts) Application.registerAdmin(); moduleId:(可选参数)模块id或者有modeule提供的模块Id;module:模块对象或者模块的工程函数;opts:模块构造函数的参数。filter(filter) Application.filter(); filter:provide before and after filter method。add a filter to before and after filterbefore(bf) Application.before(); bf:before filter。Add before filterafter(af) Application.after(); af:after filter。Add after filterload(name, component, opts) Application.load(); name:组件的名称（可选）；component：组件的实例或者组件的工厂函数；opts：组件构造函数的参数（可选）。加载组件loadConfig(key,val) Application.loadConfig(); key:环境配置的关键字;val:环境配置的值。导入json文件来配置环境。 组件相关 12345678910111213141516route(serverType, routeFunc) Application.route(); serverType:服务类型;routeFunc:路由功能函数,如：routeFunc(session, msg, app, cb)未指定的服务类型设置路由功能。如：app.route('area', routeFunc);var routeFunc = function(session, msg, app, cb) &#123; // all request to area would be route to the first area server var areas = app.getServersByType('area'); cb(null, areas[0].id);&#125; 获取相关配置，组件方法 123456789101112131415getMaster() Application.getMaster() 获得Maseter服务的信息getCurServer() Application.getCurServer() 获得当前服务的信息getServerId() Application.getServerId() 获得当前服务的IDgetServerType() Application.getServerType() 获得当前服务的类型getServers() Application.getServers() 获得所有当前服务的信息getServersFromConfig() Application.getServersFromConfig() 从server.json中获得所有服务的信息getServerTypes() Application.getServerTypes() 获得所有服务的类型getServerById(serverId) Application.getServerById() 根据服务ID从服务集群中获得服务的信息getServerFromConfig(serverId) Application.getServerFromConfig() 根据服务ID从server.json中获得服务的信息getServersByType(serverType) Application.getServersByType() 根据服务类型获取服务信息isFrontend(server) Application.isFrontend() 检查服务是否是一个前端服务isBackend(server) Application.isBackend() 检查服务是否是一个后端服务isMaster() Application.isMaster() 检查当前服务是否是主服务addServers(servers) Application.addServers() servers：新服务信息列表。添加新服务信息到正在运行的应用程序中removerServers(ids) Application.removerServers() ids：服务id列表。从当前运行的应用程序中删除服务信息。 创建和维护本地服务的信道。 12345createChannel(name) ChannelService.prototype.createChannel() 根据信道名称创建信道，如果该信道已存在则返回已存在的信道getChannel(name,create) ChannelService.prototype.getChannel() name:信道名称，create:如果为true，并且信道不存在时，则创建新的信道。根据信道名称获取信道destroyChannel(name) ChannelService.prototype.destroyChannel() 根据信道名称，删除信道pushMessageByUids(route, msg, uids, cb) ChannelService.prototype.pushMessageByUids() route：消息路由；msg：发送到客户端的消息；uids：接收消息的客户端列表，格式 [&#123;uid: userId, sid: frontendServerId&#125;]；cb：回调函数 cb(err)。根据uids将消息推送给客户端，如果uids中的sid未指定，则忽略相应的客户端broadcast(stype,route, msg, opts, cb) ChannelService.prototype.broadcast() stype：前端服务的类型;route：路由;msg：消息;opts：广播参数;cb：回调函数。广播消息到所有连接的客户端。 Channel 123456add(uid,sid) Channel.prototype.add() uid:用户编号；sid：用户连接到的前端服务id。添加指定用户到信道。leave(uid,sid) Channel.prototype.leave() uid:用户编号；sid：用户连接到的前端服务id。从信道中移除用户。getMembers() Channel.prototype.getMembers() 获得信道中的成员getMember(uid) Channel.prototype.getMember() 根据uid获取成员信息destroy() Channel.prototype.destroy() 销毁信道pushMessage(route,msg,cb) Channel.prototype.pushMessage() route：消息路由，msg：要推送的消息，cb：回调函数。将消息推送给信道的所有成员。 GlobalChannelService 1234567891011121314151617destroyChannel(name,cb) GlobalChannelService.prototype.destroyChannel() uid:用户编号；sid：用户连接到的前端服务id。添加指定用户到信道。add(name,uid,sid,cb) GlobalChannelService.prototype.add() name:信道名称；uid：用户id；sid：前端服务id；cb：回调函数。添加成员到信道。leave(name,uid,sid,cb) GlobalChannelService.prototype.leave() name:信道名称；uid：用户id；sid：前端服务id；cb：回调函数。从信道中移除成员。pushMessage() GlobalChannelService.prototype.pushMessage(serverType, route, msg,channelName, opts, cb)serverType：前端服务的类型, route：路由, msg：需要推送的消息,channelName：信道名称, opts：参数, cb：回调函数通过全局信道发送消息 LocalSessionService 1234567get(frontendId,sid,cb) LocalSeesionService.prototype.get() frontendId:会话链接的前端服务id,sid:会话Id,cb:回调函数。根据前端服务和会话id获得本地会话getByUid(name,uid,sid,cb) LocalSeesionService.prototype.getByUid() frontendId:会话链接的前端服务id,uid：绑定到会话的用户id，cb：回调函数。args: cb(err, localSessions)。根据前端服务和用户id获取本地会话。kickBySid(name,uid,sid,cb) LocalSeesionService.prototype.kickBySid() frontendId:会话链接的前端服务id,sid:会话Id,cb:回调函数。根据会话id踢掉该会话。kickByUid() LocalSeesionService.prototype.kickByUid() frontendId:会话链接的前端服务id,uid：用户id,cb:回调函数。根据用户id踢掉该会话。 LocalSession 123456789101112bind(uid,cb) LocalSeesion.prototype.bind() uid:用户编号;cb:回调函数。callfunction(err)。绑定当前会话，用于前端服务的推送和全局会话的绑定。unbind(uid,cb) LocalSeesion.prototype.unbind() uid:用户编号;cb:回调函数。callfunction(err)。取消绑定。set(key,value) LocalSeesion.prototype.set() 将key/value添加到本地会话中get(key) LocalSeesion.prototype.get() 根据key从本地会话中获取值。push(key,cb) LocalSeesion.prototype.push() 将本地会话中的key/value添加到全局会话中pushAll(cb) LocalSeesion.prototype.pushAll() 将本地会话中的所有key/value添加到全会话中 SessionService 1234567kick(uid,cb) SeesionService.prototype.kick() 踢掉该用户的所有离线会话kickBySession(sid,cb) SeesionService.prototype.kickBySession() sid:会话编号;cb:回调函数。根据会话id踢掉一个在线用户sendMessage(sid,msg) SeesionService.prototype.sendMessage()根据会话id向客户端发送消息sendMessageByUid(uid,msg) SeesionService.prototype.sendMessageByUid() 根据用户id向客户端发送消息 Pomelo createApp(opts) Pomelo.create() 创建一个Pomelo 应用程序","categories":[{"name":"服务端框架","slug":"服务端框架","permalink":"http://zxtotti17.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://zxtotti17.github.io/tags/node-js/"}]},{"title":"node笔记","slug":"node笔记","date":"2018-08-21T09:04:37.000Z","updated":"2020-04-07T03:13:02.450Z","comments":true,"path":"2018/08/21/node笔记/","link":"","permalink":"http://zxtotti17.github.io/2018/08/21/node%E7%AC%94%E8%AE%B0/","excerpt":"第一章 node简介1.1 node的特点 1.1.1 异步I/O 绝大多数操作以异步方式进行调用 1.1.2 事件与回调函数 1.1.3 单线程，但是可以用WebWorkers的方式解决单线程的问题（子进程），用Master-Worker用master统一管理子进程 1.1.4 跨平台 1.1.5 c++速度大约是node的2.5倍 1.2 模块机制 1.2.1 分为核心模块和文件模块，require没带路径的为核心模块，直接加载进内存，带路径的为文件模块,核心模块中有c++和javascript两部分，其中buffer、crypto、evals、fs、os、等都是c++部分的 1.2.2 npm安装的核心模块插件在package.json中定义 1.3 异步I/O 1.3.1 操作系统内核对I/O只有：阻塞I/O和非阻塞I/O，node中的异步I/O模型由事件循环、观察者、请求对象、I/O线程池 整个系统可以理解为事件循环相当于厨子，不停的询问是否有新的订单，观察者相当于收银员，收到用户的订单将订单分给厨子，而订单相当于请求对象，参数、方法、回调函数斗封装在请求对象中, 以上是异步I/O的第一步，io线程池相当于放订单的桌子， 请求对象-&gt;I/O线程池-&gt;观察者-&gt;事件循环 1.3.2 非异步的I/O主要是setTimeout(),setInterval(),setImmediate(),process.nextTick()","text":"第一章 node简介1.1 node的特点 1.1.1 异步I/O 绝大多数操作以异步方式进行调用 1.1.2 事件与回调函数 1.1.3 单线程，但是可以用WebWorkers的方式解决单线程的问题（子进程），用Master-Worker用master统一管理子进程 1.1.4 跨平台 1.1.5 c++速度大约是node的2.5倍 1.2 模块机制 1.2.1 分为核心模块和文件模块，require没带路径的为核心模块，直接加载进内存，带路径的为文件模块,核心模块中有c++和javascript两部分，其中buffer、crypto、evals、fs、os、等都是c++部分的 1.2.2 npm安装的核心模块插件在package.json中定义 1.3 异步I/O 1.3.1 操作系统内核对I/O只有：阻塞I/O和非阻塞I/O，node中的异步I/O模型由事件循环、观察者、请求对象、I/O线程池 整个系统可以理解为事件循环相当于厨子，不停的询问是否有新的订单，观察者相当于收银员，收到用户的订单将订单分给厨子，而订单相当于请求对象，参数、方法、回调函数斗封装在请求对象中, 以上是异步I/O的第一步，io线程池相当于放订单的桌子， 请求对象-&gt;I/O线程池-&gt;观察者-&gt;事件循环 1.3.2 非异步的I/O主要是setTimeout(),setInterval(),setImmediate(),process.nextTick() 1.4 异步编程 1.4.1 异步编程的解决方案分为3个： 1）事件发布/订阅模式 2）Promise/Deferred模式 3）流程控制库 1.4.2 事件发布/订阅模式 123456//订阅emitter.on(\"event1\",function(message)&#123; console.log(message);&#125;);//发布emitter.emit('event1',\"I Love you\"); 1）继承events模块 123456var events = require('events');function Stream()&#123; events.EventEmitter.call(this);&#125;util.inherits(Stream,events.EventEmitter); 2)利用事件队列解决崩溃问题 事件发布/订阅模式中一般只有一个once()方法，用一个『状态锁』或者『事件队列』防止崩溃 状态锁 12345678910var status = \"ready\";var select = function(callback)&#123; if(status == \"ready\" )&#123; status = \"pending\"; db.select(\"SQL\", function(results)&#123; status = \"ready\"; callback(results); &#125;); &#125;&#125;; 事件队列 1234567891011var proxy = new events.EventEmitter();var status = function (callback) proxy.once(\"selected\", callback); if(status === \"ready\")&#123; status = \"pending\"; db.select(\"SQL\", function(result)&#123; proxy.emit(\"selected\",result); status = \"ready\"; &#125;); &#125;&#125; 3）多异步之间的协作方案 借组一个第三方函数和第三方变量来处理异步协作的结果 123456789101112var after = function (times,callback)&#123; var count = 0, results = &#123;&#125;; return function (key, value)&#123; result[key] = value; count++; if(count === times)&#123; callback(results); &#125; &#125;&#125;var done = after(times, render); 1.4.3 Promise/Deferred模式 Promise是高级接口，事件是低级接口，Promise更像链表 1.4.4 async流程控制模块 1）async的series()方法实现串行（不传参） 12345678910async.series([ function (callback)&#123; fs.readFile('file1.txt','utf-8',calback); &#125;, function (callback)&#123; fs.readFile('file2.txt','utf-8',calback); &#125;],function (err,result)&#123; //result = [file1.txt,file2.txt]等价于先处理file1.txt，在处理file2.txt，错误回调&#125;); 2）async的parallel()方法实现并行 12345678910async.parallel([ function (callback)&#123; fs.readFile('file1.txt','utf-8',calback); &#125;, function (callback)&#123; fs.readFile('file2.txt','utf-8',calback); &#125;],function (err,result)&#123; //result = [file1.txt,file2.txt]等价于并行处理file1.txt，在处理file2.txt，错误回调&#125;); 3）async的waterfall()方法实现串行（传参） 略 4）async.auto()可以根据依赖关系自动分析，以最佳顺序执行 略 1.4.5 流程控制模块Step 1)Step接受任意数量任务，所有任务传行执行 1234567891011Step( function (callback)&#123; fs.readFile('file1.txt','utf-8',this); &#125;, function (callback)&#123; fs.readFile('file2.txt','utf-8',this); &#125;, function done(err, content) &#123; console.log(content); &#125;); 2)Step实现异步任务并行执行要用this的parallel() 1234567891011Step( function (callback)&#123; fs.readFile('file1.txt','utf-8',this.parallel()); &#125;, function (callback)&#123; fs.readFile('file2.txt','utf-8',this.parallel()); &#125;, function done(err, content) &#123; console.log(arguments); &#125;); 1.4.6流程控制模块wind 1)wind的$await()方法实现异步等待 2）wind的whenAll()处理并发 1.5 异步并发控制 1.5.1 bagpipe解决办法（API添加过载保护，用队列控制并发） 1234567891011var Bagpipe = require('bagpipe');//设定最大并发数为10var bagpipe = new Bagpipe(10);for(var i = 0; i&lt; 100;i++)&#123; bagpipe.push(async, function ()&#123; &#125;);&#125;bagpipe.on('full',function (length)&#123; console.warn('底层系统处理不及时');&#125;); 1.5.2 拒绝模式 123var bagpipe = new Bagpipe(10,&#123; refuse: true&#125;); 1.5.3 超时控制 123var bagpipe = new Bagpipe(10, &#123; timeout: 3000&#125;); 1.6 内存管理 1.6.1 v8内存分为新生代和老生代的 node –max-old-space-size 2048 xxx.js 调整内存大小执行某个脚本 v8堆内存64位系统是1.4G,32位系统是0.7G 新生代内存的回收机制是将堆内存一分为2，使用中的是From，空的是to，进行垃圾回收时，是将from中的存活对象复制到to中，然后释放非存活的，同时from和to对换，缺点是只能使用一半的内存空间 老生带内存的回收机制是将from中的使用的标记，回收未使用的 1.6.2 外部访问内部的变量的方法叫闭包 还有的说是内部变量无法被外部访问的过程叫闭包 1.6.3 查看内存使用process.memoryUsage() os.totalmem os.freemem 1.7 Buffer 1.7.1 Buffer与字符串转换 123new Buffer(str, [encoding]);buf.write(string, [offset], [length], [encodeing]);buf.tostring([encoding], [start], [end]);1.8 网络 1.8.1 tcp协议中的osi模型（分为 物理层、数据链路层、网络层、传输层、会话层、表示层、应用层） server 12345678910111213var net = require('net');var server = net.createServer(function(socket)&#123; server.on('data',function(data)&#123; &#125;); server.on('end',function(data)&#123; &#125;); server.on('error',function(data)&#123; &#125;); server.write('data');&#125;);server.listen(port,function()&#123;&#125;) client 12345678910var net = require('net');var client = net.connect(&#123;port: 8124&#125;,function(socket)&#123; client.on('data',function(data)&#123; &#125;); client.on('end',function(data)&#123; &#125;); client.on('error',function(data)&#123; &#125;); client.write('data');&#125;); 1.8.2 UDP是用户数据包协议，一个套接字可以与多个UDP通信 server 12345678910var dgrm = require(\"dgrm\");var server = dgrm.createSocket(\"udp4\");server.on(\"message\", function (msg, rinfo)&#123; console.log(\"xxx\");&#125;);server.on(\"listening\", function() &#123; var address = server.address(); console.log(\"xxx\");&#125;);server.bind(41234); client 123456var dgram = require('dgram');var messgae = new Buffer(\"xxxx\");var client = dgram.createSocket(\"udp4\");clinet.send(message, 0, message.length, 41234, \"localhost\", function(err,bytes)&#123; client.close();&#125;); 1.8.3 HTTP是构建在TCP之上属于应用层协议 123456789101112131415161718192021222324252627282930313233343536373839404142https_request : function(host, path, post_data, cb)&#123; var reqdata = JSON.stringify(post_data); var options = &#123; hostname: host, port: 443, method: 'POST', path: path, headers: &#123; 'Content-Type': 'application/json' &#125; &#125;; var req_time_out = setTimeout(function() &#123; req.abort(); cb(400, &#123;code:400,message:'请求超时'&#125;); logger.n.info('Got Request Timeout.'); &#125;, 10000); var req = https.request(options, function (res) &#123; clearTimeout(req_time_out); //等待响应60秒超时 var res_time_out = setTimeout(function() &#123; res.destroy(); cb(400, &#123;code:400,message:'响应超时'&#125;); logger.n.info('Got Response Timeout.'); &#125;, 60000); var status_code = res.statusCode; var body = null; logger.n.info(\"Got status_code: \" + status_code); res.on('data',function(data)&#123; body = JSON.parse(data); &#125;).on('end', function()&#123; clearTimeout(res_time_out); cb(status_code, body); &#125;); &#125;).on('error', function(e) &#123; cb(400, &#123;code:400,message:e.message&#125;); logger.n.info(\"Got error: \" + e.message); &#125;); req.write(reqdata); req.end(); &#125; 1.8.4 WebSocket client 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 var client= new net.Socket();var flag = true;var port = 0;client.on('connect',function ()&#123; //正常连接 flag = true; logger.boot.info('socket Connection succeed');&#125;);client.on('end', function() &#123; //flag=false; logger.n.warn('!!!!!tcp_client disconnected'); setTimeout(Fight_Service.tcp_reconnect, 1000);&#125;);client.on('data',function(data)&#123; //得到服务端返回来的数据 Fight_Service.processResp(data);&#125;);client.on('error',function(error)&#123; //错误出现之后关闭连接 flag = false; logger.n.error('socket error:' + error); client.destroy(); setTimeout(Fight_Service.tcp_reconnect, 1000);&#125;);client.on('close',function()&#123; //正常关闭连接 flag = false; logger.n.warn('socket Connection closed'); client.destroy();&#125;);Fight_Service.tcp_reconnect = function(worker_id)&#123; //创建socket客户端 client.setEncoding('binary'); if (port == 0 )&#123; //连接到服务端115.159.186.60 8400 // logger.boot.info(\"socket process_work_id:\" + worker_id); worker_id = worker_id % 8; port = 8400 + worker_id; &#125;else&#123; logger.boot.info(\"socket tcp_reconnect\"); &#125; logger.boot.info(\"socket_port_id:\" + port); client.connect(port,\"10.96.71.91\");&#125; 1.9 多进程 1.9.1 child_process模块 1）spawn()启动一个子进程执行命令，无回调，无超时 2）exec()启动一个子进程执行命令，有回调，有超时 3）execFile()启动一个子进程执行可执行文件 4）fork()启动node子进程执行js文件模块 12345var fork = require('child_process').fork;var cpus = require('os').cpus();for(var i = 0; i &lt; cpus.length; i++)&#123; fork('./worker.js');&#125; 1.9.2 进程间通信IPC，主线程与工作线程之间通过onmessage()和postMessage()进行通信，子进程对象则由send()方法实现主进程向子进程发送数据 1.9.3 句柄是一种用来标识资源的引用，用来拓展有限的文件描述符 1234567child.send(message,[sandHandle])如（child.send('server',server)）;子进程代码process.on('message',function(m, server)&#123; if(m == 'server')&#123; xxxxx&#125;&#125;) 1.9.4 父进程可以通过kill()方法给子进程发送一个SIGTERM信号杀进程 1234567891011121314151617181920212223242526chid.kill([signal]);process.kill(pid, [signal]);``` 在退出中加入自动重启可能会有新用户进来请求丢失的情况，工作进程在得知退出时，向主进程发送一个自杀信号（达到先创建在退出进程）``` bash/** * cluster mode */if ( opts.get('cluster') || config.APP_CLUSTER.ENABLE) &#123; var cluster = require('cluster'); if (cluster.isMaster) &#123; console.log('[CLUSTER MODE] MASTER'); for (var i=0; i&lt;config.APP_CLUSTER.NUM; i++) &#123; cluster.fork(); &#125; cluster.on('exit', function(worker, code, signal) &#123; console.log('worker ' + worker.process.pid + ' died'); cluster.fork(); &#125;); return; &#125; console.log('[CLUSTER MODE] WORKER');&#125; 1.10 插件 1.10.1 Sequelizejs 此插件在option索引的位置千万不能写错，写错有大几率导致db堵塞 123456789101112131415161718192021Model.findAll(&#123; attributes: ['foo', ['bar', 'baz']]&#125;);SELECT foo, bar AS baz ...Model.findAll(&#123; attributes: [[sequelize.fn('COUNT', sequelize.col('hats')), 'no_hats']]&#125;);SELECT COUNT(hats) AS no_hats ...Post.findAll(&#123; where: &#123; [Op.or]: [&#123;authorId: 12&#125;, &#123;authorId: 13&#125;] &#125;&#125;);SELECT * FROM post WHERE authorId = 12 OR authorId = 13;Order.findAll(&#123;attributes:['name', [sequelize.fn('SUM', sequelize.col('price')), 'sum']], group:'name', having:['COUNT(?)&gt;?', 'name', 1], raw:true&#125;).then(function(result)&#123; console.log(result);&#125;)SELECT `name`, sum(`price`) AS `sum` FROM `orders` AS `Orders` GROUP BY name HAVING COUNT('name')&gt;1; 1.10.2 Lodashjs [文档](https://www.lodashjs.com/docs/4.17.5.html) _.indexOf(array, value, [fromIndex=0]) number): Returns the index of the matched value, else -1. 123456_.indexOf([1, 2, 1, 2], 2);// =&gt; 1 // Search from the `fromIndex`._.indexOf([1, 2, 1, 2], 2, 2);// =&gt; 3 _.dropRight(array, [n=1]) (Array): Returns the slice of array. 12345678_.dropRight([1, 2, 3]);// =&gt; [1, 2] _.dropRight([1, 2, 3], 2);// =&gt; [1]_.dropRight([1, 2, 3], 0);// =&gt; [1, 2, 3] _.filter(collection, [predicate=_.identity]) (Array): Returns the new filtered array. 1234567var users = [ &#123; 'user': 'barney', 'age': 36, 'active': true &#125;, &#123; 'user': 'fred', 'age': 40, 'active': false &#125;]; _.filter(users, function(o) &#123; return !o.active; &#125;);// =&gt; objects for ['fred'] _.find(collection, [predicate=_.identity], [fromIndex=0]) (*): Returns the matched element, else undefined. 12345678 var users = [ &#123; 'user': 'barney', 'age': 36, 'active': true &#125;, &#123; 'user': 'fred', 'age': 40, 'active': false &#125;, &#123; 'user': 'pebbles', 'age': 1, 'active': true &#125;]; _.find(users, function(o) &#123; return o.age &lt; 40; &#125;);// =&gt; object for 'barney' _.forEach(collection, [iteratee=_.identity]) 12345678_.forEach([1, 2], function(value) &#123; console.log(value);&#125;);// =&gt; Logs `1` then `2`. _.forEach(&#123; 'a': 1, 'b': 2 &#125;, function(value, key) &#123; console.log(key);&#125;); _.groupBy(collection, [iteratee=_.identity]) (Object): Returns the composed aggregate object. 123456_.groupBy([6.1, 4.2, 6.3], Math.floor);// =&gt; &#123; '4': [4.2], '6': [6.1, 6.3] &#125; // The `_.property` iteratee shorthand._.groupBy(['one', 'two', 'three'], 'length');// =&gt; &#123; '3': ['one', 'two'], '5': ['three'] &#125; #Promise.map Promise.all 相当于事务 _.map(collection, [iteratee=_.identity]) (Array): Returns the new mapped array. 123456789function square(n) &#123; return n * n;&#125;_.map([4, 8], square);// =&gt; [16, 64] _.map(&#123; 'a': 4, 'b': 8 &#125;, square);// =&gt; [16, 64] (iteration order is not guaranteed) #Promise.reduce是顺序执行 _.reduce(collection, [iteratee=_.identity], [accumulator]) - (*): Returns the accumulated value. 1234f_.reduce([1, 2], function(sum, n) &#123; return sum + n;&#125;, 0);// =&gt; 3 _.isEmpty(value) (boolean): Returns true if value is empty, else false. 1234567891011121314_.isEmpty(null);// =&gt; true _.isEmpty(true);// =&gt; true _.isEmpty(1);// =&gt; true _.isEmpty([1, 2, 3]);// =&gt; false _.isEmpty(&#123; 'a': 1 &#125;);// =&gt; false 项目案例 略 1.10.3 Moment.js [文档](http://momentjs.cn) 案例使用 12moment(event.start_time).startOf('day')/1000;moment.unix(moment().startOf('month')/1000).utcOffset(config.TIME_ZONE_DIFF).format(\"YYYY-MM-DD HH:mm:ss\");js中数组及数据类型对象都是按址传递","categories":[{"name":"开发语言","slug":"开发语言","permalink":"http://zxtotti17.github.io/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://zxtotti17.github.io/tags/node-js/"}]},{"title":"翻译提取替换","slug":"翻译提取替换","date":"2018-08-03T03:02:18.000Z","updated":"2019-11-27T15:26:48.000Z","comments":true,"path":"2018/08/03/翻译提取替换/","link":"","permalink":"http://zxtotti17.github.io/2018/08/03/%E7%BF%BB%E8%AF%91%E6%8F%90%E5%8F%96%E6%9B%BF%E6%8D%A2/","excerpt":"提取提取客户端资源文件之前先要用uc-utf8.php转utf-8 把unicode码转成utf-8的日文在提取将要提取文字的文件整合与getFromHtml.sh 放在同目录下12345678#!/bin/bash#sh getFromHtml.sh under the template fold#Change filelist.csv to excel file, and give it to translatorLANG=C grep -r -n -v '^[[:cntrl:][:print:]]*$' . | grep -v \"using UnityEngine;\" | grep -v svn | grep -v // | grep -v \\* | grep -v \"\\&#123;\\*\" | grep -v \"\\\"Name\\\"\" &gt; ~/lj_2_3_server.csvsed -i 's@\\t@ @g' ~/lj_2_3_server.csvsed -i 's@\\([^:]*\\):\\([0-9]*\\):@\\1\\t\\2\\t@' ~/lj_2_3_server.csv 点击下载","text":"提取提取客户端资源文件之前先要用uc-utf8.php转utf-8 把unicode码转成utf-8的日文在提取将要提取文字的文件整合与getFromHtml.sh 放在同目录下12345678#!/bin/bash#sh getFromHtml.sh under the template fold#Change filelist.csv to excel file, and give it to translatorLANG=C grep -r -n -v '^[[:cntrl:][:print:]]*$' . | grep -v \"using UnityEngine;\" | grep -v svn | grep -v // | grep -v \\* | grep -v \"\\&#123;\\*\" | grep -v \"\\\"Name\\\"\" &gt; ~/lj_2_3_server.csvsed -i 's@\\t@ @g' ~/lj_2_3_server.csvsed -i 's@\\([^:]*\\):\\([0-9]*\\):@\\1\\t\\2\\t@' ~/lj_2_3_server.csv 点击下载 可以脚本文件内修改输出路径及文件名运行命令提取内容sh getFromHtml 取出后的excel先在编辑软件里打开编码改成ansi, 否则直接excel打开会乱码在excel内，全选，点击数据-&gt;分列-&gt;分隔符号-&gt;Tab键-&gt;确定。。。。以Tab键分割内容完成后的数据格式如下：(A列为行数，B列为行号，C列为提取的原字符)如果有发现提取到不需要翻译的错误的，可直接整行删除。。。提交翻译 替换翻译后的文件如果为xls，在最后另起一列，用公式=A1&amp;”^”&amp;B1&amp;”^”&amp;C1连接，拖到底，用连接的主要目的是让文件、行、数据之间有个特殊的符号分割^ 这个符号基本见不到所以用这个，将最后列的数据拷贝到sublime，替换”^ “ 为 “^”去掉多余的数据与行之间的一个空格，然后将\\替换为@@@或者奇怪不重复的符号，如果不替换转换会被转换掉，最后将sublime上的代码考到新建的一个txt中另存为utf-8，上传到服务器对应的目录下面，修改changeHtml.sh这个文件中判断中间的分割符号保存，整个文件权限777. 1234567891011121314151617181920212223242526272829303132#!/bin/bash#sh changeHtml.sh result_file#result_file' content#file's path line_no old_content new_contentfile=$1if [ -z $file ]then echo \"Input result_file\" exitfiwhile read linedo IFS=\"^\" arr=($line) filename=$&#123;arr[0]&#125; line_num=$&#123;arr[1]&#125; str_kr=$&#123;arr[2]&#125; if [ $str_kr ] then echo $filename echo $line_num echo $str_kr sed -i ''$line_num' c\\'$str_kr'' $filename else echo $line fidone &lt; $file 运行命令替换内容sh changeHtml.sh text.txt 运行完.asset的文件是没办法替换的，要手动自行替换 text.txt数据格式如下点击下载","categories":[{"name":"脚本工具","slug":"脚本工具","permalink":"http://zxtotti17.github.io/categories/%E8%84%9A%E6%9C%AC%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"redis笔记","slug":"redis笔记","date":"2018-08-01T08:52:31.000Z","updated":"2019-11-27T15:26:48.000Z","comments":true,"path":"2018/08/01/redis笔记/","link":"","permalink":"http://zxtotti17.github.io/2018/08/01/redis%E7%AC%94%E8%AE%B0/","excerpt":"Redis是什么、特点、优势redis是Key-Value数据库,数据包含各种数据 字符串String、字典Hash、列表List、集合Set、有序集合SortedSet等redis支持数据持久化，重启再次加载,支持数据备份(支持分布式),Redis是单进程单线程的Redis的优势性能高 读速度110000/s 写速度81000/s丰富的数据类型 redis安装（Linux）、启动、退出、设置密码、远程连接 1 安装redis下载redis安装包（如：redis-2.8.17.tar.gz） 1234tar -zxvf redis-2.8.17.tar.gzcd redis-2.8.17makesudo make install 2 后台启动服务端 1nohup redis-server &amp; 3 启动客户端、验证 1234cd /usr/local/binredis-cliset var \"hello world\"get var","text":"Redis是什么、特点、优势redis是Key-Value数据库,数据包含各种数据 字符串String、字典Hash、列表List、集合Set、有序集合SortedSet等redis支持数据持久化，重启再次加载,支持数据备份(支持分布式),Redis是单进程单线程的Redis的优势性能高 读速度110000/s 写速度81000/s丰富的数据类型 redis安装（Linux）、启动、退出、设置密码、远程连接 1 安装redis下载redis安装包（如：redis-2.8.17.tar.gz） 1234tar -zxvf redis-2.8.17.tar.gzcd redis-2.8.17makesudo make install 2 后台启动服务端 1nohup redis-server &amp; 3 启动客户端、验证 1234cd /usr/local/binredis-cliset var \"hello world\"get var Reis key序号 Redis keys命令及描述1 DEL key该命令用于在 key 存在是删除 key。2 DUMP key序列化给定 key ，并返回被序列化的值。3 EXISTS key检查给定 key 是否存在。4 EXPIRE key seconds为给定 key 设置过期时间。5 EXPIREAT key timestampEXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。6 PEXPIRE key milliseconds设置 key 的过期时间亿以毫秒计。7 PEXPIREAT key milliseconds-timestamp设置 key 过期时间的时间戳(unix timestamp) 以毫秒计8 KEYS pattern查找所有符合给定模式( pattern)的 key 。例如keys * 返回所有的key9 MOVE key db将当前数据库的 key 移动到给定的数据库 db 当中。10 PERSIST key移除 key 的过期时间，key 将持久保持。11 PTTL key以毫秒为单位返回 key 的剩余的过期时间。12 TTL key以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。13 RANDOMKEY从当前数据库中随机返回一个 key 。14 RENAME key newkey修改 key 的名称15 RENAMENX key newkey仅当 newkey 不存在时，将 key 改名为 newkey 。16 TYPE key返回 key 所储存的值的类型。…中文文档 Redis 发布订阅占时没用过，看起来跟微信公众号一样,Pub/Sub做延时队列可以用在玩家登录排队上 Redis事务一个事务从开始到结束经过以下三个阶段： 开始事务命令入队执行事务例子 1234567891011localhost:6379&gt; MULTIOKlocalhost:6379&gt; set name jihiteQUEUEDlocalhost:6379&gt; get nameQUEUEDlocalhost:6379&gt; sadd language \"c++\" \"python\" \"java\"QUEUEDlocalhost:6379&gt; smembers languageQUEUEDlocalhost:6379&gt; exec 说明：事务以MULTI开始，以EXEC结束 关闭持久化与持久化(RDB)bgsave做镜像全量持久化，aof做增量持久化RDB相当于快照，是fork一个子进程，快照成功后替换aof相当于日志，cow，copy and write,一条一条的数据 这是redis与其他缓存服务的比较明显的特点,如memcache修改配置文件，改完后重启。 123#save 900 1 #save 300 10 #save 60 10000 或执行操作命令 1CONFIG SET save \"\" redis相比memcached有哪些优势？ (1) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型(2) redis的速度比memcached快很多(3) redis可以持久化其数据 redis常见性能问题和解决方案： (1) Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件(2) 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次(3) 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内(4) 尽量避免在压力很大的主库上增加从库(5) 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3… 这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。 Redis 常见的性能问题都有哪些？如何解决？1).Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以Master最好不要写内存快照。2).Master AOF持久化，如果不重写AOF文件，这个持久化方式对性能的影响是最小的，但是AOF文件会不断增大，AOF文件过大会影响Master重启的恢复速度。Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化,如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。3).Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。4). Redis主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内 Redis分布式锁拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。 Redis做异步队列一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://zxtotti17.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://zxtotti17.github.io/tags/redis/"}]},{"title":"项目各种配置文件","slug":"项目各种配置文件","date":"2018-07-31T08:43:21.000Z","updated":"2019-11-27T15:26:48.000Z","comments":true,"path":"2018/07/31/项目各种配置文件/","link":"","permalink":"http://zxtotti17.github.io/2018/07/31/%E9%A1%B9%E7%9B%AE%E5%90%84%E7%A7%8D%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/","excerpt":"srpg.conf 12345678910111213141516171819202122232425262728server &#123; listen 80; listen 443 ssl;# server_name alctwobt.ssl.91dena.cn; server_name alccn2-release.ssl.91dena.cn;# ssl on; ssl_certificate /root/cert/91dena_cn.pem; ssl_certificate_key /root/cert/91dena_cn.key; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; ## APP 11 location / &#123; # proxy proxy_pass http://127.0.0.1:5000/; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # connect to backend with keepalives proxy_http_version 1.1; proxy_set_header Connection \"\"; proxy_send_timeout 30s; proxy_read_timeout 60s; proxy_connect_timeout 30s; &#125; access_log /home/log/nginxlog/cnrelease/alccn2.ssl.91dena.cn.access.log main; error_log /home/log/nginxlog/cnrelease/alccn2.ssl.91dena.cn.error.log;&#125; 点击下载","text":"srpg.conf 12345678910111213141516171819202122232425262728server &#123; listen 80; listen 443 ssl;# server_name alctwobt.ssl.91dena.cn; server_name alccn2-release.ssl.91dena.cn;# ssl on; ssl_certificate /root/cert/91dena_cn.pem; ssl_certificate_key /root/cert/91dena_cn.key; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; ## APP 11 location / &#123; # proxy proxy_pass http://127.0.0.1:5000/; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # connect to backend with keepalives proxy_http_version 1.1; proxy_set_header Connection \"\"; proxy_send_timeout 30s; proxy_read_timeout 60s; proxy_connect_timeout 30s; &#125; access_log /home/log/nginxlog/cnrelease/alccn2.ssl.91dena.cn.access.log main; error_log /home/log/nginxlog/cnrelease/alccn2.ssl.91dena.cn.error.log;&#125; 点击下载 nginx 123456789101112131415161718192021222324252627282930user nginx;worker_processes auto;worker_rlimit_nofile 150000;error_log /tmp/error.log;events &#123; worker_connections 65535; multi_accept on ;&#125;http &#123; include mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" $request_time' ' $status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\" $upstream_response_time'; access_log /tmp/access.log; sendfile on; tcp_nopush on; keepalive_timeout 120; gzip on; include /etcinx/title/*.conf;&#125; 点击下载 srpg-app 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#!/bin/bash### BEGIN INIT INFO# Provides: webapp# Required-Start: $syslog $remote_fs# Required-Stop: $syslog $remote_fs# Should-Start: $local_fs# Should-Stop: $local_fs# Default-Start: 2 3 4 5# Default-Stop: 0 1 6# Short-Description: Alchemist Webapp# Description: Alchemist Webapp### END INIT INFO#### BEGIN CHKCONFIG INFO# chkconfig: 2345 55 25# description: Alchemist Webapp### END CHKCONFIG INFOUSER=\"webapp\"NAME=\"webapp\"NODE_ENV=\"production\"NODE_BIN_DIR=\"/usr/localde/bin\"NODE_PATH=\"/usr/localdebde_modules\"APPLICATION_PATH=\"ar/webapps/alchemist/currentde/app/app.js\"APPLICATION_WORKDIR=\"ar/webapps/alchemist/currentde/app/\"APPLICATION_OPTION=\"\"LOGFILE=\"ar/webapps/alchemist/log/forever/app.log\"MIN_UPTIME=\"5000\"SPIN_SLEEP_TIME=\"10000\"PATH=$NODE_BIN_DIR:$PATHexport NODE_PATH=$NODE_PATHstart() &#123; echo `runuser -l \"$USER\" -c \"forever list\"` | grep -q \"$APPLICATION_PATH\" if [ \"$?\" -eq \"0\" ]; then echo \"$NAME is already running.\" RETVAL=0 else echo \"Starting $NAME\" runuser -l \"$USER\" -c \"\\ export NODE_ENV=$NODE_ENV &amp;&amp; forever \\ -a \\ -l $LOGFILE \\ --minUptime $MIN_UPTIME \\ --spinSleepTime $SPIN_SLEEP_TIME \\ --workingDir $APPLICATION_WORKDIR \\ start $APPLICATION_PATH $APPLICATION_OPTION\" 2&gt;&amp;1 &gt; /dev/null &amp; RETVAL=$? fi&#125;stop() &#123; echo `runuser -l \"$USER\" -c \"forever list\"` | grep -q \"$APPLICATION_PATH\" if [ \"$?\" -eq \"0\" ]; then echo \"Shutting down $NAME\" # Tell Forever to stop the process. runuser -l \"$USER\" -c \"forever stop $APPLICATION_PATH\" 2&gt;&amp;1 &gt; /dev/null RETVAL=$? else echo \"$NAME is not running.\" RETVAL=0 fi&#125;restart() &#123; stop start&#125;status() &#123; echo `runuser -l \"$USER\" -c \"forever list\"` | grep -q \"$APPLICATION_PATH\" if [ \"$?\" -eq \"0\" ]; then echo \"$NAME is running.\" RETVAL=0 else echo \"$NAME is not running.\" RETVAL=3 fi&#125;case \"$1\" in start) start ;; stop) stop ;; status) status ;; restart) restart ;; *) echo \"Usage: &#123;start|stop|status|restart&#125;\" exit 1 ;;esacexit $RETVAL 点击下载 td-agent 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138###### Output descriptions:### Treasure Data (http://www.treasure-data.com/) provides cloud based data# analytics platform, which easily stores and processes data from td-agent.# FREE plan is also provided.# @see http://docs.fluentd.org/articles/http-to-td## This section matches events whose tag is td.DATABASE.TABLE&lt;match td.*.*&gt; @type tdlog apikey YOUR_API_KEY auto_create_table buffer_type file buffer_path /var/log/td-agent/buffer/td &lt;secondary&gt; @type file path /var/log/td-agent/failed_records &lt;/secondary&gt;&lt;/match&gt;## match tag=debug.** and dump to console&lt;match debug.**&gt; @type stdout&lt;/match&gt;###### Source descriptions:#### built-in TCP input## @see http://docs.fluentd.org/articles/in_forward&lt;source&gt; @type forward&lt;/source&gt;## built-in UNIX socket input#&lt;source&gt;# @type unix#&lt;/source&gt;# HTTP input# POST http://localhost:8888/&lt;tag&gt;?json=&lt;json&gt;# POST http://localhost:8888/td.myapp.login?json=&#123;\"user\"%3A\"me\"&#125;# @see http://docs.fluentd.org/articles/in_http&lt;source&gt; @type http port 8888&lt;/source&gt;## live debugging agent&lt;source&gt; @type debug_agent bind 127.0.0.1 port 24230&lt;/source&gt;###### Examples:#### File input## read apache logs continuously and tags td.apache.access#&lt;source&gt;# @type tail# format apache# path /var/log/httpd-access.log# tag td.apache.access#&lt;/source&gt;## File output## match tag=local.** and write to file#&lt;match local.**&gt;# @type file# path /var/log/td-agent/access#&lt;/match&gt;## Forwarding## match tag=system.** and forward to another td-agent server#&lt;match system.**&gt;# @type forward# host 192.168.0.11# # secondary host is optional# &lt;secondary&gt;# host 192.168.0.12# &lt;/secondary&gt;#&lt;/match&gt;## Multiple output## match tag=td.*.* and output to Treasure Data AND file#&lt;match td.*.*&gt;# @type copy# &lt;store&gt;# @type tdlog# apikey API_KEY# auto_create_table# buffer_type file# buffer_path /var/log/td-agent/buffer/td# &lt;/store&gt;# &lt;store&gt;# @type file# path /var/log/td-agent/td-%Y-%m-%d/%H.log# &lt;/store&gt;#&lt;/match&gt;#&lt;match *.**&gt;# type file# path /var/log/td-agent/error.log#&lt;/match&gt;&lt;match alchemist.**&gt; type forward heartbeat_type tcp buffer_type file buffer_path /var/tmp/td-agent/forward.*.buffer buffer_chunk_limit 8m # チャンクサイズ buffer_queue_limit 256 # 1queueに保存できるchunk数の上限 flush_interval 1s # 10秒に1回送信 flush_at_shutdown true # シャットダウン時にチャンクを処理するか?(ファイルバッファのみ有効) retry_wait 5s # 再送実施までの待ち時間 retry_limit 2 # 再送実施回数 require_ack_response true expire_dns_cache 0 dns_round_robin true &lt;server&gt; host mongodb.alccn.91dena.cn port 24224 &lt;/server&gt; # ログ送信失敗時のファイル # # &lt;secondary&gt; # # type file # # path /var/log/td-agent/failed/forward-failed # #&lt;/secondary&gt; &lt;/match&gt; 点击下载","categories":[{"name":"开发环境安装","slug":"开发环境安装","permalink":"http://zxtotti17.github.io/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://zxtotti17.github.io/tags/nginx/"},{"name":"td-agent","slug":"td-agent","permalink":"http://zxtotti17.github.io/tags/td-agent/"}]},{"title":"ALC_Sentry","slug":"ALC-Sentry","date":"2018-07-24T08:06:55.000Z","updated":"2019-11-27T15:26:48.000Z","comments":true,"path":"2018/07/24/ALC-Sentry/","link":"","permalink":"http://zxtotti17.github.io/2018/07/24/ALC-Sentry/","excerpt":"1) 安装环境执行命令创建名为sentry的数据库createdb -E utf-8 sentry为sentry项目初始化数据sentry –config=/.sentry/sentry.conf.py upgrade创建新用户sentry –config=/.sentry/sentry.conf.py createuser然后就可以启动服务了sentry –config=/.sentry/sentry.conf.py start另外，还需要启动Workersentry –config=/.sentry/sentry.conf.py celery worker -B假设web服务器端口是9000，那么访问localhost:9000就能开始使用sentry了！ source /usr/local/vir-sentry/bin/activatesentry –config=~/.sentry/sentry.conf.py start &gt;&gt; /usr/local/vir-sentry/logs/sentry.log 2&gt;&amp;1 &amp;","text":"1) 安装环境执行命令创建名为sentry的数据库createdb -E utf-8 sentry为sentry项目初始化数据sentry –config=/.sentry/sentry.conf.py upgrade创建新用户sentry –config=/.sentry/sentry.conf.py createuser然后就可以启动服务了sentry –config=/.sentry/sentry.conf.py start另外，还需要启动Workersentry –config=/.sentry/sentry.conf.py celery worker -B假设web服务器端口是9000，那么访问localhost:9000就能开始使用sentry了！ source /usr/local/vir-sentry/bin/activatesentry –config=~/.sentry/sentry.conf.py start &gt;&gt; /usr/local/vir-sentry/logs/sentry.log 2&gt;&amp;1 &amp; 2）相关命令2.1启动su - webappsource /usr/local/vir-sentry/bin/activatesupervisord -c /etc/supervisord.confsupervisorctl start all2.2关闭命令su - webappsource /usr/local/vir-sentry/bin/activatesupervisorctl stop allkillall supervisord *创建账号 sentry createuser3)基于node的测试demoraven-node-master.zip 4.）界面显示 web 服务器相关配置","categories":[{"name":"开发环境安装","slug":"开发环境安装","permalink":"http://zxtotti17.github.io/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"}],"tags":[{"name":"Sentry","slug":"Sentry","permalink":"http://zxtotti17.github.io/tags/Sentry/"}]},{"title":"alchemist_manage服务器部署","slug":"alchemist-manage服务器部署","date":"2018-07-11T08:55:25.000Z","updated":"2019-11-27T15:26:48.000Z","comments":true,"path":"2018/07/11/alchemist-manage服务器部署/","link":"","permalink":"http://zxtotti17.github.io/2018/07/11/alchemist-manage%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/","excerpt":"manage服务器代码上传copy srpg_too 目录到 /var/webapps/alchemist_mnt (文件所有者必须为webapp) ruby运行环境构建 1 检查依赖 -ruby(v2.2.2p95~)-gem bundle-Node.js-npm-bower-msyql-redis2.1 设置gem源为淘宝源Gemfile （描述gem之间依赖文件）需要如下修改source ‘https://gems.ruby-china.org/&#39;2.2 安装gem filesu - webappbundle install2.2.1 安装bundle 命令不存在，。gem install bundle2.2.2 提示gem命令不存在，就执行rbenv global 2.2.2， 如果无法运行就重新安装ruby 2.2.2 版本，流程如下su - webappgit clone https://github.com/rbenv/rbenv.git ~/.rbenvcd ~/.rbenv &amp;&amp; src/configure &amp;&amp; make -C srcecho ‘export PATH=”$HOME/.rbenv/bin:$PATH”‘ &gt;&gt; ~/.bash_profile~/.rbenv/bin/rbenv initecho ‘eval “$(rbenv init -)”‘ &gt;&gt; ~/.bash_profilesource ~/.bash_profilegit clone https://github.com/rbenv/ruby-build.git ~/.rbenv/plugins/ruby-buildrbenv install 2.2.2rbenv global 2.2.2ruby -v","text":"manage服务器代码上传copy srpg_too 目录到 /var/webapps/alchemist_mnt (文件所有者必须为webapp) ruby运行环境构建 1 检查依赖 -ruby(v2.2.2p95~)-gem bundle-Node.js-npm-bower-msyql-redis2.1 设置gem源为淘宝源Gemfile （描述gem之间依赖文件）需要如下修改source ‘https://gems.ruby-china.org/&#39;2.2 安装gem filesu - webappbundle install2.2.1 安装bundle 命令不存在，。gem install bundle2.2.2 提示gem命令不存在，就执行rbenv global 2.2.2， 如果无法运行就重新安装ruby 2.2.2 版本，流程如下su - webappgit clone https://github.com/rbenv/rbenv.git ~/.rbenvcd ~/.rbenv &amp;&amp; src/configure &amp;&amp; make -C srcecho ‘export PATH=”$HOME/.rbenv/bin:$PATH”‘ &gt;&gt; ~/.bash_profile~/.rbenv/bin/rbenv initecho ‘eval “$(rbenv init -)”‘ &gt;&gt; ~/.bash_profilesource ~/.bash_profilegit clone https://github.com/rbenv/ruby-build.git ~/.rbenv/plugins/ruby-buildrbenv install 2.2.2rbenv global 2.2.2ruby -v Cap环境部署 1 配置SSH无密码登录配置config/deploy/produciton.rb ssh无密码登陆（id_rsa.pub和authorized_keys） 设置authorized_keys，记得chmod 600，否则无法生效） 1.1 生成sshkey:cd ~/.sshssh-keygen输入公钥名：id_rsa 1.2 配置authorized_keyscat id_rsa.pub &gt;&gt; authorized_keyschmod -R 600 authorized_keyschmod 700 /.ssh备注：如果还是无法实现无密码登录，再清空下/.ssh/koown_hosts文件（echo “” &gt; ~/.sshown_hosts); 1.3执行以下deploy命令：production环境为例cd currentbundle exec cap production mkdir:socketsbundle exec cap production bower:install 前端bower模块安装 1 Node.js 安装bowernpm install -g bower –registry=https://registry.npm.taobao.org (-g不一定要) 2install Bowerfilebundle exec rake bower:install 3 manage server DB构建bundle exec rake maint:create maint:migrate 4.4 添加管理账号 bundle exec rake maint:seed 4.5 配置crontab 缺少crontab 会影响预约奖励发放 cd 根目录（current/） gem install whenever ，检查config/schedule.rb是否存在 whenever -w（写入到crontab 中） 查看log/cron_log.log日志是否已生成。","categories":[{"name":"开发环境安装","slug":"开发环境安装","permalink":"http://zxtotti17.github.io/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"}],"tags":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"http://zxtotti17.github.io/tags/Ruby-on-Rails/"},{"name":"Capistrano 自动部署工具","slug":"Capistrano-自动部署工具","permalink":"http://zxtotti17.github.io/tags/Capistrano-%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%B7%A5%E5%85%B7/"}]},{"title":"hexo 常用笔记","slug":"hexo-安装遇到的问题","date":"2018-07-03T09:39:12.000Z","updated":"2020-06-24T08:41:06.046Z","comments":true,"path":"2018/07/03/hexo-安装遇到的问题/","link":"","permalink":"http://zxtotti17.github.io/2018/07/03/hexo-%E5%AE%89%E8%A3%85%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"建站的过程网上一大把就不记录了，主要写下遇到的几个问题 github上的项目名称一定要和自己在github上的用户名一致，否则会生成静态文件后点开会白屏 多看看官方手册上面有详细记录https://hexo.io/zh-cn/docs hexo g -dhexo cleanhexo shexo目录下执行这样一句话npm install hexo-asset-image –save，这是下载安装一个可以上传本地图片的插件,再运行hexo n “xxxx”来生成md博文 npm install hexo-generator-json-content –save index_generator: per_page: 9 ##首页默认9篇文章标题 如果值为0不分页archive_generator: per_page: 100 ##归档页面默认100篇文章标题 yearly: true ##生成年视图 monthly: true ##生成月视图tag_generator: per_page: 100 ##标签分类页面默认100篇文章category_generator: per_page: 100 ###分类页面默认100篇文章","categories":[{"name":"开发环境安装","slug":"开发环境安装","permalink":"http://zxtotti17.github.io/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://zxtotti17.github.io/tags/node-js/"},{"name":"hexo","slug":"hexo","permalink":"http://zxtotti17.github.io/tags/hexo/"}]}],"categories":[{"name":"数据库","slug":"数据库","permalink":"http://zxtotti17.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"服务端框架","slug":"服务端框架","permalink":"http://zxtotti17.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"name":"开发语言","slug":"开发语言","permalink":"http://zxtotti17.github.io/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"},{"name":"脚本工具","slug":"脚本工具","permalink":"http://zxtotti17.github.io/categories/%E8%84%9A%E6%9C%AC%E5%B7%A5%E5%85%B7/"},{"name":"开发环境安装","slug":"开发环境安装","permalink":"http://zxtotti17.github.io/categories/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"}],"tags":[{"name":"游戏","slug":"游戏","permalink":"http://zxtotti17.github.io/tags/%E6%B8%B8%E6%88%8F/"},{"name":"Erlang","slug":"Erlang","permalink":"http://zxtotti17.github.io/tags/Erlang/"},{"name":"c++ 设计模式","slug":"c-设计模式","permalink":"http://zxtotti17.github.io/tags/c-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"mysql","slug":"mysql","permalink":"http://zxtotti17.github.io/tags/mysql/"},{"name":"node.js","slug":"node-js","permalink":"http://zxtotti17.github.io/tags/node-js/"},{"name":"redis","slug":"redis","permalink":"http://zxtotti17.github.io/tags/redis/"},{"name":"nginx","slug":"nginx","permalink":"http://zxtotti17.github.io/tags/nginx/"},{"name":"td-agent","slug":"td-agent","permalink":"http://zxtotti17.github.io/tags/td-agent/"},{"name":"Sentry","slug":"Sentry","permalink":"http://zxtotti17.github.io/tags/Sentry/"},{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"http://zxtotti17.github.io/tags/Ruby-on-Rails/"},{"name":"Capistrano 自动部署工具","slug":"Capistrano-自动部署工具","permalink":"http://zxtotti17.github.io/tags/Capistrano-%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%B7%A5%E5%85%B7/"},{"name":"hexo","slug":"hexo","permalink":"http://zxtotti17.github.io/tags/hexo/"}]}